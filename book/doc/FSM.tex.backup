% This file was converted to LaTeX by Writer2LaTeX ver. 1.0.2
% see http://writer2latex.sourceforge.net for more info
\documentclass[a4paper]{article}
\usepackage[latin1]{inputenc}
\usepackage{listings}
\usepackage[T1]{fontenc}
\usepackage[spanish,es-noshorthands]{babel}
\usepackage{amsmath}
\usepackage{amssymb,amsfonts,textcomp}
\usepackage{color}
\usepackage[top=2.501cm,bottom=2.501cm,left=3cm,right=3cm,nohead,nofoot]{geometry}
\usepackage{array}
\usepackage{supertabular}
\usepackage{hhline}
\usepackage{hyperref}
\hypersetup{pdftex, colorlinks=true, linkcolor=blue, citecolor=blue, filecolor=blue, urlcolor=blue, pdftitle=1}
\usepackage[pdftex]{graphicx}
\makeatletter
\newcommand\arraybslash{\let\\\@arraycr}
\makeatother
% Footnote rule
\setlength{\skip\footins}{0.119cm}
\renewcommand\footnoterule{\vspace*{-0.018cm}\setlength\leftskip{0pt}\setlength\rightskip{0pt plus 1fil}\noindent\textcolor{black}{\rule{0.25\columnwidth}{0.018cm}}\vspace*{0.101cm}}
% Pages styles
\makeatletter
\newcommand\ps@Standard{
  \renewcommand\@oddhead{}
  \renewcommand\@evenhead{}
  \renewcommand\@oddfoot{}
  \renewcommand\@evenfoot{}
  \renewcommand\thepage{\arabic{page}}
}
\makeatother
\pagestyle{Standard}
\setlength\tabcolsep{1mm}
\renewcommand\arraystretch{1.3}
\newcommand\normalsubformula[1]{\text{\mathversion{normal}$#1$}}
\title{1}



\lstset{ language=VHDL}



\begin{document}

\section{Ejemplos de Aplicaciones del VHDL.}

\subsection[INTRODUCCION]{ INTRODUCCION}
{
En los capítulos anteriores se describió el proceso de diseño para sistemas digitales y las herramientas disponibles (tanto software como hardware) para su implementación. En este capítulo se trataran ejemplos prácticos de diseño de sistemas digitales, iniciando con su descripción hasta llegar a su implementación final utilizando en algunos casos componentes discretos y VHDL.}

\subsection[¿QUE ES UNA FSM?]{ ¿QUE ES UNA FSM?}
Una máquina de estados es un sistema secuencial sincrónico que posee un número fijo de posibles estados. El valor de sus salidas y la transición entre los estados depende del valor de sus entradas y del estado en que se encuentra actualmente. \textbf{Todos los cambios de estado ocurren ante un determinado flanco de la señal de reloj }(ya sea de subida o bajada).

Para entender mejor este concepto imaginemos que nuestra máquina de estados es un televisor, que sólo puede sintonizar cuatro canales y que
se puede controlar por un control remoto que tiene solo dos teclas para aumentar o disminuir el canal. Los estados de nuestro sistema están
representados por el número de canales que se pueden sintonizar, así pues, solo tendremos cuatro posibles estados (Número fijo de estados).
En la Figura 1 se muestra un diagrama de nuestro sistema:

{\centering 
\includegraphics[width=5.715cm,height=3.122cm]{FSM-img1.png} \par}

{\centering
Figura 1. Ejemplo de FSM.
\par}

Ahora hagámonos una pregunta: ¿Qué nos produce un cambio en el estado de nuestro sistema?, Lo único que nos puede producir un cambio de estado
(Canal sintonizado) es un cambio en las teclas de nuestro control remoto (Entradas del sistema). Observemos como actúa el sistema ante cambios de las entradas:

Si oprimimos la tecla de aumentar el canal, el televisor aumentará en uno la cadena sintonizada, por ejemplo, si estaba en el canal 1 pasará
al 2, si estaba en el 2 al 3, del 3 al 4 y del 4 al 1 nuevamente.

Si oprimimos la tecla menos es canal diminuirá pasando del 4 al 3, del 3 al 2, del 2 al 1 y del 1 al 4 nuevamente.
Si no oprimimos una tecla, el televisor debe permanecer en la cadena sintonizada actualmente y quedarse ahí hasta que se le ordene un cambio
por medio del control remoto.

Note que el estado (canal sintonizado) al que pasará el sistema depende del estado actual (canal actual) y de las entradas (tecla del control
remoto oprimida). Si las entradas no cambian el sistema no cambia su posición (esto no es necesariamente cierto para todas las máquinas de
estado).

\subsection[TABLAS Y DIAGRAMAS DE ESTADO]{TABLAS Y DIAGRAMAS DE ESTADO}

Existen varias formas de representar el comportamiento de las máquinas
de estado, siendo los más utilizados las tablas y los diagramas de
estado. Tomemos nuevamente el ejemplo del televisor y representemos en
una tabla los estados actual y siguiente (Estado al que pasa el sistema
ante un cambio de las entradas).

{\centering 
\includegraphics[width=9.206cm,height=3.651cm]{FSM-img2.png} \par}

{\centering
Figura 2. Entradas y salidas del Sistema.
\par}

La Figura 2 muestra el sistema como una caja negra en la que sólo se indican las entradas y las salidas. Supongamos que nuestro sistema tiene dos entradas que son las correspondientes a Adelantar (UP) y disminuir (DN) canal, y que tiene cuatro salidas C1, C2, C3, C4 que corresponden a los cuatro canales y que me indican cual canal se está sintonizando actualmente. En este punto debemos tomar varias decisiones:

¿Cuando se considera que una entrada esta activa?, Es decir, con que valor lógico de la entrada se produce un cambio y con cual no. En nuestro caso un valor lógico alto en las entradas producirá un cambio de estado, es decir, si UP = {\textquoteleft}1{\textquoteright} el canal sintonizado aumentará o si DN = {\textquoteleft}1{\textquoteright} el canal disminuirá. Otra decisión que debemos tomar y que se deriva de esta es: que sucede si por error las dos entradas son {\textquoteleft}1{\textquoteright} simultáneamente, lo más conveniente es que el sistema conserve su estado ante esta posible situación.

El valor de las salidas para cada estado, en este ejemplo, un uno lógico en una salida indica que el canal ha sido seleccionado (por ejemplo, un
uno en C1 indicara que actualmente el canal seleccionado es el 1), por lo tanto sólo una salida puede tener un valor lógico alto.

Una vez definido completamente el funcionamiento de nuestro sistema se procede  a representarlo mediante una tabla de estados:

\subsubsection[Tabla de Estados]{ Tabla de Estados}
{\centering 
\includegraphics[width=14.991cm,height=3.895cm]{FSM-img3.png} \par}

{\centering
Figura 3. Tabla de estados del sistema Televisor.
\par}

La Figura 3. Muestra una tabla de estados típica en la cual se resume el comportamiento del sistema. La tabla tiene tres secciones: El estado actual: Lista de todos lo posibles estados.

Posibles combinaciones de las entradas: El número de entradas del sistema determina el número de columnas de la tabla de estados. Así, si la máquina tiene n entradas, la tabla tendrá 2\textsuperscript{n} +1 Columnas.

El estado siguiente: Indica a que estado pasará la FSM cuando se presente una determinada entrada, Por ejemplo, Si UP=0 y DOWN = 1 y el estado actual es el canal 4 la máquina de estados irá al estado Canal 3.

Otra forma de representar el estado de las entradas es utilizando una convención en la que si la variable aparece negada entonces toma un valor de cero lógico, pero si no lo esta tiene un valor de uno lógico. Esto se hace para simplificar las tablas. Por ejemplo:


A:\ \ A = {\textquoteleft}1{\textquoteright}

{!A:\ \ A = 0;}

Con lo que la tabla de estados se convierte en :

\begin{center}
\tablehead{}
\begin{supertabular}{|m{2.441cm}|m{1.8739998cm}|m{1.68cm}|m{1.68cm}|m{1.486cm}|m{2.3309999cm}|}
\hline &
\multicolumn{4}{m{7.32cm}|}{\centering  Estado Siguiente} &
\centering\arraybslash  Salidas\\\hline
\centering  Estado Actual &
\centering  !UP.!DN &
\centering  !UP.DN &
\centering  UP.!DN &
\centering  UP.DN &
\centering\arraybslash  C1,C2,C3,C4\\\hline
\centering  Canal 1 &
\centering  Canal 1 &
\centering  Canal 4 &
\centering  Canal 2 &
\centering  Canal 1 &
\centering\arraybslash  1,0,0,0\\\hline
\centering  Canal 2 &
\centering  Canal 2 &
\centering  Canal 1 &
\centering  Canal 3 &
\centering  Canal 2 &
\centering\arraybslash  0,1,0,0\\\hline
\centering  Canal 3 &
\centering  Canal 3 &
\centering  Canal 2 &
\centering  Canal 4 &
\centering  Canal 3 &
\centering\arraybslash  0,0,1,0\\\hline
\centering  Canal 4 &
\centering  Canal 4 &
\centering  Canal 3 &
\centering  Canal 1 &
\centering  Canal 4 &
\centering\arraybslash  0,0,0,1\\\hline
\end{supertabular}
\end{center}
{\centering
Tabla 1. Tabla de Estados del sistema Televisor.
\par}

\subsubsection[Diagrama de Estados]{ Diagrama de Estados}

Otra forma de representar el comportamiento de una máquina de estados es el diagrama de estados, este diagrama es una representación gráfica del
funcionamiento del sistema. 

 \includegraphics[width=12.751cm,height=5.556cm]{FSM-img4.png}

{\centering Figura 4. Diagrama de estados del sistema Televisor. \par}

La Figura 4 muestra el diagrama de bloques del sistema televisor. Observamos que cada estado está representado por un círculo en el que se indica el nombre del mismo y el valor de las salidas. Las líneas que unen los estados representan el cambio que sufre la máquina cuando se cumple una determinada regla de transición. (La regla de transición normalmente se indican en las líneas que unen los estados). En esta figura se introduce una nueva nomenclatura para representar las funciones lógicas, el operador \textbf{\textit{not}} se representa con el signo \textbf{\textit{!}}, la operación \textbf{\textit{AND}} con el signo \textbf{\textit{\&}} y la \textbf{\textit{OR}} con \textbf{\textit{\#}}.

Podemos observar que del estado Canal1, salen dos líneas: Una hacia el estado Canal2, lo que indica que la máquina pasará de Canal1 a Canal2 si UP = {\textquoteleft}1{\textquoteright} y DN = {\textquoteleft}0{\textquoteright} y se presenta un flanco adecuado en
la señal de reloj; Otra hacia el estado Canal4, lo que indica que la máquina de estados pasará de Canal1 a Canal4 si UP = {\textquoteleft}0{\textquoteright},  DN = {\textquoteleft}1{\textquoteright} y se presenta un flanco adecuado en la señal de reloj.

Así mismo tenemos dos líneas que llegan al Estado Canal1: Una proviene del estado Canal2, con lo que el sistema pasará de Canal2 a Canal 1 si UP = {\textquoteleft}0{\textquoteright}, DN = {\textquoteleft}1{\textquoteright} y se presenta un flanco adecuado en la señal de reloj; y otra desde el estado Canal4. lo que hace que el sistema pase de Canal4 a Canal 1 si UP = {\textquoteleft}1{\textquoteright} y DN = {\textquoteleft}0{\textquoteright} y se presenta un flanco adecuado en la señal de reloj.

Por último existe una curva que sale del Canal1 y vuelve a entrar a Canal1, esto indica que la máquina mantendrá su estado si: (UP 
= {\textquoteleft}0{\textquoteright} Y DN = {\textquoteleft}0{\textquoteright} ) O (UP = {\textquoteleft}1{\textquoteright} Y DN = {\textquoteleft}1{\textquoteright}).

\subsection[SINTESIS DE FSM]{ SINTESIS DE FSM}

En esta sección analizaremos la arquitectura de la FSM y el proceso de síntesis. Como vimos en el capítulo anterior la síntesis parte de una descripción funcional y llega a una descripción a nivel de compuertas.

 \includegraphics[width=12.27cm,height=6.04cm]{FSM-img5.png} 

{\centering Figura 5. Estructura de una FSM. \par}

\subsubsection[Estructura de una FSM]{ Estructura de una FSM}
La estructura general de una máquina de estados se muestra en la  Figura 5. Como puede observarse existen tres bloques bien definidos:

Lógica de estado siguiente: Está encargada de generar las señales necesarias para producir un cambio de estado en la FSM (Estado Siguiente). Puede observarse que el estado siguiente depende del estado actual y de las entradas 

Memoria de Estado: Normalmente esta formada por Flip-Flops tipo D o JK, los cuales tienen la misma señal de reloj. Las salidas de los Flip-Flops determinan el estado actual de la FSM, cada salida del Flip-Flop puede tomar dos valores distintos {\textquoteleft}1{\textquoteright} o
{\textquoteleft}0{\textquoteright}, por lo tanto se pueden tener dos estados con un Flip-Flop. Si tenemos N Flip-Flops tendremos 2\textsuperscript{N} estados.

Lógica de Salida: La lógica de salida esta encargada de producir los valores necesarios a la salida de la FSM, su la arquitectura esta basada en decodificadores. 

Existen dos tipos de máquinas de estados: Moore: El estado siguiente depende del valor de las entradas y del estado actual; Y la salida depende únicamente del estado actual; y Mealy: Al igual que la máquina de Moore el estado siguiente depende del valor de las entradas y del estado actual, pero se diferencian en que la salida depende del estado actual y del valor de las entradas.

\subsubsection[Proceso de Síntesis]{ Proceso de Síntesis}

El primer paso en el proceso de síntesis de una FSM y en general de cualquier sistema digital es la descripción del sistema ya sea mediante
un algoritmo o de un diagrama de tiempos. El siguiente paso consiste en pasar la descripción funcional a un diagrama de estados para su posterior representación en tablas de estado y de salida. A continuación debemos reducir el número de estados (si es posible) utilizando algoritmos de minimización. Después debemos realizar la codificación de estados, es decir, asignarle a los estados un grupo único de valores que corresponden a los valores que tomarán los Flip-Flops. A continuación se debemos obtener las ecuaciones de estado siguiente y de salidas. El siguiente paso consiste en la elección del tipo de Flip-Flop que se va a utilizar para la implementación, recuerde que todos los Flip\_Flops tienen diferentes ecuaciones de estado siguiente:

\begin{center}
\tablehead{}
\begin{supertabular}{|m{2.142cm}|m{3.61cm}|}
\hline
\centering  Tipo de F-F &
\centering\arraybslash  Estado Siguiente
(Q\textsuperscript{*})\\\hline
\centering  D &
\centering\arraybslash  Q* = D\\\hline
\centering  JK &
\centering\arraybslash  Q* = J,!Q + !K.Q\\\hline
\centering  T &
\centering\arraybslash  Q* = !Q\\\hline
\centering  SR &
\centering\arraybslash  Q* = S + !R.Q\\\hline
\end{supertabular}
\end{center}

{\centering Tabla 2. Ecuaciones de Estado siguiente de los Flip-Flop. \par}

Una vez elegido el Flip-Flop se procede a obtener las ecuaciones de las señales de excitación de los FFs. Después se de be realizar un proceso
de minimización con las ecuaciones obtenidas anteriormente para realizar un diagrama de la implementación lógica de las ecuaciones. Finalmente debemos verificar el correcto funcionamiento del circuito, esto se logra simulando el circuito obtenido y si cumple con lo requerimientos se llevará al plano físico para realizar pruebas de tiempos. La figura 6 resume los pasos a seguir en el proceso de síntesis.

{\centering \includegraphics[width=9.135cm,height=12.734cm]{FSM-img6.png} \par}

{\centering Figura 6. Diagrama de flujo del proceso de Síntesis para FSM \par}

Para entender mejor el proceso de síntesis realizaremos paso a paso un sencillo ejemplo. Desarrollando todas las posibilidades de implementación para buscar la más óptima.

\subsubsection[Control de Motor de Paso.]{Control de Motor de Paso.}

Un motor de paso a diferencia de los motores de Corriente Continua necesita una secuencia determinada en sus cuatro terminales para originar el giro de su rotor. La secuencia necesaria para controlar el motor es la siguiente:

\begin{center}
\tablehead{}
\begin{supertabular}{|m{2.679cm}|m{2.892cm}|m{2.892cm}|m{2.892cm}|m{2.945cm}|}
\hline
 &
\centering  A & \centering  B & \centering  C & \centering\arraybslash  D\\\hline
\centering  S1 & \centering  V+ & \centering  GND & \centering  V+ & \centering\arraybslash  GND\\\hline
\centering  S2 & \centering  V+ & \centering  GND & \centering  GND & \centering\arraybslash  V+\\\hline
\centering  S3 & \centering  GND & \centering  V+ & \centering  GND & \centering\arraybslash  V+\\\hline
\centering  S4 & \centering  GND & \centering  V+ & \centering  V+ & \centering\arraybslash  GND\\\hline
\end{supertabular}
\end{center}
Para que el motor gire un paso (normalmente 1.8 grados) es necesario que se aplique S1 y luego S2, o S2 y S3 o S3 y S4 o S4 y S1. Si se desea que el motor gire cinco pasos se debe seguir la secuencia S1, S2, S3, S4, S5. La inversión del sentido de giro se logra invirtiendo la secuencia anterior, es decir, S1, S4, S3, S2, S1.

\paragraph[Diagrama de Caja Negra]{Diagrama de Caja Negra}

El primer paso consiste en realizar un diagrama de caja negra en el que se indiquen las entradas y salidas (Figura 7).

\includegraphics[width=11.023cm,height=4.064cm]{FSM-img7.png} 
Figura 7. Diagrama de Caja Negra del Controlador de Motor de Paso.

A continuación realizaremos una breve descripción del funcionamiento del circuito. Como se observa en la Figura 7. Se tienen tres entradas:

DIR: Encargada de indicar la dirección de giro del motor. DIR = 0 Secuencia Directa (S1, S2, S3, S4), DIR = 1 Secuencia Invertida (S4, S3, S2, S1)
EN: ENABLE, encargada de habilitar nuestro control Si EN = 1 el circuito realizará su función si EN = 0 el control conservará el último estado
de las salidas. 

CLOCK: Es el reloj del sistema y gobierna todas las transiciones entre estados. 
Y las cuatro salidas A, B, C, D son las encargadas de manejar los terminales del motor de paso.

\paragraph[Diagrama de Estado]{ Diagrama de Estado}

Una vez se conoce el funcionamiento del circuito, o las funciones que debe cumplir se procede a realizar el diagrama de estados del mismo. La
Figura 8 muestra este diagrama para el controlador de motor de paso.

{\centering \includegraphics[width=11.719cm,height=7.142cm]{FSM-img8.png} \par}
Figura 8 Diagrama de Estados del Controlador de Motor de Paso.

\paragraph[Tabla de estados]{ Tabla de estados}

Una vez realizado el diagrama de estados se procede a la realización de la tabla de estados y salidas. Dicha tabla para el controlador de motor
de paso se presente a continuación:

\begin{center}
\tablehead{}
\begin{supertabular}{|m{2.5379999cm}|m{1.798cm}|m{1.714cm}|m{1.714cm}|m{1.629cm}|m{1.9549999cm}|}
\hline  &
\multicolumn{4}{m{7.4550004cm}|}{\centering 
Estado Siguiente} &
\centering\arraybslash  Salidas\\\hline
\centering  Estado Actual &
\centering  !EN.!DIR &
\centering  !EN.DIR &
\centering  EN.!DIR &
\centering  EN.DIR &
\centering\arraybslash  A, B, C, D\\\hline
\centering  S1 &
\centering  S1 &
\centering  S1 &
\centering  S2 &
\centering  S4 &
\centering\arraybslash  1, 0, 1, 0\\\hline
\centering  S2 &
\centering  S2 &
\centering  S2 &
\centering  S3 &
\centering  S1 &
\centering\arraybslash  1, 0, 0, 1\\\hline
\centering  S3 &
\centering  S3 &
\centering  S3 &
\centering  S4 &
\centering  S2 &
\centering\arraybslash  0, 1, 0, 1\\\hline
\centering  S4 &
\centering  S4 &
\centering  S4 &
\centering  S1 &
\centering  S3 &
\centering\arraybslash  0, 1, 1, 0\\\hline
\end{supertabular}
\end{center}

\paragraph[Minimización de Estados]{Minimización de Estados}

El objetivo de la minimización de estados es la reducción del número de Flip-Flops necesarios para la implementación, reduciendo de este modo el costo de la misma. Sin embargo para reducir el número de Flip-Flops de un circuito es necesario reducir el número de estados en múltiplos de 2. Por ejemplo, supongamos que tenemos 7 estados, para lo cual necesitamos 3 FFs, para utilizar sólo 2 FFs necesitamos reducir el número de estados de 7 a 4 o menos.

La minimización de estados se basa en la equivalencia funcional, por ejemplo, se dice que dos circuitos son equivalentes cuando proporcionan la misma salida ante los mismos cambios de entrada. Dos o más estados son equivalentes sí:

Ambos estados producen las mismas salidas ante igual cambio en las señales de entrada.
Ambos estados tienen los mismos estados siguientes ante los mismos cambios de las señales de entrada.

En nuestro caso no tenemos equivalentes ya que todos tienen diferentes valores de salida y diferentes estados siguientes ante variaciones de
las entradas.

\paragraph[Codificación de estados]{Codificación de estados}
La codificación de estados consiste en la asignación de valores a las salidas de los FFs para cada estado, estos valores deben ser únicos para cada estado, es decir, no se deben repetir. Debido a que nuestra máquina tiene cuatro estados, tenemos 2 FFs y por lo tanto debemos asignar a cada estado un código formado por dos bits. Existen muchas posibles codificaciones para los cuatro estados, unas más eficientes que otras. En este libro no se tratarán las técnicas existentes para hallar la codificación óptima ya que esta función las realizan las herramientas CAD y además, se sale del objetivo de este libro. Para nuestro ejemplo utilizaremos la siguiente codificación:

\begin{center}
\tablehead{}
\begin{supertabular}{|m{0.67800003cm}|m{0.791cm}|m{0.84400004cm}|}
\hline  &
\centering  Q1 & \centering\arraybslash  Q0\\\hline 
\centering  S1 & \centering  0 & \centering\arraybslash  0\\\hline
\centering  S2 & \centering  0 & \centering\arraybslash  1\\\hline
\centering  S3 & \centering  1 & \centering\arraybslash  0\\\hline
\centering  S4 & \centering  1 & \centering\arraybslash  1\\\hline
\end{supertabular}
\end{center}

Donde Q1 y Q0 son las salidas del primer y segundo FF correspondientemente. Con esta asignación de estados la tabla de estados queda de la siguiente forma:

\begin{center}
\tablehead{}
\begin{supertabular}{|m{0.791cm}|m{0.791cm}|m{0.897cm}|m{0.897cm}|m{0.897cm}|m{0.897cm}|m{0.897cm}|m{0.897cm}|m{1.98cm}|}
\hline
\multicolumn{2}{|m{1.782cm}|}{\centering {Estado Actual}\par
\centering  (S)} &
\multicolumn{6}{m{6.3820004cm}|}{\centering 
Estado Siguiente (S\textsuperscript{*})} &
\centering\arraybslash 
SALIDAS\\\hhline{~~------~}
 &  &
\multicolumn{2}{m{1.994cm}|}{\centering  !EN} &
\multicolumn{4}{m{4.188cm}}{\centering  EN} &
\\\hhline{~~-------}  &  &  &  &
\multicolumn{2}{m{1.994cm}|}{\centering  !DIR} &
\multicolumn{2}{m{1.994cm}|}{\centering  DIR} &
\centering\arraybslash  A, B, C, D\\\hline
\centering  Q1 & \centering  Q0 & 
\centering  Q1\textsuperscript{*} &
\centering  Q0\textsuperscript{*} &
\centering  Q1\textsuperscript{*} &
\centering  Q0\textsuperscript{*} &
\centering  Q1\textsuperscript{*} &
\multicolumn{1}{m{0.897cm}}{\centering 
Q0\textsuperscript{*}} &
\\\hline
\centering  0 & \centering  0 & \centering  0 & \centering  0 & \centering  0 & \centering  1 & \centering  1 & \centering  1 &
\centering\arraybslash  1, 0, 1, 0\\\hline
\centering  0 & \centering  1 & \centering  0 & \centering  1 & \centering  1 & \centering  0 & \centering  0 & \centering  0 &
\centering\arraybslash  1, 0, 0, 1\\\hline 
\centering  1 & \centering  0 & \centering  1 & \centering  0 & \centering  1 & \centering  1 & \centering  0 & \centering  1 &
\centering\arraybslash  0, 1, 0, 1\\\hline
\centering  1 & \centering  1 & \centering  1 & \centering  1 & \centering  0 & \centering  0 & \centering  1 & \centering  0 &
\centering\arraybslash  0, 1, 1, 0\\\hline
\end{supertabular}
\end{center} 


Donde Q1\textsuperscript{*} y Q0\textsuperscript{*} representan los valores siguientes de las señales Q1 y Q0 respectivamente. Note que no
se representaron los casos !EN.!DIR y !EN.DIR, esto se debe a que cuando la señal En tiene un valor lógico bajo la FSM conserva su estado
sin importar el valor de DIR.

\paragraph[Ecuaciones de estado siguiente]{Ecuaciones de estado siguiente}

Una vez realizada la codificación de estados se procede a la obtención de las ecuaciones de estado siguiente Q1\textsuperscript{*} y  Q0\textsuperscript{*}. Para obtener estas ecuaciones debemos sumar todos los unos de la tabla de estados (suma de minitérminos). Para Q1\textsuperscript{*} debemos observar todas las columnas correspondientes a Q1\textsuperscript{*} y sumar los minitérminos asociados. Por ejemplo, la primera columna de Q1* correspondiente a la asociada con !EN, el primer minitérmino asociado es: !EN.Q1.!Q0 ya que está en la fila correspondiente a Q1 = 1 y Q0 = 0. Y el segundo !EN.Q1.Q0. \\

{Q1\textsuperscript{*} = !EN.Q1.!Q0 + !EN.Q1.Q0 + EN.!DIR.!Q1.Q0 + EN.!DIR.Q1.!Q0 + EN.DIR.!Q1.!Q0 + EN.DIR.Q1.Q0.\\
Q0\textsuperscript{*} = !EN.!Q1.Q0 + !EN.Q1.Q0 + EN.!DIR.!Q1.!Q0 + EN.!DIR.Q1.!Q0 + EN.DIR.!Q1.!Q0 + EN.DIR.Q1.!Q0.}

Estas ecuaciones deben pasar a través de un proceso de minimización para encontrar una implementación óptima.

Q1* = !EN.Q1(!Q0+Q1) + EN.(!DIR.(!Q1.Q0 + Q1.!Q0) + DIR (!Q1.!Q0 + Q1.Q0)) \\
Q1* = !EN.Q1 + EN.(!DIR.Q1 Q0 + DIR.!(Q1 Q0)) \\
Q1* = !EN.Q1 + EN.DIR (Q1 XOR Q0) \\
Q0* = !EN.Q0.(!Q1 + Q1) + EN.(!Q1.!Q0.(!DIR + DIR) + Q1.!Q0.(!DIR + DIR)) \\
Q0* = !EN.Q0 + EN.(!Q1.!Q0 + Q1.!Q0) \\
Q0* = !EN.Q0 + EN.(!Q0.(!Q1+ Q1)) \\
Q0* = !EN.Q0 + EN.!Q0 \\
Q0* = EN XOR Q0 \\

Las ecuaciones para las salidas son:

{A = !Q1.!Q0 + !Q1.Q0 = !Q1}
{B = Q1.!Q0 + Q1.Q0 = Q1}
{C = !Q1.!Q0 + Q1.Q0 = !(Q1 Q0)}
{D = !Q1.Q0 + Q1.!Q0 = Q1 Q0}
{A = !B = !Q1}
{C = !D = Q1 XOR Q0}

\paragraph[Elección del tipo de Flip{}-Flop, ecuaciones de excitación y minimización]{ Elección del tipo de Flip-Flop, ecuaciones de excitación y minimización}

Utilizando las ecuaciones obtenidas anteriormente para Q1* y Q0*, debemos escoger el tipo de Flip-Flop a utilizar. La siguiente tabla resume los valores necesarios en las entradas de los FFs para obtener los cambios indicados en sus salidas. Por ejemplo en un FF JK si Q tiene un valor de 0 lógico y se quiere que pase a tener un valor de 1 lógico es necesario que J = 1 y el valor de K no importa.

\begin{center}
\tablehead{}
\begin{supertabular}{|m{1.2689999cm}|m{0.95699996cm}|m{0.95699996cm}|m{0.55cm}|m{0.663cm}|}
\hline
\centering  Q  Q* & \centering  S  R & \centering  J  K & \centering  T & \centering\arraybslash  D\\\hline
\centering  0  0 & \centering  0  X & \centering  0  X & \centering  0 & \centering\arraybslash  0\\\hline
\centering  0  1 & \centering  1  0 & \centering  1  X & \centering  1 & \centering\arraybslash  1\\\hline
\centering  1  0 & \centering  0  1 & \centering  X  1 & \centering  1 & \centering\arraybslash  0\\\hline
\centering  1  1 & \centering  X  0 & \centering  X  0 & \centering  0 & \centering\arraybslash  1\\\hline
\end{supertabular}
\end{center}

El diagrama de Karnough para la máquina de estados es el siguiente

\begin{center}
\tablehead{}
\begin{supertabular}{|m{0.675cm}|m{0.772cm}|m{0.772cm}|m{0.772cm}|m{0.825cm}|}
\hline  &
\centering  00 & \centering  01 & \centering  11 & \centering\arraybslash  10\\\hline
\centering  00 & \centering  \textbf{0} 0 & \centering  \textbf{0} 0 & \centering  \textbf{1} 1 & \centering\arraybslash  \textbf{0} 1\\\hline
\centering  01 & \centering  \textbf{0} 1 & \centering  \textbf{0} 1 & \centering  \textbf{0} 0 & \centering\arraybslash  \textbf{1} 0\\\hline
\centering  11 & \centering  \textbf{1} 1 & \centering  \textbf{1} 1 & \centering  \textbf{1} 0 & \centering\arraybslash  \textbf{0} 0\\\hline
\centering  10 & \centering  \textbf{1} 0 & \centering  \textbf{1} 0 & \centering  \textbf{0} 1 & \centering\arraybslash  \textbf{1} 1\\\hline
\end{supertabular}
\end{center}

La región sombreada corresponde a los valores de las señales Q1* (en negrilla) y Q0*.


Para el FF D tenemos: Q* = D. Por lo tanto:
 
{D1 = !EN.Q1 + EN.DIR (Q1 XOR Q0)}
{D0 = EN XOR Q0}

Para el FF JK debemos ordenar las ecuaciones obtenidas de la forma: Q* =J.!Q + !K.Q, por lo que para Q1:

\begin{center}
\tablehead{}
\begin{supertabular}{|m{0.675cm}|m{0.95699996cm}|m{0.95699996cm}|m{0.95699996cm}|m{1.01cm}|}
\hline  &
\centering  00 & \centering  01 & \centering  11 & \centering\arraybslash  10\\\hline
\centering  00 & \centering  \textbf{0}  X & \centering  \textbf{0}  X & \centering  \textbf{1}  X & \centering\arraybslash  \textbf{0}  X\\\hline
\centering  01 & \centering  \textbf{0}  X & \centering  \textbf{0}  X & \centering  \textbf{0}  X & \centering\arraybslash  \textbf{1}  X\\\hline
\centering  11 & \centering  \textbf{X}  0 & \centering  \textbf{X}  0 & \centering  \textbf{X}  0 & \centering\arraybslash  \textbf{X}  1\\\hline
\centering  10 & \centering  \textbf{X}  0 & \centering  \textbf{X}  0 & \centering  \textbf{X}  1 & \centering\arraybslash  \textbf{X}  0\\\hline
\end{supertabular}
\end{center}

La región sombreada indican los valores que deben tener las señales J1(en negrilla) y K1.
{J1 = !Q1.!Q0.EN.DIR + !Q1.Q0.EN.!DIR = EN.!Q1(Q0 XOR DIR)}
{K1 = Q1.!Q0.EN.DIR + Q1.Q0.EN.!DIR = EN.Q1.(Q0 XOR DIR)}

Para Q0

\begin{center}
\tablehead{}
\begin{supertabular}{|m{0.675cm}|m{0.95699996cm}|m{0.95699996cm}|m{0.95699996cm}|m{1.01cm}|}
\hline  &
\centering  00 & \centering  01 & \centering  11 & \centering\arraybslash  10\\\hline
\centering  00 & \centering  \textbf{0}  X & \centering  \textbf{0}  X & \centering  \textbf{1}  X & \centering\arraybslash  \textbf{1}  X\\\hline
\centering  01 & \centering  \textbf{X}  0 & \centering  \textbf{X}  0 & \centering  \textbf{X}  1 & \centering\arraybslash  \textbf{X}  1\\\hline
\centering  11 & \centering  \textbf{X}  0 & \centering  \textbf{X}  0 & \centering  \textbf{X}  1 & \centering\arraybslash  \textbf{X}  1\\\hline
\centering  10 & \centering  \textbf{0}  X & \centering  \textbf{0 } X & \centering  \textbf{1}  X & \centering\arraybslash  \textbf{1}  X\\\hline
\end{supertabular}
\end{center}

{J0 = EN}
{K0 = EN}

{Flip-Flop tipo T:}

{Para Q1:}

\begin{center}
\tablehead{}
\begin{supertabular}{|m{0.675cm}|m{0.772cm}|m{0.772cm}|m{0.772cm}|m{0.825cm}|}
\hline&
\centering  00 & \centering  01 & \centering  11 & \centering\arraybslash  10\\\hline
\centering  00 & \centering  0 & \centering  0 & \centering  1 & \centering\arraybslash  0\\\hline
\centering  01 & \centering  0 & \centering  0 & \centering  0 & \centering\arraybslash  1\\\hline
\centering  11 & \centering  0 & \centering  0 & \centering  0 & \centering\arraybslash  1\\\hline
\centering  10 & \centering  0 & \centering  0 & \centering  1 & \centering\arraybslash  0\\\hline
\end{supertabular}
\end{center}

{T1 = !Q0.EN.DIR + Q0.EN.!DIR = EN.(Q0 XOR DIR)}

{Para Q0:}

\begin{center}
\tablehead{}
\begin{supertabular}{|m{0.675cm}|m{0.772cm}|m{0.772cm}|m{0.772cm}|m{0.825cm}|}
\hline &
\centering  00 & \centering  01 & \centering  11 & \centering\arraybslash  10\\\hline
\centering  00 & \centering  0 & \centering  0 & \centering  1 & \centering\arraybslash  1\\\hline
\centering  01 & \centering  0 & \centering  0 & \centering  1 & \centering\arraybslash  1\\\hline
\centering  11 & \centering  0 & \centering  0 & \centering  1 & \centering\arraybslash  1\\\hline
\centering  10 & \centering  0 & \centering  0 & \centering  1 & \centering\arraybslash  1\\\hline
\end{supertabular}
\end{center}

{T0 = EN}

{Flip-Flop tipo SR.}

{Para Q1:}

\begin{center}
\tablehead{}
\begin{supertabular}{|m{0.675cm}|m{0.772cm}|m{0.772cm}|m{0.772cm}|m{0.825cm}|}
\hline&
\centering  00 & \centering  01 & \centering  11 & \centering\arraybslash  10\\\hline
\centering  00 & \centering  \textbf{0}  X & \centering  \textbf{0}  X & \centering  \textbf{1}  0 & \centering\arraybslash  \textbf{0}  X\\\hline
\centering  01 & \centering  \textbf{0}  X & \centering  \textbf{0}  X & \centering  \textbf{0}  X & \centering\arraybslash  \textbf{1}  0\\\hline
\centering  11 & \centering  \textbf{X}  0 & \centering  \textbf{X}  0 & \centering  \textbf{X}  0 & \centering\arraybslash  \textbf{0}  1\\\hline
\centering  10 & \centering  \textbf{X}  0 & \centering  \textbf{X}  0 & \centering  \textbf{0}  1 & \centering\arraybslash  \textbf{X}  0\\\hline
\end{supertabular}
\end{center}

{S1 = !Q1.!Q0.EN.DIR + !Q1.Q0.EN.!DIR = EN.!Q1(Q0 XOR DIR)}

{R1 = Q1.!Q0.EN.DIR + Q1.Q0.EN.!DIR = EN.Q1.(Q0 XOR DIR) }

{Para Q0:}

\begin{center}
\tablehead{}
\begin{supertabular}{|m{0.675cm}|m{0.772cm}|m{0.772cm}|m{0.772cm}|m{0.825cm}|}
\hline&
\centering  00 & \centering  01 & \centering  11 & \centering\arraybslash  10\\\hline
\centering  00 & \centering  \textbf{0}  X & \centering  \textbf{0}  X & \centering  \textbf{1}  0 & \centering\arraybslash  \textbf{1}  0\\\hline
\centering  01 & \centering  \textbf{X}  0 & \centering  \textbf{X}  0 & \centering  \textbf{0}  1 & \centering\arraybslash  \textbf{0}  1\\\hline
\centering  11 & \centering  \textbf{X}  0 & \centering  \textbf{X}  0 & \centering  \textbf{0}  1 & \centering\arraybslash  \textbf{0}  1\\\hline
\centering  10 & \centering  \textbf{0}  X & \centering  \textbf{0}  X & \centering  \textbf{1}  0 & \centering\arraybslash  \textbf{1}  0\\\hline
\end{supertabular}
\end{center}
{S0 = EN.!Q0}
{R0 = EN.Q0}

Del análisis anterior observamos que la implementación que ocupa el menor número de compuertas es la correspondiente a los Flip-Flops tipo T.

\paragraph[\ SIMULACION]{  SIMULACION}

En la Figura 9 se muestra la implementación final de la máquina de Estados (Sin la Unidad de Salida) y en la Figura 10 la simulación correspondiente.

{\centering \includegraphics[width=13.778cm,height=5.817cm]{FSM-img9.png} \par}

{\centering Figura 9. Diagrama a nivel de compuertas del controlador de Motor de Paso.\par}

Como puede observarse en la Figura 9, la máquina de estados está formada por la lógica de estado siguiente (Compuertas XOR y AND), la memoria de
estado (FFs tipo T con la misma señal de Reloj) y la lógica de salida, (Compuertas NOT y XOR) que en este caso corresponde al de una máquina de estados tipo MOORE.


{\centering \includegraphics[width=14.984cm,height=2.953cm]{FSM-img10.png} \par}

{\centering Figura 10. Simulación del Controlador de Motor de Paso. \par}

\subsection[DESCRIPCION VHDL DE UNA FSM]{ DESCRIPCION VHDL DE UNA FSM}

En esta sección se realizará la descripción en VHDL del controlador de motor de paso. Inicialmente se hará una descripción estructural, basándose en los resultados obtenidos en la sección 5.4.3.7. Y a continuación se utilizará la descripción funcional para la implementación del controlador.

\subsubsection[DESCRIPCION ESTRUCTURAL]{DESCRIPCION ESTRUCTURAL}

Recordemos que la descripción estructural en VHDL realiza la interconexión entre los componentes que forman el sistema. En nuestro caso (Ver Figura 9), primero debemos realizar la descripción de los componentes:

\paragraph[Compuerta AND de dos entradas]{Compuerta AND de dos entradas}
\begin{lstlisting}
ENTITY and2 IS -- Debido a que AND es una palabra reservada del lenguaje
-- no puede utilizarse para nombrar una entidad
PORT(
    A : IN BIT;
    B : IN BIT;
    Y : OUT BIT);
    END and2;
ARCHITECTURE Y OF and2 IS
BEGIN
    Y <= A AND B;
END;
\end{lstlisting}

\paragraph[Compuerta XOR de dos entradas]{Compuerta XOR de dos entradas}
\begin{lstlisting}
ENTITY xor2 IS -- Debido a que XOR es una palabra reservada del lenguaje
-- no puede utilizarse para nombrar una entidad
  PORT(
    A : IN BIT;
    B : IN BIT;
    Y : OUT BIT); 
END xor2;

ARCHITECTURE XR OF xor2 IS
  BEGIN
    Y <= A XOR B;
  END;
\end{lstlisting}

\paragraph[INVERSOR]{ INVERSOR}
\begin{lstlisting}

INVERSOR ENTITY inv IS
  PORT(
    A : IN BIT;
    Y : OUT BIT); 
END inv;
ARCHITECTURE NO OF inv IS
  BEGIN
    Y <= not (A);
  END;
\end{lstlisting}

\paragraph[FLIP FLOP TIPO T]{ FLIP FLOP TIPO T}
\begin{lstlisting}
FLIP FLOP TIPO T ENTITY FFT IS
  PORT(
    T,CLK : IN BIT;
    Q : BUFFER BIT);
END FFT;
ARCHITECTURE T OF FFT IIS
  BEGIN
   process (CLK) begin
    if (CLK'event and CLK = '1') then
     if (t = '1') then
      Q <= not (Q);
     else
      Q <= Q;
     end if;
    end if;
   end process;
  END;
\end{lstlisting}


Una vez realizada la implementación de los componentes, se procede a su unión. Para lograr esto se deben sintetizar las anteriores declaraciones, y sus archivos deben estar en el mismo directorio de trabajo.

\paragraph[CONTROL DE MOTOR DE PASO]{ CONTROL DEMOTOR DE PASO}
\begin{lstlisting}
CONTROL DE MOTOR DE PASO ENTITY StepMotor IS
  PORT(
    CLK, EN, DIR : IN BIT;
    AO, BO, CO, DO : BUFFER BIT);
END StepMotor;

ARCHITECTURE CONTROLLER OF StepMotor IS
  SIGNAL I1, T1, Q0N: BIT;
  COMPONENT AND2E
    PORT (A, B : IN BIT;
             Y : OUT BIT);
  END COMPONENT;
  COMPONENT XOR2
    PORT (A, B : IN BIT;
             Y : OUT BIT);
  END COMPONENT;
  COMPONENT INV
    PORT (A : IN BIT;
          Y : OUT BIT);
  END COMPONENT;
  COMPONENT FFT
    PORT(
    CLK, T: IN BIT;
        Q : OUT BIT);
  END COMPONENT;

  BEGIN
    X1: XOR2 port map(DIR, Q0N, I1);
    X2: AND2E port map(EN, I1, T1);
    X3: FFT port map(CLK, T1, BO);
    X4: FFT port map(CLK, EN, Q0N);
    X5: XOR2 port map(BO, Q0N, DO);
    X6: INV port map(BO, AO);
    X7: INV port map(DO, CO);
  END CONTROLLER;
\end{lstlisting}

\subsubsection[DESCRIPCION FUNCIONAL]{DESCRIPCION FUNCIONAL}

La descripción Estructural no es el mejor ejemplo de la potencialidad del VHDL, ya que como vimos, es necesario realizar todo el proceso de  síntesis para obtener las ecuaciones de excitación de los Flip-Flops. Realizando la descripción funcional no es necesario preocuparse por escoger el Flip -- Flop que reduzca el número de compuertas ni de minimizar las ecuaciones booleanas obtenidas, todos estos procesos los realizan automáticamente las herramientas CAD disponibles comercialmente. El código VHDL del controlador del motor de paso se muestra a continuación, y en la Figura 11 se muestra el resultado de la simulación.


\begin{lstlisting}
library ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

ENTITY FSMF IS
  PORT(
   clk        : IN std_logic;
   EN, DIR    : IN std_logic;
   A, B, C, D : OUT std_logic);
END FSMF;

ARCHITECTURE funcional OF FSMF IS
TYPE estados IS (S1, S2, S3, S4);
SIGNAL state : estados;

BEGIN
  PROCESS (clk)
   BEGIN
    IF (clk'event and clk = '1') then
     case state is
      when S1 => A <= '1'; B <= '0'; C <= '1'; D <= '0';
       IF (EN = '0') then
        state <= S1;
       ELSIF (DIR = '0') then
        state <= S2;
       ELSE
        state <= S4;
       END IF;

      when S2 => A <= '1'; B <= '0'; C <= '0'; D <= '1';
       IF (EN = '0') then
        state <= S2;
       ELSIF (DIR = '0') then
        state <= S3;
       ELSE
        state <= S1;
       END IF;

      when S3 => A <= '0'; B <= '1'; C <= '0'; D <= '1';
       IF (EN = '0') then
        state <= S3;
       ELSIF (DIR = '0') then
        state <= S4;
       ELSE
        state <= S2;
       END IF;
      when S4 => A <= '0'; B <= '1'; C <= '1'; D <= '0';
       IF (EN = '0') then
        state <= S4;
       ELSIF (DIR = '0') then
        state <= S1;
       ELSE
        state <= S3;
      END IF;
     END CASE;
    END IF;
  END PROCESS;
END funcional;
\end{lstlisting}







{
El código para la realización del Test Bench es:}

{\itshape
\textbf{LIBRARY} ieee;}

{\itshape
\textbf{USE} ieee.std\_logic\_1164.ALL;}

{\itshape
\textbf{USE} ieee.numeric\_std.ALL;}

{\itshape
\textbf{ENTITY} testbench \textbf{IS}}

{\itshape
\textbf{END} testbench;}

{\itshape
\textbf{ARCHITECTURE} behavior \textbf{OF} testbench \textbf{IS} }

{\itshape
\ \ \textbf{COMPONENT} fsmf}

{\itshape
\ \ \textbf{PORT}(}

{\itshape
\ \ \ \ clk : \textbf{IN} std\_logic;}

{\itshape
\ \ \ \ EN : \textbf{IN} std\_logic;}

{\itshape
\ \ \ \ DIR : \textbf{IN} std\_logic;  }

{\itshape
\ \ \ \ A : \textbf{OUT} std\_logic;}

{\itshape
\ \ \ \ B : \textbf{OUT} std\_logic;}

{\itshape
\ \ \ \ C : \textbf{OUT} std\_logic;}

{\itshape
\ \ \ \ D : \textbf{OUT} std\_logic}

{\itshape
\ \ \ \ );}

{\itshape
\ \ \textbf{END} \textbf{COMPONENT};}

{\itshape
\ \ \textbf{SIGNAL} clk :  std\_logic;}

{\itshape
\ \ \textbf{SIGNAL} EN :  std\_logic;}

{\itshape
\ \ \textbf{SIGNAL} DIR :  std\_logic;}

{\itshape
\ \ \textbf{SIGNAL} A :  std\_logic;}

{\itshape
\ \ \textbf{SIGNAL} B :  std\_logic;}

{\itshape
\ \ \textbf{SIGNAL} C :  std\_logic;}

{\itshape
\ \ \textbf{SIGNAL} D :  std\_logic;}

{\itshape
 \textbf{constant} ncycles  : \textbf{integer} := 40;}

{\itshape
 \textbf{constant} halfperiod : \textbf{time  } := 5 ns;}

{\bfseries\itshape
BEGIN}

{\itshape
 \ \ uut: fsmf \textbf{PORT} \textbf{MAP}(}

{\itshape
\foreignlanguage{english}{\ \ \ \ }\foreignlanguage{spanish}{clk
={\textgreater} clk,}}

{\itshape
\ \ \ \ EN ={\textgreater} EN,}

{\itshape
\ \ \ \ DIR ={\textgreater} DIR,}

{\itshape
\ \ \ \ A ={\textgreater} A,}

{\itshape
\foreignlanguage{spanish}{\ \ \ \ }\foreignlanguage{english}{B
={\textgreater} B,}}

{\itshape
\ \ \ \ C ={\textgreater} C,}

{\itshape
\foreignlanguage{english}{\ \ \ \ }\foreignlanguage{spanish}{D
={\textgreater} D);}}

{\itshape
 {}-{}- Generacion del Reloj}

{\itshape
\foreignlanguage{spanish}{ }\foreignlanguage{english}{Clock\_Source:
}\foreignlanguage{english}{\textbf{process}}}

{\itshape
 \textbf{begin}}

{\itshape
 \textbf{for} i \textbf{in} 0 \textbf{to} ncycles \textbf{loop}  {}-{}-
Genera ncyclos de periodo 10 ns}

{\itshape
 clk {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{wait} \textbf{for} halfperiod;}

{\itshape
 clk {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{wait} \textbf{for} halfperiod;}

{\itshape
 \textbf{end} \textbf{loop};}

{\itshape
 \textbf{wait};}

{\itshape
 \textbf{end} \textbf{process} Clock\_Source;}

{\itshape
 tb : PROCESS}

{\itshape
\ \ \textbf{BEGIN}}

{\itshape
 \textbf{for} i \textbf{in} 1 \textbf{to} ncycles/4 \textbf{loop 
}{}-{}- Durante ncyclos/4 genera las diferentes}

{\itshape
\foreignlanguage{english}{
}\foreignlanguage{spanish}{\textbf{wait}}\foreignlanguage{spanish}{
}\foreignlanguage{spanish}{\textbf{until}}\foreignlanguage{spanish}{
Clk={\textquotesingle}1{\textquotesingle}
}\foreignlanguage{spanish}{\textbf{and}}\foreignlanguage{spanish}{
Clk}\foreignlanguage{spanish}{\textbf{{\textquotesingle}event}}\foreignlanguage{spanish}{;
 {}-{}- Combinaciones de EN y DIR}}

{\itshape
 EN  {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
\foreignlanguage{spanish}{ }\foreignlanguage{english}{DIR {\textless}=
{\textquotesingle}0{\textquotesingle};}}

{\itshape
 \textbf{end} \textbf{loop};}

{\itshape
 \textbf{for} i \textbf{in} 1 \textbf{to} ncycles/4 \textbf{loop}}

{\itshape
 \textbf{wait} \textbf{until} Clk={\textquotesingle}1{\textquotesingle}
\textbf{and} Clk{\textquotesingle}\textbf{event};}

{\itshape
\foreignlanguage{english}{ }\foreignlanguage{spanish}{EN  {\textless}=
{\textquotesingle}0{\textquotesingle};}}

{\itshape
\ \   DIR {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
\foreignlanguage{spanish}{
}\foreignlanguage{english}{\textbf{end}}\foreignlanguage{english}{
}\foreignlanguage{english}{\textbf{loop}}\foreignlanguage{english}{; 
}}

{\itshape
 \textbf{for} i \textbf{in} 1 \textbf{to} ncycles/4 \textbf{loop}}

{\itshape
 \textbf{wait} \textbf{until} Clk={\textquotesingle}1{\textquotesingle}
\textbf{and} Clk{\textquotesingle}\textbf{event};}

{\itshape
\foreignlanguage{english}{ }\foreignlanguage{spanish}{EN  {\textless}=
{\textquotesingle}1{\textquotesingle};}}

{\itshape
\ \   DIR {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
\foreignlanguage{spanish}{
}\foreignlanguage{english}{\textbf{end}}\foreignlanguage{english}{
}\foreignlanguage{english}{\textbf{loop}}\foreignlanguage{english}{; 
\ \  }}

{\itshape
 \textbf{for} i \textbf{in} 1 \textbf{to} ncycles/4 \textbf{loop}}

{\itshape
 \textbf{wait} \textbf{until} Clk={\textquotesingle}1{\textquotesingle}
\textbf{and} Clk{\textquotesingle}\textbf{event};}

{\itshape
\foreignlanguage{english}{ }\foreignlanguage{spanish}{EN  {\textless}=
{\textquotesingle}1{\textquotesingle};}}

{\itshape
\ \   DIR {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
\foreignlanguage{spanish}{
}\foreignlanguage{english}{\textbf{end}}\foreignlanguage{english}{
}\foreignlanguage{english}{\textbf{loop}}\foreignlanguage{english}{; 
}}

{\itshape
 \textbf{END} \textbf{PROCESS};}

{\itshape
\textbf{END};}

 \includegraphics[width=13.286cm,height=4.382cm]{FSM-img11.png} 

{\centering
Figura 11. Simulación de la descripción funcional del controlador de
motor de paso.
\par}

{
Con la descripción funcional no es necesario preocuparse por el tipo de
Flip-Flop ni por los procesos de minimización.}

{
Normalmente las herramientas CAD proporcionan información sobre
resultado de ls síntesis del diseño, las ecuaciones implementadas en un
CPLD por una de estas herramientas es:}

{\itshape
clk  : INPUT;}

{\itshape
DIR  : INPUT;}

{\itshape
EN  : INPUT;}

{\itshape
A  = DFFE( state\~{}2 \$  VCC,  GLOBAL( clk),  VCC,  VCC,  VCC);}

{\itshape
B  = DFFE(!state\~{}2 \$  VCC,  GLOBAL( clk),  VCC,  VCC,  VCC);}

{\itshape
C  = DFFE(!state\~{}1 \$  state\~{}2, GLOBAL( clk),  VCC,  VCC,  VCC);}

{\itshape
D  = DFFE( state\~{}1 \$  state\~{}2, GLOBAL( clk),  VCC,  VCC,  VCC);}

{\bfseries\itshape
state\~{}1  = TFFE( EN, GLOBAL( clk),  VCC,  VCC,  VCC);}

{\bfseries\itshape
state\~{}2  = TFFE( \_EQ001, GLOBAL( clk),  VCC,  VCC,  VCC);}

{\itshape
\foreignlanguage{english}{\textbf{
}}\foreignlanguage{spanish}{\textbf{\_EQ001 = !DIR \&  EN \& 
state\~{}1  \#  DIR \&  EN \&
!state\~{}1}}\foreignlanguage{spanish}{;}}

{
En donde se puede observar que se llegó a las mismas ecuaciones
obtenidas anteriormente. Observe que se utilizaron 2 Flip-Flops tipo T
uno de los cuales tiene a la señal EN como entrada (primera seña que
aparece dentro de los paréntesis después de TFFE. ). Mientras que el
otro tiene a la señal \_EQ001 conectada a su entrada T. La ecuación
para \_EQ001 es:}

{
 \textit{!DIR \&  EN \&  state\~{}1  \#  DIR \&  EN \& !state\~{}1 =
EN.((!DIR.sate\~{}1) + (DIR.!state\~{}1)}}

{
Como vimos en capítulos anteriores la arquitectura de un CPLD no posee
compuertas XOR, por lo tanto las ecuaciones son de la forma de suma de
productos. Lo interesante es observar el ahorro de tiempo asociado a la
utilización del VHDL como herramienta de diseño.}



\section{Máquinas de Estados Algorítmicas (ASM)}
Una máquina de estados algorítmica (ASM) permite la implementación de cualquier tipo de algoritmo; está compuesta por el \textit{camino de datos} y el \textit{control}. El camino de datos, como su nombre lo indica, modifica los datos o variables del algorítmo; mientras que el control determina cuando son modificados. Los pasos que se realizan para el diseño e implementación de una máquina de estados algorítmica son los siguientes:

\begin{enumerate}
 \item Elaboración del diagrama de flujo del algoritmo.
 \item Identificación de los componentes del camino de datos.
 \item Identificación de las señales necesarias para controlar el camino de datos e interconexión.
 \item Especificación de la unidad de control utilizando diagramas de estado.
 \item Implementación de los componentes del camino de datos y de la unidad de control utilizando lenguajes de descripción de hardware.
 \item Simulación y pruebas
\end{enumerate}

\subsection{Multiplicación de números binarios usando una ASM}

El algoritmo de multiplicación que se implementará se basa en productos parciales; el primer producto parcial siempre es cero (ver Figura \ref{productos_parciales}, a continuación se realiza la multiplicación iniciando con el bit menos significativo del multiplicador, el resultado de la multiplicación se suma al primer producto parcial y se obtiene el segundo producto parcial; si el bit del multiplicador es {\textquoteleft}0{\textquoteright} no se afecta el contenido de PP, por lo que no se realiza la suma. A continuación se realiza la multiplicación del siguiente bit (a la izquierda del LSB) y el resultado se suma al producto parcial dos pero corrido un bit a la izquierda, esto para indicar que la potencia del siguiente bit tiene un grado más; este corrimiento se debe realizar ya que si un número binario se multiplica por 2 el resultado es el mismo número corrido a la izquierda, por ejemplo:

{15 (1111) X 2 = 11110 = (30)};
{15 (1111) X 4 = 111100 = (60)}

Este proceso continúa hasta completar los bits del multiplicador y el último producto parcial es el resultado.

\begin{figure}[htpb]
  \centering
  \includegraphics[width=6.879cm,height=5.08cm]{FSM-img12.png}
  \caption{Multiplicación de numeros binarios usando productos parciales.} \label{productos_parciales}
\end{figure}

\subsubsection{Diagrama de Flujo}
En la Figura \ref{flujo_multiplicador} se muestra un diagrama de flujo para la implementación de este algoritmo. El primer paso para realizar la multiplicación es hacer el producto parcial (PP) sea igual a cero, a continuación se realiza una verificación del bit menos significativo del multiplicador, esto se hace para sumar únicamente los resultados que no son cero. En este caso se utiliza un corrimiento a la izquierda para obtener el siguiente bit del multiplicador, si por ejemplo al número \textit{101\textbf{0}} se le realiza un corrimiento a la derecha se obtiene el número \textit{010\textbf{1}}, con lo que el bit menos significativo corresponde al segundo bit de \textit{1010}, si se realiza otro corrimiento a la derecha se obtiene \textit{001\textbf{0}} y de nuevo el bit menos significativo corresponde al tercer bit de \textit{1010}, al realizar de nuevo un corrimiento se obtiene \textit{000\textbf{1}}, con lo que tendríamos todas las cifras del multiplicador de forma consecutiva en el mit menos significativo. Cuando se realiza un nuevo corrimiento el resultado es \textit{0000} lo que indica que el producto parcial no puede cambiar y podemos terminar el algortimo. Este método para finalizar el algoritmo produce que el número de iteraciones depende del valor del multiplicador; otra forma de terminar el algoritmo sin que dependa del valor del multiplicador se obtiene al contar el número de bits del multiplicador y realizar el corrimiento \textit{n} veces, donde \textit{n} es el número de bits del multiplicador.

Para indicar que cada vez que se toma un bit del multiplicador, este tiene una potencia mayor que el bit anterior, debemos multiplicar el resultado por la base, la cual es 2 en este caso; como se mencionó anteriormente, multiplicar por 2 equivale a realizar un corrimiento a la izquierda, por lo que siempre que se tome un nuevo bit del multiplicador debemos correr a la izquierda el multiplicando.

\begin{figure}[htpb]
  \centering
  \includegraphics[scale=.35]{./images/Multipl.pdf}
  \caption{Diagrama de flujo para la multiplicación de numeros binarios.} \label{flujo_multiplicador}
\end{figure}

Una vez conocido el funcionamiento del sistema se procede a realizar el diagrama de caja negra de entradas y salidas. En la Figura \ref{caja_multiplicador} se muestra el multiplicando y el multiplicador (A y B), señales de m bits cada una, el resultado de la multiplicación PP (Bus de 2m Bits), la señal de reloj (CLOCK). Las señales INIT y DONE se utilizan para iniciar el proceso de multiplicación e indicar que el resultado está disponible respectivamente; es importante que todo sistema digital posea la forma de interactuar con el exterior, ya que sin ello el sistema carecería de utilidad.

\begin{figure}[htpb]
  \centering
  \includegraphics[width=11.458cm,height=5.055cm]{FSM-img14.png}
  \caption{Diagrama de caja negra para el multiplicador de numeros binarios.} \label{caja_multiplicador}
\end{figure}

\subsubsection{Identificación de los componentes del camino de datos}

A continuación se identifican los componentes del camino de datos, esto se realiza recorriendo el diagrama de flujo para encontrar las operaciones que se realizan. 

\begin{figure}[htpb]
  \centering
  \includegraphics[scale=0.35]{./images/Multipl2.pdf}
  \caption{Identificación de los componentes del camino de datos para el multiplicador de numeros binarios.} \label{caja_multiplicador}
\end{figure}

En la figura \ref{datapath_multiplicador} se resaltan las operaciones que se deben realizar para la correcta operación del algorítmo; la primera es una operación de acumulación correspondiente a \textit{PP = PP + A}; la segunda operación que encontramos son los dos corrimientos a la izquierda y derecha del multiplicando (A) y el multiplicador (B) respectivamente, estas operaciones se realizan al mismo tiempo pero en módulos diferentes; el último módulo es un comparador que indica que el multiplicador es igual a cero, indicando que el algoritmo puede finalizar.

\subsubsection{Identificación de las señales de control e interconexión del camino de datos}

En la figura \ref{intercon_datapath_multiplicador} se muestra la interconexión de los componentes del camino de datos y las señales que lo controlan. 

\begin{figure}[htpb]
  \centering
  \includegraphics[scale=1.2]{./images/multipl_datapath.pdf}
  \caption{Identificación de las señales de control e interconexión del camino de datos.} \label{intercon_datapath_multiplicador}
\end{figure}

La primera operación que aparece en el diagrama de flujo es la del acumulador, el cual acumula el valor de la salida del registro de corrimiento que almacena el multiplicando, de aquí obtenemos la conexión entre el registro de corrimiento (LSR) a la izquierda y el acumulador (ACC). La segunda operación que aparece es la de los registros de corrimiento, por lo que los valores del multiplicando y multiplicador deben cargarse para su posterior corrimiento a las unidades de corrimiento a la izquierda y derecha respectivamente. La salida del corrimiento a la derecha del multiplicador es comparada en cada ciclo para determinar si se llegó al final del algoritmo, por lo que la entrada del comparador es la salida del registro de corrimiento del multiplicador.

Para determinar las señales de control de cada componente del camino de datos, se debe identificar su función y las operaciones que debe realizar; los registros de corrimiento deben permitir la carga de un valor inicial y el corrimiento de las mismas, esto se realiza con las señales \textit{LOAD} y \textit{SHIFT} respectivamente; el acumulador debe tener la posibilidad de inicializarse en cero y una señal para que sume el valor de la entrada al que tiene almacenado, esto se hace con las señales \textit{RESET} y \textit{ADD}; por último el comparador debe proporcionar una señal que indique que el valor de su entrada es igual a cero, \textit{Z} en este caso.

Aunque es posible que la máquina de control maneje todas las señales de control del camino de datos, es mejor aguparlas de acuerdo a su activación; esto es, si una señal se activa al mismo tiempo que otra, se puede utilizar una señal que las controle a ambas. Para esto se utiliza el diagrama de flujo y se observa en que momento se realizan las operaciones: Se observa que se cargan los valores de los registros de corrimiento y se inicializa en cero el acumulador únicamenet al comenzar el algoritmo y durante la ejecución del mismo no se vuelve a relizar esta operación, por este motivo utilizaremos la misma señal (\textit{RESET}) para cargar los registros de desplazamiento e inicializar en cero el acumulador; la señal que controla el momento en que el acumulador se incrementa es única, ya que no se realiza ninguna operación en ese punto del algoritmo y en este caso recibe el nombre de \textit{ADD}; las operaciones de corrimiento se realizan en el mismo lugar, por lo que se puede utilizar una señal común, que en este caso llamaremos \textit{SH}; por último la salida del comparador \textit{Z} y el bit menos significativo de B \textit{LSB} son señales de salida del camino de datos que le darán a la unidad de control la información necesaria para tomar la acción adecuada en los bloques de decisión.

\subsubsection{Especificación de la unidad de control utilizando diagramas de estado}
Una vez que se conoce el camino de datos, las señales que lo controlan y las señales que ayudarán a la unidad de control a tomar decisiones, se procede con la especificación de la unidad de control, la cual, es una máquina de estados finitos, por lo que la mejor forma de especificarla es utilizando un diagrama de estados; en la figura \ref{control_multiplicador} se muestra la relación entre el diagrama de flujo y el diagrama de estados.

\begin{figure}[htpb]
  \centering
  \includegraphics[scale=0.4]{./images/Multipl3.pdf}
  \caption{Diagrama de estados de la unidad de control del multiplicador binario.} \label{control_multiplicador}
\end{figure}

Como se puede observar, existe una relación muy estrecha entre el diagrama de estados y el diagrama de flujo, cada operación del diagrama de flujo corresponde a un estado de la máquina de control y las transiciones entre ellos son idénticas, observe las líneas del mismo color en la figura \ref{control_multiplicador}



La máquina de estados debe iniciar en START y se queda en este estado siempre que la señal INIT tenga un valor de {\textquoteleft}0{\textquoteright}, En el estado INIT la señal RESET = {\textquoteleft}1{\textquoteright}, con lo que el valor del acumulador se hace cero y se cargan los registros A y B. Cuando INIT = {\textquoteleft}1{\textquoteright}, entramos al estado CHECK el cual evalúa la señal LSB, sí LSB = {\textquoteleft}0{\textquoteright}, no se debe realizar la suma de MD, pero si se debe realizar un corrimiento para obtener el siguiente bit del multiplicador y realizar el corrimiento necesario en MD. Si LSB = {\textquoteleft}1{\textquoteright} se debe sumar el valor de las salidas de LSR al valor del acumulador, y después se debe realizar un corrimiento. En el estado ADD se hace la salida ADD = {\textquoteleft}1{\textquoteright} para que el valor a la entrada del acumulador se sume al valor almacenado en él. En el estado SHIFT se realiza el corrimiento de RSR y LSR haciendo el valor de la señal SH = 1. 

Para verificar el buen funcionamiento del diagrama de estado debemos realizar una prueba de escritorio: Supongamos que tenemos A = 7 y B = 5
y que INIT = 1:




\begin{center}
\tablehead{}
\begin{supertabular}{|m{1.855cm}|m{0.791cm}|m{1.765cm}|m{1.038cm}|m{0.566cm}|m{0.95699996cm}|m{1.1719999cm}|m{1.467cm}|m{1.8179998cm}|}
\hline
\centering  ESTADO & \centering  SH & \centering  LSR & \centering  RSR & \centering  Z & \centering  LSB & \centering  ADD & \centering  DONE & \centering\arraybslash  ACC\\\hline
\centering  CHECK & \centering  0 & \centering  00000111 & \centering  0101 & \centering  0 & \centering  1 & \centering  0 & \centering  0 &
\centering\arraybslash  00000000\\\hline
\centering  ADD & \centering  0 & \centering  00000111 & \centering  0101 & \centering  0 & \centering  1 & \centering  1 & \centering  0 &
\centering\arraybslash  00000111\\\hline
\centering  SHIFT & \centering  1 & \multicolumn{1}{m{1.765cm}}{\centering  00001110} & \centering  0010 & \centering  0 & \centering  0 & \centering  0 & \centering  0 &
\centering\arraybslash  00000111\\\hline
\centering  CHECK & \centering  0 & \centering  00001110 & \centering  0010 & \centering  0 & \centering  0 & \centering  0 & \centering  0 &
\centering\arraybslash  00000111\\\hline
\centering  SHIFT & \multicolumn{1}{m{0.791cm}}{\centering  1} & \multicolumn{1}{m{1.765cm}}{\centering 00011100} & \centering  0001 & \centering  0 & \centering  1 & \centering  0 & \centering  0 & 
\centering\arraybslash  00000111\\\hline
\centering  CHECK & \centering  0 & \centering  00011100 & \centering  0001 & \centering  0 & \centering  1 & \centering  0 & \centering  0 &
\centering\arraybslash  00000111\\\hline
\centering  ADD & \centering  0 & \centering  00011100 & \centering  0001 & \centering  0 & \centering  1 & \centering  1 & \centering  0 &
\centering\arraybslash  00100011\\\hline
\centering  SHIFT & \multicolumn{1}{m{0.791cm}}{\centering  1} & \multicolumn{1}{m{1.765cm}}{\centering  00111000} & \centering  0000 & \centering  1 & \centering  0 & \centering  0 & \centering  0 &
\centering\arraybslash  00100011\\\hline
\centering  CHECK & \centering  0 & \centering  00111000 & \centering  0000 & \centering  1 & \centering  0 & \centering  0 & \centering  0 &
\centering\arraybslash  00100011\\\hline
\centering  END1 & \centering  0 & \centering  00111000 & \centering  0000 & \centering  1 & \centering  0 & \centering  0 & \centering  1 &
\centering\arraybslash  00100011\\\hline
\centering  START & \centering  0 & \multicolumn{1}{m{1.765cm}}{\centering  00000111} & \multicolumn{1}{m{1.038cm}}{\centering  0101} & \multicolumn{1}{m{0.566cm}}{\centering  0} & \centering  1 & \centering  0 & \multicolumn{1}{m{1.467cm}}{\centering  0} & \centering\arraybslash  00000000\\\hline
\end{supertabular}
\end{center}

Como puede observarse el resultado es correcto (35), en la tabla las casillas sombreadas corresponden a las señales que cambian de un estado
a otro.

\subsubsection{Implementación de los componentes del camino de datos y de la unidad de control}
Existe abundante literatura sobre el uso de lenguajes de descripción de hardware para la implementación de sistemas digitales; por este motivo, en este libro no se presentará el código que implementa los diferentes módulos que hacen parte de las máquinas de estado algorítmicas estudiadas.

Es muy importante anotar la importancia de la portabilidad del código, como es bien sabido existen varias empresas que suministran entornos de desarrollo que permiten la entrada de diseño utilizando diferentes medios; las herramientas gráficas utilizados por ellos no son compatibles entre sí, lo que hace imposible el paso de un diseño implementado en una herramienta gráfica a otra de otro fabricante; sin embargo, todas las herramientas aceptan texto con el estándard del lenguaje utilizad; por esto, se recomienda utilizar únicamente entrada de texto en las descripciones.

\subsubsection{Simulación}
Como se mencionó anteriormente, es posible realizar las simulaciones utilizando las herramientas gráficas de cada uno de los entornos de desarrollo que proporcionan los fabricantes de dispositivos lógicos programables, sin embargo, su uso dificulta la portabilidad del diseño. Por este motivo, se recomienda el uso de \textit{testbench} escritos con el lenguaje estándard. Como parte del proceso de diseño, cada módulo debe ser simulado antes de ser integrado en la descripción de más alto nivel.

Es bueno tener en cuenta los diferentes niveles de simulación que se pueden realizar a un sistema bajo prueba; la simulación más rápida es la que tiene en cuenta únicamente el lengiaje de descripción de hardware utilizado, sin embargo, no es posible garantizar que los resultados del circuito sintetizado sean los mismos que la simulación del lenguaje; por esto, existe la simulación post-síntesis, en la que se simula el RTL (lógica de transferencia de registros) o las compuertas lógicas básicas obtenidas del proceso de síntesis, esta simulación garantiza que el circuito obtenido del proceso de síntesis se comporta como lo deseamos; el tercer nivel de simulación se obtiene cuando se adiciona un modelo de tiempo al diagrama de compuertas del nivel anterior, en este nivel, se tienen en cuenta las capacitancias de carga y la capacitancia de los caminos de interconexión para obtener el retardo de cada elemento del circuito, esta simulación es la más precisa y permite conocer la velocidad máxima a la que puede operar el sistema, esta simulación en algunos entornos de desarrollo recibe el nombre de \textit{simulación post place & route}.

\subsubsection{Pruebas}
Aunque la simulación es una buena herramienta para la detección de errores, es necesario implementar 


{\bfseries
Ejemplo 3: Implementación de un divisor de n bits sin signo.}

{
El presente ejemplo es un divisor binario de n bits, en este ejemplo y
en los siguientes solo se realizará el \textit{testbench} a las
implementaciones finales. En la Figura 23 se muestra un ejemplo de
división de dos números binarios (35 / 5).}

{\centering 
\includegraphics[width=6.668cm,height=10.502cm]{FSM-img23.png} \par}

{\centering
Figura 23. División de dos números binarios sin signo.
\par}

{
El proceso de división de números binarios es similar al de números
decimales: Inicialmente se separan dígitos del Dividendo de izquierda a
derecha hasta que la cifra así formada sea mayor o igual que el
divisor.  En la figura 13 separamos el primer dígito de la derecha ( 0
) y le restamos el divisor (la operación de resta se realizó en
complemento a dos), el resultado de esta operación es un número
negativo (los números negativos en representación complemento a dos
comienzan por 1). Esto indica que el número es menor que el divisor,
por lo tanto, colocamos un cero en el resultado parcial de la división
(este dígito será el más significativo) y separamos los dos primeros
dígitos (00) y repetimos el proceso. En la Figura 13 aparece en
negrilla el número formado al realizar la separación de dígitos. Este
número es el residuo parcial de la operación de división.}

{
Sólo hasta el sexto resultado parcial obtenemos un cero en la primera
cifra de la resta (recuerde que en complemento a dos los números tienen
una longitud fija en nuestro caso 4 bits, sí una operación provoca un
bit adicional este se descarta, los bits descartados se encerraron en
líneas punteadas en la Figura 23). Indicando que el número es mayor o
igual que el divisor. En este caso se coloca un
{\textquoteleft}1{\textquoteright} en el resultado parcial y se
conserva el valor de la operación de resta, el cual se convierte en el
nuevo residuo parcial, este proceso se repite hasta haber
{\textquotedblleft}bajado {\textquotedblright} todos los dígitos del
dividendo.}

{
En la Figura 24 se muestra el algoritmo de división de dos números sin
signo.}

{\centering 
\includegraphics[width=9.103cm,height=15.85cm]{FSM-img24.png} \par}

{\centering
Figura 24. Diagrama de flujo para la división de números binarios sin
signo.
\par}

{
\textbf{Primera Implementación: }El divisor de N Bits se implementará de
dos formas: La primera siguiendo un procedimiento similar al del
multiplicador y después se realizará una implementación directa del
algoritmo de división utilizando un package propio.}

{
Del diagrama de flujo podemos deducir que los bloques necesarios para la
implementación del divisor son:}

{
Un registro de corrimiento a la izquierda con precarga para A (LSR): El
registro de corrimiento debe tener precarga ya que cuando es necesario
modificar el valor de este registro.}

\begin{itemize}
\item {
Un registro de corrimiento a la izquierda para Q (LSRQ).}
\item {
Un Sumador Restador (ADDSUB).}
\item {
Un contador descendente (DEC): El cual está encargado de controlar el
número de corrimientos.}
\item {
Una unidad de control (CONTROLL)}
\end{itemize}
{
En la siguiente figura se muestra el diagrama de entradas y salidas del
divisor y el diagrama de bloques del mismo.}

{\centering 
\includegraphics[width=12.778cm,height=9.116cm]{FSM-img25.png} \par}

{\centering
Figura 25. Diagrama de bloques del divisor de N bits.
\par}

{
Con el diagrama de bloques anterior podemos generar la descripción
estructural del divisor:}

{\itshape
\textbf{Library} IEEE;}

{\itshape
\textbf{USE} IEEE.STD\_LOGIC\_1164.all;}

{\itshape
\textbf{USE} IEEE.STD\_LOGIC\_ARITH.all;}

{\itshape
\textbf{USE} IEEE.STD\_LOGIC\_UNSIGNED.all;}

{\itshape
\textbf{Entity} divisor \textbf{is}}

{\itshape
\textbf{Generic}(\textbf{width}:natural:=7);}

{\itshape
\textbf{Port}(}

{\itshape
\ \ A,B\ \ \ \ \ \ : \textbf{IN} STD\_LOGIC\_VECTOR(width downto 0);}

{\itshape
\ \ Init,clk\ \ : IN STD\_LOGIC;}

{\itshape
\ \ D,R\ \ \ \ \ \ : \textbf{BUFFER} STD\_LOGIC\_VECTOR(width downto
0);}

{\itshape
\ \ Done\ \ \ \ : \textbf{OUT} STD\_LOGIC);}

{\itshape
\textbf{End} Divisor;}

{\itshape
\textbf{Architecture} \textbf{estructural} of \textbf{divisor} is}

{\itshape
\ \ \textbf{component} controll}

{\itshape
\ \ \textbf{Port}(}

{\itshape
\ \ \ \ Clk,Init, msb, Z\ \ \ \ :\textbf{IN}\ \ STD\_LOGIC;}

{\itshape
\ \ \ \ shift,reset,q0,done\ \ :\textbf{OUT} STD\_LOGIC;}

{\itshape
\ \ \ \ sub,add,dec,load,sq\ \ :\textbf{OUT} STD\_LOGIC);}

{\itshape
\ \ \textbf{End} Component;}

{\itshape
\ \ \textbf{Component} lsrq}

{\itshape
\ \ \textbf{GENERIC}(width:\textbf{natural}:=7);}

{\itshape
\ \ \textbf{PORT}(}

{\itshape
\ \ \ \ clk,shift,DIN,reset:  \textbf{IN}\ \ STD\_LOGIC;}

{\itshape
\ \ \ \ Qlsrq: \ \ \ \   \textbf{BUFFER} STD\_LOGIC\_VECTOR(width downto
0));}

{\itshape
\ \ \textbf{END} \textbf{Component};}

{\itshape
\ \ \textbf{Component} lsr}

{\itshape
\ \ \textbf{GENERIC}(width:natural:=7);}

{\itshape
\ \ \textbf{PORT}(}

{\itshape
\ \ \ \ clk,shift,load,reset: \textbf{IN}\ \ STD\_LOGIC;}

{\itshape
\ \ \ \ Data,DataL: \ \   \textbf{IN}\ \ STD\_LOGIC\_VECTOR(width
\textbf{downto} 0);}

{\itshape
\ \ \ \ Qlsr: \ \ \ \   \textbf{BUFFER} STD\_LOGIC\_VECTOR(width
\textbf{downto} 0));}

{\itshape
\ \ \textbf{END} \textbf{Component};}

{\itshape
\ \ \textbf{Component} Decrement}

{\itshape
\ \ \textbf{Port}(}

{\itshape
\ \ \ \ Clk,Init,dec\ \ : \textbf{IN}\ \ STD\_LOGIC;}

{\itshape
\ \ \ \ Z\ \ \ \ : \textbf{OUT} STD\_LOGIC);}

{\itshape
\ \ \textbf{End} \textbf{Component};}

{\itshape
\ \ \textbf{Component} addsub}

{\itshape
\ \ \textbf{GENERIC}(width:\textbf{natural}:=7);}

{\itshape
\ \ \textbf{PORT}(}

{\itshape
\ \ \ \ clk,reset,add,sub:  \textbf{IN}\ \ STD\_LOGIC;}

{\itshape
\ \ \ \ msb: \ \ \ \   \textbf{OUT}\ \ STD\_LOGIC;}

{\itshape
\ \ \ \ A,B\ \ : \ \   \textbf{IN}\ \ STD\_LOGIC\_VECTOR(width
\textbf{downto} 0);}

{\itshape
\ \ \ \ AS: \ \ \ \   \textbf{BUFFER }STD\_LOGIC\_VECTOR(width
\textbf{downto} 0));}

{\itshape
\ \ \textbf{END} \textbf{Component};}

{\itshape
\textbf{Signal} \ \ ld,sh,re,ad,su,Z,msb,de,q0,sq : STD\_LOGIC;}

{\itshape
\textbf{Signal}\ \ INN1\ \ \ \ \ \   :STD\_LOGIC\_VECTOR(width
\textbf{downto} 0);}

{\bfseries\itshape
Begin}

{\itshape
\ \ A1: lsr}

{\itshape
\ \ \textbf{Generic} \textbf{map}(width)}

{\itshape
\ \ \textbf{Port} \textbf{Map}(clk,sh,ld,re,A,INN1,R);}

{\itshape
\ \ A2: lsrq}

{\itshape
\ \ \textbf{Generic} \textbf{map}(width)}

{\itshape
\ \ \textbf{Port} \textbf{Map}(clk,sq,q0,re,D);}

{\itshape
\ \ A3: Decrement}

{\itshape
\ \ \textbf{Port} \textbf{Map}(Clk,re,de,Z);}

{\itshape
\ \ A4: AddSub}

{\itshape
\ \ \textbf{Generic} \textbf{map}(width)}

{\itshape
\ \ \textbf{Port} \textbf{Map}(clk,re,ad,su,msb,R,B,INN1);}

{\itshape
\ \ A5: Controll}

{\itshape
\ \ \textbf{Port}
\textbf{Map}(Clk,Init,msb,Z,sh,re,q0,done,su,ad,de,ld,sq);}

{\itshape
\textbf{End} \textbf{Estructural};}

{\bfseries
CONTROLL}

{
A continuación debemos realizar la descripción funcional de cada uno de
los componentes. Comenzando por la unidad de control. En la siguiente
figura se muestra }

{
el diagrama de estados de la misma:}

{\centering 
\includegraphics[width=11.852cm,height=9.259cm]{FSM-img26.png} \par}

{\centering
Figura 26. Diagrama de estados de la unidad de control.
\par}

{
Como puede observarse en el diagrama de estados primero se realiza un
corrimiento del dividendo seguido por una operación de resta, en este
diseño no se realiza la suma para restaurar el registro A, ya que A no
cambia hasta que se cargue el registro. Por lo tanto solo se cargará el
registro con el resultado de la resta cuando el resultado de la misma
sea positiva.}

{
La descripción funcional del módulo controll es la siguiente:}

{\itshape
\textbf{Library} IEEE;}

{\itshape
\textbf{USE} IEEE.STD\_LOGIC\_1164.all;}

{\itshape
\textbf{USE} IEEE.STD\_LOGIC\_ARITH.all;}

{\itshape
\textbf{USE} IEEE.STD\_LOGIC\_UNSIGNED.all;}

{\itshape
\textbf{Entity} Controll \textbf{is}}

{\itshape
\textbf{Port}(}

{\itshape
\ \ Clk,Init, msb, Z\ \ \ \ : \textbf{IN}  STD\_LOGIC;}

{\itshape
\ \ shift,reset,q0,done\ \ : \textbf{OUT} STD\_LOGIC;}

{\itshape
\ \ sub,add,dec,load,sq\ \ :\textbf{OUT} STD\_LOGIC);}

{\itshape
\textbf{End} Controll;}

{\itshape
\textbf{Architecture} funcional \textbf{of} Controll \textbf{is}}

{\itshape
\textbf{Type} \textbf{state} \textbf{is} (rst, shft, subb, check, end1,
check1, Wait1);}

{\itshape
\textbf{signal} next\_state,current\_state : state;}

{\bfseries\itshape
Begin}

{\itshape
\ \ \textbf{Process} (Init,msb,Z, current\_state)}

{\itshape
\ \ \textbf{Begin}}

{\itshape
\ \ \textbf{Case} current\_state \textbf{is}}

{\itshape
\ \  \textbf{When} rst ={\textgreater} shift {\textless}=
{\textquotesingle}0{\textquotesingle};reset {\textless}=
{\textquotesingle}0{\textquotesingle};q0 {\textless}=
{\textquotesingle}0{\textquotesingle};sub {\textless}=
{\textquotesingle}0{\textquotesingle};}

{\itshape
 add {\textless}= {\textquotesingle}0{\textquotesingle};dec
{\textless}={\textquotesingle}0{\textquotesingle}; load {\textless}=
{\textquotesingle}0{\textquotesingle};done {\textless}=
{\textquotesingle}0{\textquotesingle};sq {\textless}=
{\textquotesingle}0{\textquotesingle};}

{\itshape
\ \ \textbf{if} init = {\textquotesingle}1{\textquotesingle}
\textbf{then}}

{\itshape
\ \   next\_state {\textless}= wait1;}

{\bfseries\itshape
\ \ else}

{\itshape
\ \   next\_state {\textless}= rst;}

{\itshape
\ \ \textbf{End} \textbf{If};}

{\itshape
\ \ \textbf{When} wait1 ={\textgreater} shift {\textless}=
{\textquotesingle}0{\textquotesingle};reset {\textless}=
{\textquotesingle}1{\textquotesingle};q0 {\textless}=
{\textquotesingle}0{\textquotesingle};sub {\textless}=
{\textquotesingle}0{\textquotesingle};}

{\itshape
 add {\textless}= {\textquotesingle}0{\textquotesingle};dec
{\textless}={\textquotesingle}0{\textquotesingle}; load {\textless}=
{\textquotesingle}0{\textquotesingle};done {\textless}=
{\textquotesingle}0{\textquotesingle};sq {\textless}=
{\textquotesingle}0{\textquotesingle};}

{\itshape
\ \   next\_state {\textless}= shft;}

{\itshape
\textbf{When} shft ={\textgreater} shift {\textless}=
{\textquotesingle}1{\textquotesingle};reset {\textless}=
{\textquotesingle}0{\textquotesingle};sub {\textless}=
{\textquotesingle}0{\textquotesingle};add {\textless}=
{\textquotesingle}0{\textquotesingle};}

{\itshape
 dec {\textless}={\textquotesingle}1{\textquotesingle}; load
{\textless}= {\textquotesingle}0{\textquotesingle};done {\textless}=
{\textquotesingle}0{\textquotesingle};sq {\textless}=
{\textquotesingle}1{\textquotesingle};}

{\itshape
 next\_state {\textless}= subb;}

{\itshape
\textbf{When} subb ={\textgreater} shift {\textless}=
{\textquotesingle}0{\textquotesingle};sub {\textless}=
{\textquotesingle}1{\textquotesingle};reset {\textless}=
{\textquotesingle}0{\textquotesingle};add {\textless}=
{\textquotesingle}0{\textquotesingle};}

{\itshape
 dec {\textless}={\textquotesingle}0{\textquotesingle}; load
{\textless}= {\textquotesingle}0{\textquotesingle};done {\textless}=
{\textquotesingle}0{\textquotesingle};q0{\textless}={\textquotesingle}0{\textquotesingle};sq
{\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 next\_state {\textless}= check;}

{\itshape
\textbf{when} check ={\textgreater} shift {\textless}=
{\textquotesingle}0{\textquotesingle};sub {\textless}=
{\textquotesingle}1{\textquotesingle};reset {\textless}=
{\textquotesingle}0{\textquotesingle};add {\textless}=
{\textquotesingle}0{\textquotesingle};}

{\itshape
 dec {\textless}={\textquotesingle}0{\textquotesingle};done {\textless}=
{\textquotesingle}0{\textquotesingle};sq {\textless}=
{\textquotesingle}0{\textquotesingle};}

{\itshape
\textbf{ }\textbf{if} msb = {\textquotesingle}1{\textquotesingle}
\textbf{then}}

{\itshape
 q0 {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 load {\textless}= {\textquotesingle}0{\textquotesingle};}

{\bfseries\itshape
 else}

{\itshape
 q0 {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 load {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
\textbf{ }\textbf{end} \textbf{if};}

{\itshape
 next\_state {\textless}= check1;}

{\itshape
\textbf{when} check1 ={\textgreater} shift {\textless}=
{\textquotesingle}0{\textquotesingle};sub {\textless}=
{\textquotesingle}0{\textquotesingle};add {\textless}=
{\textquotesingle}0{\textquotesingle};reset {\textless}=
{\textquotesingle}0{\textquotesingle};}

{\itshape
 dec {\textless}={\textquotesingle}0{\textquotesingle};done {\textless}=
{\textquotesingle}0{\textquotesingle};sq {\textless}=
{\textquotesingle}0{\textquotesingle};}

{\itshape
\textbf{ }\textbf{if} Z = {\textquotesingle}1{\textquotesingle}
\textbf{then}}

{\itshape
 next\_state {\textless}= end1;}

{\bfseries\itshape
 else}

{\itshape
 next\_state {\textless}= shft;}

{\itshape
\textbf{ }\textbf{end} \textbf{if};}

{\itshape
\textbf{when} end1 ={\textgreater} shift {\textless}=
{\textquotesingle}0{\textquotesingle};sub {\textless}=
{\textquotesingle}0{\textquotesingle};add {\textless}=
{\textquotesingle}0{\textquotesingle};dec
{\textless}={\textquotesingle}0{\textquotesingle};}

{\itshape
 reset {\textless}= {\textquotesingle}0{\textquotesingle}; load
{\textless}= {\textquotesingle}0{\textquotesingle};done {\textless}=
{\textquotesingle}1{\textquotesingle};sq {\textless}=
{\textquotesingle}1{\textquotesingle};}

{\itshape
 next\_state {\textless}= rst;}

{\itshape
\textbf{when} \textbf{others} ={\textgreater}}

{\itshape
 shift {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 sub {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 add {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 dec {\textless}={\textquotesingle}0{\textquotesingle};}

{\itshape
 reset {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 load {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 done {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 sq {\textless}= {\textquotesingle}0{\textquotesingle}; }

{\itshape
 q0 {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 next\_state {\textless}= rst;}

{\itshape
 \textbf{End} \textbf{Case};}

{\itshape
\textbf{End} \textbf{Process};}

{\itshape
\textbf{Process} (clk)}

{\itshape
 \textbf{Begin}}

{\itshape
 \textbf{if} (clk{\textquotesingle}\textbf{event} \textbf{and} clk =
{\textquotesingle}0{\textquotesingle}) \textbf{then}}

{\itshape
 current\_state {\textless}= next\_state; }

{\itshape
 \textbf{End} \textbf{if};}

{\itshape
 \textbf{End} \textbf{Process};}

{\itshape
\textbf{End} \textbf{funcional};}

{
La simulación de este módulo se muestra a continuación:}

{\centering 
\includegraphics[width=12.522cm,height=5.637cm]{FSM-img27.png} \par}

{\centering
Figura 27 Simulación de la unidad de control.
\par}

{\bfseries
LSRQ}

{
Este bloque es un registro de corrimiento a la izquierda con una entrada
que determina el valor del bit menos significativo. Su descripción
funcional es la siguiente:}

{\itshape
\textbf{Library} IEEE;}

{\itshape
\textbf{USE} IEEE.STD\_LOGIC\_1164.all;}

{\itshape
\textbf{USE} IEEE.STD\_LOGIC\_ARITH.all;}

{\itshape
\textbf{USE} IEEE.STD\_LOGIC\_UNSIGNED.all;}

{\itshape
\textbf{ENTITY} lsrq \textbf{IS}}

{\itshape
\ \ \textbf{GENERIC}(width:natural:=7);}

{\itshape
\ \ \textbf{PORT}(}

{\itshape
\ \   clk,shift,DIN,reset  : \textbf{IN}\ \ STD\_LOGIC;}

{\itshape
\ \   Qlsrq  : \textbf{BUFFER} STD\_LOGIC\_VECTOR(width \textbf{downto}
0));}

{\itshape
\textbf{END} lsrq;}

{\itshape
\textbf{Architecture} funcional \textbf{of} lsrq \textbf{is}}

{\bfseries\itshape
Begin}

{\itshape
\ \ \textbf{Process}(Clk)}

{\itshape
\ \ \textbf{Begin}}

{\itshape
\ \ \ \ \textbf{if} (Clk{\textquotesingle}\textbf{event and }Clk =
{\textquotesingle}1{\textquotesingle}) \textbf{then}}

{\itshape
\ \ \ \ \ \ \textbf{if} reset = {\textquotesingle}1{\textquotesingle}
\textbf{then}}

{\itshape
\ \ \ \ \ \ \ \ Qlsrq {\textless}=
{\textquotedbl}00000000{\textquotedbl};}

{\itshape
\ \ \ \ \ \ \textbf{elsif} (shift =
{\textquotesingle}1{\textquotesingle}) \textbf{then}}

{\itshape
\ \ \ \ \ \ \ \ Qlsrq(width \textbf{downto} 1) {\textless}= Qlsrq((width
- 1) \textbf{downto} 0);}

{\itshape
\ \ \ \ \ \ \ \ Qlsrq(0) {\textless}= DIN;\ \ \ \ \ \ \ \ }

{\itshape
\ \ \ \ \ \ \textbf{else}}

{\itshape
\ \ \ \ \ \ \ \ Qlsrq {\textless}= Qlsrq;}

{\itshape
\ \ \ \ \ \ \textbf{end} \textbf{if};}

{\itshape
\ \ \ \ \textbf{end} \textbf{if};}

{\itshape
\ \ \textbf{End} \textbf{Process};}

{\itshape
\textbf{End} \textbf{funcional};}

{
La simulación del módulo LSRQ se muestra en la siguiente figura.}

{\centering  \includegraphics[width=13.03cm,height=2.3cm]{FSM-img28.png}
\par}

{\centering
Figura 28. Simulación del módulo LSRQ.
\par}

{\bfseries
LSR}

{
Este módulo está encargado de realizar el corrimiento a la izquierda del
dividendo y almacenar los resultados de la resta. La descripción
funcional de este módulo es el siguiente:}

{\itshape
\textbf{Library} IEEE;}

{\itshape
\textbf{USE} IEEE.STD\_LOGIC\_1164.all;}

{\itshape
\textbf{USE} IEEE.STD\_LOGIC\_ARITH.all;}

{\itshape
\textbf{USE} IEEE.STD\_LOGIC\_UNSIGNED.all;}

{\itshape
\textbf{ENTITY} lsr \textbf{IS}}

{\itshape
\ \ \textbf{GENERIC}(width:natural:=7);}

{\itshape
\ \ \textbf{PORT}(}

{\itshape
\ \ \ \ clk,shift,load,reset: \textbf{IN}  STD\_LOGIC;}

{\itshape
\ \ \ \ Data,DataL: \ \   \textbf{IN}  STD\_LOGIC\_VECTOR(width
\textbf{downto} 0);}

{\itshape
\ \ \ \ Qlsr: \ \ \ \ \textbf{BUFFER} STD\_LOGIC\_VECTOR(width
\textbf{downto} 0));}

{\itshape
\textbf{END} lsr;}

{\itshape
\textbf{ARCHITECTURE} funcional \textbf{OF} lsr \textbf{IS}}

{\itshape
\ \ \textbf{SIGNAL} INN1: STD\_LOGIC\_VECTOR(width \textbf{downto} 0);}

{\bfseries\itshape
BEGIN}

{\itshape
 \textbf{Process}(CLK)}

{\itshape
\ \ \textbf{Begin}}

{\itshape
\ \ \ \ \textbf{if} (clk{\textquotesingle}\textbf{event} \textbf{and}
clk = {\textquotesingle}1{\textquotesingle}) \textbf{then}}

{\itshape
\ \ \ \ \ \ \textbf{if} Reset = {\textquotesingle}1{\textquotesingle}
\textbf{then}}

{\itshape
\ \ \ \ \ \ \ \ Qlsr
{\textless}={\textquotedbl}00000000{\textquotedbl};}

{\itshape
\ \ \ \ \ \ \ \ INN1 {\textless}= Data;}

{\itshape
\ \ \ \ \ \ \textbf{elsif} load = {\textquotesingle}1{\textquotesingle}
\textbf{then}}

{\itshape
\ \ \ \ \ \ \ \ Qlsr {\textless}= DataL;}

{\itshape
\ \ \ \ \ \ \textbf{elsif} shift = {\textquotesingle}1{\textquotesingle}
\textbf{then}}

{\itshape
\ \ \ \ \ \ \ \ Qlsr(width \textbf{downto} 1) {\textless}= Qlsr((Width
-1 ) \textbf{downto} 0);}

{\itshape
\ \ \ \ \ \ \ \ Qlsr(0) {\textless}= INN1(width);}

{\itshape
\ \ \ \ \ \ \ \ INN1(width \textbf{downto} 1) {\textless}= INN1((Width
-1 ) \textbf{downto} 0);}

{\itshape
\ \ \ \ \ \ \ \ INN1(0) {\textless}=
{\textquotesingle}0{\textquotesingle};}

{\itshape
\ \ \ \ \ \ \textbf{end} \textbf{if};}

{\itshape
\ \ \ \ \textbf{else}}

{\itshape
\ \ \ \ \ \ Qlsr {\textless}= Qlsr;}

{\itshape
\ \ \ \ \textbf{end} \textbf{if};}

{\itshape
 \textbf{End} \textbf{Process};}

{\itshape
\textbf{END} funcional;}

{
La simulación de este módulo se muestra en la Figura 29.}

{\centering 
\includegraphics[width=12.786cm,height=3.512cm]{FSM-img29.png} \par}

{\centering
Figura 29. Simulación del módulo LSR.
\par}

{\bfseries
DECREMENT}

{
Este módulo está encargado de controlar el número de veces que se
realizan las iteraciones. La descripción funcional se muestra a
continuación:}

{\itshape
\textbf{Library} IEEE;}

{\itshape
\textbf{USE} IEEE.STD\_LOGIC\_1164.all;}

{\itshape
\textbf{USE} IEEE.STD\_LOGIC\_ARITH.all;}

{\itshape
\textbf{USE} IEEE.STD\_LOGIC\_UNSIGNED.all;}

{\itshape
\textbf{Entity} Decrement \textbf{is}}

{\itshape
\textbf{Port}(}

{\itshape
\ \ Clk,Init,dec\ \ : \textbf{IN}\ \ STD\_LOGIC;}

{\itshape
\ \ Z\ \ \ \ : \textbf{OUT} STD\_LOGIC);}

{\itshape
\textbf{End} Decrement;}

{\itshape
\textbf{Architecture} funcional \textbf{of} Decrement \textbf{is}}

{\itshape
\textbf{Signal} INN1 : Std\_logic\_vector (2 downto 0);}

{\itshape
\textbf{signal} end1 : Std\_Logic;}

{\bfseries\itshape
Begin}

{\itshape
\ \ \textbf{Process} (Clk,dec)}

{\itshape
\ \ \textbf{Begin}}

{\itshape
\ \ \ \ \textbf{if} (Clk\textbf{{\textquotesingle}event} \textbf{and}
Clk = {\textquotesingle}1{\textquotesingle}) \textbf{then}}

{\itshape
\ \ \ \ \ \ \textbf{if} Init = {\textquotesingle}1{\textquotesingle} 
\textbf{then}}

{\itshape
\foreignlanguage{english}{\ \ \ \ \ \ \ \ }\foreignlanguage{spanish}{Z
{\textless}= {\textquotesingle}0{\textquotesingle};}}

{\itshape
\ \ \ \ \ \ \ \ INN1 {\textless}= {\textquotedbl}111{\textquotedbl};}

{\itshape
\foreignlanguage{spanish}{\ \ \ \ \ \ \ \ }\foreignlanguage{english}{end1
{\textless}= {\textquotesingle}0{\textquotesingle};}}

{\itshape
\ \ \ \ \ \ \textbf{elsif} (dec = {\textquotesingle}1{\textquotesingle}
\textbf{and} end1 = {\textquotesingle}0{\textquotesingle})
\textbf{then}}

{\itshape
\ \ \ \ \ \ \ \ \textbf{if} (INN1 {\textgreater} 0) \textbf{then}}

{\itshape
\ \ \ \ \ \ \ \ \ \ z {\textless}=
{\textquotesingle}0{\textquotesingle};}

{\itshape
\ \ \ \ \ \ \ \ \ \ INN1 {\textless}= INN1 - 1;}

{\itshape
\ \ \ \ \ \ \ \ \textbf{else}}

{\itshape
\ \ \ \ \ \ \ \ \ \ z{\textless}=
{\textquotesingle}1{\textquotesingle};}

{\itshape
\ \ \ \ \ \ \ \ \ \ end1 {\textless}=
{\textquotesingle}1{\textquotesingle};}

{\itshape
\ \ \ \ \ \ \ \ \textbf{End} \textbf{if};}

{\itshape
\ \ \ \ \ \ \textbf{else}}

{\itshape
\ \ \ \ \ \ \ \ INN1 {\textless}= INN1;}

{\itshape
\ \ \ \ \ \ \textbf{end} \textbf{if};}

{\itshape
\ \ \ \ \textbf{End} \textbf{if};}

{\itshape
\ \ \textbf{End} \textbf{Process};}

{\itshape
\textbf{End} \textbf{funcional};}

{
La simulación de este módulo se muestra en la Figura 30.}

{\centering 
\includegraphics[width=12.778cm,height=2.286cm]{FSM-img30.png} \par}

{
Figura 30. Simulación del módulo DECREMENT.}

{\bfseries
ADDSUB}

{
Este módulo está encargado de realizar la resta para determinar si al
número contenido en el módulo LSR se le puede restar el divisor. La
descripción funcional de este módulo se muestra a continuación.}

{\itshape
\textbf{Library} IEEE;}

{\itshape
\textbf{USE} IEEE.STD\_LOGIC\_1164.all;}

{\itshape
\textbf{USE} IEEE.STD\_LOGIC\_ARITH.all;}

{\itshape
\textbf{USE} IEEE.STD\_LOGIC\_UNSIGNED.all;}

{\itshape
\textbf{ENTITY} addsub \textbf{IS}}

{\itshape
\ \ GENERIC(width:natural:=7);}

{\itshape
\ \ \textbf{PORT}(}

{\itshape
\ \ \ \ clk,reset,add,sub: \ \ \textbf{IN} STD\_LOGIC;}

{\itshape
\ \ \ \ msb: \ \ \ \ \ \ \textbf{OUT} STD\_LOGIC;}

{\itshape
\ \ \ \ A,B\ \ : \ \ \textbf{IN} STD\_LOGIC\_VECTOR(width downto 0);}

{\itshape
\ \ \ \ AS: \ \ \ \ \textbf{BUFFER} STD\_LOGIC\_VECTOR(width downto
0));}

{\itshape
\textbf{END} addsub;}

{\itshape
\textbf{ARCHITECTURE} funcional \textbf{OF} addsub \textbf{IS}}

{\bfseries\itshape
BEGIN}

{\itshape
\ \ \textbf{PROCESS} (clk, Reset)}

{\itshape
\ \ \ \ \textbf{BEGIN}}

{\itshape
\ \ \ \   \textbf{if} Reset = {\textquotesingle}1{\textquotesingle}
\textbf{then}}

{\itshape
 AS {\textless}= {\textquotedbl}00000000{\textquotedbl};}

{\itshape
\ \ \ \   \textbf{else}}

{\itshape
\ \ \ \ \ \ \textbf{if} (clk\textbf{{\textquotesingle}event and}
clk={\textquotesingle}1{\textquotesingle}) \textbf{then}}

{\itshape
\ \ \ \ \ \ \ \ \textbf{if} add = {\textquotesingle}1{\textquotesingle}
\textbf{and} sub = {\textquotesingle}0{\textquotesingle} \textbf{then}}

{\itshape
\ \ \ \ \ \ \ \ \ \ AS {\textless}= A + B;}

{\itshape
\ \ \ \ \ \ \ \ \textbf{elsif} add =
{\textquotesingle}0{\textquotesingle} \textbf{and} sub =
{\textquotesingle}1{\textquotesingle} \textbf{then}}

{\itshape
\ \ \ \ \ \ \ \ \ \ AS {\textless}= A - B;}

{\itshape
\ \ \ \ \ \ \ \ \textbf{else}}

{\itshape
\ \ \ \ \ \ \ \ \ \ AS {\textless}=
{\textquotedbl}00000000{\textquotedbl};}

{\itshape
\ \ \ \ \ \ \ \ \textbf{end} \textbf{if};}

{\itshape
\ \ \ \ \ \ \textbf{end} \textbf{if};}

{
\textbf{\textit{\ \ \ \   End if}};}

{\itshape
\ \ \ \ \textbf{END} \textbf{PROCESS};}

{\itshape
\ \ \textbf{Process}(AS)}

{\itshape
\ \ \ \ \textbf{Begin}}

{\itshape
\ \ \ \ \ \ MSB {\textless}= AS(width);}

{\itshape
\ \ \textbf{End} \textbf{Process};}

{\itshape
\textbf{END} \textbf{funcional};}

{\centering 
\includegraphics[width=13.294cm,height=3.214cm]{FSM-img31.png} \par}

{
Figura 31. Simulación del módulo ADDSUB.}

{\bfseries
DIVISOR}

{
Finalmente se realizó la simulación del archivo DIVISOR.VHD. El cual
contiene la unión de los módulos anteriores. La simulación del divisor
se muestra en la Figura 32. Y la implementación en VHDL del
\textit{testbench} se muestra a continuación:}

{\itshape
\textbf{LIBRARY} ieee;}

{\itshape
\textbf{USE} ieee.std\_logic\_1164.ALL;}

{\itshape
\textbf{USE} ieee.numeric\_std.ALL;}

{\itshape
\textbf{ENTITY} testbench \textbf{IS}}

{\itshape
\textbf{END} testbench;}

{\itshape
\textbf{ARCHITECTURE} behavior \textbf{OF} testbench \textbf{IS} }

{\itshape
\ \ \textbf{COMPONENT} divisor}

{\itshape
\ \ \textbf{PORT}(}

{\itshape
\ \ \ \ A : \textbf{IN} std\_logic\_vector(7 \textbf{downto} 0);}

{\itshape
\ \ \ \ B : \textbf{IN} std\_logic\_vector(7 \textbf{downto} 0);}

{\itshape
\ \ \ \ Init : \textbf{IN} std\_logic;}

{\itshape
\ \ \ \ clk : \textbf{IN} std\_logic;  }

{\itshape
\ \ \ \ D : \textbf{BUFFER} std\_logic\_vector(7 \textbf{downto} 0);}

{\itshape
\ \ \ \ R : \textbf{BUFFER} std\_logic\_vector(7 \textbf{downto} 0);}

{\itshape
\ \ \ \ Done : \textbf{OUT} std\_logic}

{\itshape
\ \ \ \ );}

{\itshape
\ \ \textbf{END} \textbf{COMPONENT};}

{\itshape
\ \ \textbf{SIGNAL} A :  std\_logic\_vector(7 \textbf{downto} 0);}

{\itshape
\ \ \textbf{SIGNAL} B :  std\_logic\_vector(7 \textbf{downto} 0);}

{\itshape
\ \ \textbf{SIGNAL} Init :  std\_logic;}

{\itshape
\ \ \textbf{SIGNAL} clk :  std\_logic;}

{\itshape
\ \ \textbf{SIGNAL} D :  std\_logic\_vector(7 \textbf{downto} 0);}

{\itshape
\ \ \textbf{SIGNAL} R :  std\_logic\_vector(7 \textbf{downto} 0);}

{\itshape
\ \ \textbf{SIGNAL} Done :  std\_logic;}

{\itshape
 \textbf{constant} ncycles : \textbf{integer} := 80;}

{\itshape
 \textbf{constant} halfperiod : \textbf{time} := 5 ns;}

{\bfseries\itshape
BEGIN}

{\itshape
\ \ uut: divisor PORT MAP(}

{\itshape
\ \ \ \ A ={\textgreater} A,}

{\itshape
\ \ \ \ B ={\textgreater} B,}

{\itshape
\ \ \ \ Init ={\textgreater} Init,}

{\itshape
\ \ \ \ clk ={\textgreater} clk,}

{\itshape
\ \ \ \ D ={\textgreater} D,}

{\itshape
\ \ \ \ R ={\textgreater} R,}

{\itshape
\ \ \ \ Done ={\textgreater} Done}

{\itshape
\ \ );}

{\itshape
 {}-{}- Generacion del Reloj}

{\itshape
 Clock\_Source: \textbf{process}}

{\itshape
 \textbf{begin}}

{\itshape
 \textbf{for} i \textbf{in} 0 \textbf{to} ncycles \textbf{loop}  {}-{}-
Genera ncyclos de periodo 10 ns}

{\itshape
 CLK {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{wait} \textbf{for} halfperiod;}

{\itshape
 CLK {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{wait} \textbf{for} halfperiod;}

{\itshape
 \textbf{end} \textbf{loop};}

{\itshape
 \textbf{wait};}

{\itshape
 \textbf{end} \textbf{process} Clock\_Source;}

{\itshape
 tb : \textbf{PROCESS}}

{\itshape
 \textbf{BEGIN}}

{\itshape
 A  {\textless}= {\textquotedbl}01100100{\textquotedbl};}

{\itshape
\ \   B  {\textless}= {\textquotedbl}00000011{\textquotedbl};}

{\itshape
\ \   INIT {\textless}= {\textquotesingle}0{\textquotesingle};
\textbf{wait} \textbf{for} halfperiod;}

{\itshape
\ \   INIT {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
\ \   \textbf{wait} \textbf{until} CLK\textbf{{\textquotesingle}event}
\textbf{and} CLK={\textquotesingle}1{\textquotesingle};}

{\itshape
\ \   \textbf{wait} \textbf{until} CLK\textbf{{\textquotesingle}event}
\textbf{and} CLK={\textquotesingle}1{\textquotesingle};}

{\itshape
\ \   \textbf{wait} \textbf{until} CLK\textbf{{\textquotesingle}event}
\textbf{and} CLK={\textquotesingle}0{\textquotesingle};}

{\itshape
\ \   INIT {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{wait} \textbf{until} Done\textbf{{\textquotesingle}event}
\textbf{and} Done = {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{for} i \textbf{in} 1 \textbf{to} 6 \textbf{loop}}

{\itshape
 \textbf{wait} \textbf{until} CLK\textbf{{\textquotesingle}event}
\textbf{and} CLK={\textquotesingle}1{\textquotesingle};}

{\itshape
 \ \   \textbf{end} \textbf{loop};}

{\itshape
 INIT {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
\ \   B  {\textless}= {\textquotedbl}00001111{\textquotedbl};}

{\itshape
 \ \   \textbf{wait} \textbf{until} CLK\textbf{{\textquotesingle}event}
\textbf{and} CLK={\textquotesingle}1{\textquotesingle};}

{\itshape
\ \   \textbf{wait} \textbf{until} CLK\textbf{{\textquotesingle}event
and} CLK={\textquotesingle}1{\textquotesingle};}

{\itshape
\ \   \textbf{wait} \textbf{until} CLK\textbf{{\textquotesingle}event}
\textbf{and} CLK={\textquotesingle}0{\textquotesingle};}

{\itshape
\ \   INIT {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{wait} \textbf{until} Done\textbf{{\textquotesingle}event}
\textbf{and} Done = {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{wait};}

{\itshape
 \textbf{END} \textbf{PROCESS};}

{\itshape
\textbf{END};}

 \includegraphics[width=13.279cm,height=3.231cm]{FSM-img32.png} 

{
Figura 32. Simulación del divisor.}

{
\textbf{Segunda Implementación:} En esta sección se realizará la
implementación del divisor utilizando un procedimiento que realice la
operación de división. Inicialmente declararemos un package al cual
llamaremos \textit{aritmetico} para después utilizarlo en una entidad:}

{\itshape
\textbf{library} ieee;  }

{\itshape
\textbf{use} ieee.std\_logic\_1164.all;}

{\itshape
\textbf{package} aritmetico \textbf{is}}

{\itshape
{}-{}- Todo package se divide en dos partes en la primera (encabezado)
se realiza la }

{\itshape
{}-{}- declaración de los elementos que los constituyen, indicando
únicamente sus entradas }

{\itshape
{}-{}- y salidas:}

{\itshape
 \textbf{procedure} add ( A, B : \textbf{in} bit\_vector;  }

{\itshape
 \ \   suma : \textbf{out} bit\_vector; 
\textcolor[rgb]{0.7529412,0.7529412,0.7529412}{{}-{}-Declaración de un
sumador}}

{\itshape
\foreignlanguage{spanish}{\ \ \ \   }\foreignlanguage{english}{over :
}\foreignlanguage{english}{\textbf{out}}\foreignlanguage{english}{
boolean );  }}

{\itshape
 \textbf{procedure} sub ( A, B : \textbf{in} bit\_vector;}

{\itshape
\foreignlanguage{english}{ }\foreignlanguage{english}{\ \  
}\foreignlanguage{spanish}{resta :
}\foreignlanguage{spanish}{\textbf{out}}\foreignlanguage{spanish}{
bit\_vector; 
}\foreignlanguage{spanish}{\textcolor[rgb]{0.7529412,0.7529412,0.7529412}{{}-{}-Declaración
de un restador}}}

{\itshape
\foreignlanguage{spanish}{\ \ \ \   }\foreignlanguage{english}{over :
}\foreignlanguage{english}{\textbf{out}}\foreignlanguage{english}{
boolean );}}

{\itshape
 \textbf{procedure} divisor }

{\itshape
 ( Q, M  : \textbf{in} bit\_vector;}

{\itshape
\foreignlanguage{english}{ }\foreignlanguage{spanish}{cociente :
}\foreignlanguage{spanish}{\textbf{out}}\foreignlanguage{spanish}{
bit\_vector; 
}\foreignlanguage{spanish}{\textcolor[rgb]{0.7529412,0.7529412,0.7529412}{
{}-{}-Declaración de un divisor.}}}

{\itshape
\foreignlanguage{spanish}{ }\foreignlanguage{english}{residuo  :
}\foreignlanguage{english}{\textbf{out}}\foreignlanguage{english}{
bit\_vector;}}

{\itshape
 div\_cero : \textbf{out} boolean);}

{\itshape
\textbf{end} \textbf{package} aritmetico;}

{\itshape\color[rgb]{0.7529412,0.7529412,0.7529412}
{}-{}- La segunda parte del Package recibe el nombre de cuerpo (body) y
debe}

{\itshape\color[rgb]{0.7529412,0.7529412,0.7529412}
{}-{}- contener la descripción funcional de cada uno de los componentes
declarados }

{\itshape\color[rgb]{0.7529412,0.7529412,0.7529412}
{}-{}- en la primera parte.}

{\itshape
\textbf{package} \textbf{body} aritmetico \textbf{is}}

{\itshape\color[rgb]{0.7529412,0.7529412,0.7529412}
{}-{}-Una vez realizada la descripción de los elementos que forman el
package se }

{\itshape\color[rgb]{0.7529412,0.7529412,0.7529412}
{}-{}-debe ndicar su funcionemiento}

{\itshape
{}-{}-*****************************}

{\itshape
{}-{}-*****SUMADOR DE N BITS*******}

{\itshape
{}-{}-*****************************}

{\itshape
 \textbf{procedure} add ( A, B : \textbf{in} bit\_vector;}

{\itshape
\foreignlanguage{english}{ }\foreignlanguage{spanish}{suma :
}\foreignlanguage{spanish}{\textbf{out}}\foreignlanguage{spanish}{
bit\_vector; 
}\foreignlanguage{spanish}{\textcolor[rgb]{0.7529412,0.7529412,0.7529412}{{}-{}-Esta
declaración debe ser idéntica a la anterior}}\foreignlanguage{spanish}{
}}

{\itshape
\foreignlanguage{spanish}{ }\foreignlanguage{english}{over : out boolean
) }\foreignlanguage{english}{\textbf{is}}}

{\itshape
 \textbf{alias} op1 : bit\_vector(A{\textquotesingle}length - 1 downto
0) \textbf{is} A;}

{\itshape
 \textbf{alias} op2 : bit\_vector(B{\textquotesingle}length - 1 downto
0) \textbf{is} B;  }

{\itshape
 \textbf{variable} result  : bit\_vector(suma{\textquotesingle}length -
1 \textbf{downto} 0);}

{\itshape
 \textbf{variable} carry\_in  : bit;}

{\itshape
 \textbf{variable} carry\_out : bit :=
{\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{begin}}

{\itshape
 \textbf{for} index \textbf{in}
result\textbf{{\textquotesingle}reverse}\_range \textbf{loop}  }

{\itshape
 carry\_in := carry\_out; 
\textcolor[rgb]{0.7529412,0.7529412,0.7529412}{{}-{}- Carry IN = Carry
OUT del bit anterior}}

{\itshape
 result(index) := op1(index) \textbf{xor} op2(index) \textbf{xor}
carry\_in;  \textcolor[rgb]{0.7529412,0.7529412,0.7529412}{{}-{}-
Sumador de un bit}}

{\itshape
 carry\_out := (op1(index) \textbf{and} op2(index)) 
\textcolor[rgb]{0.7529412,0.7529412,0.7529412}{{}-{}- con Carry.}}

{\itshape
 \ \   \textbf{or} (carry\_in \textbf{and} (op1(index) \textbf{xor}
op2(index)));}

{\itshape
 \textbf{end} \textbf{loop};}

{\itshape
 suma := result;}

{\itshape
 over := carry\_out /= carry\_in;}

{\itshape
 \textbf{end} add;}

{\itshape
{}-{}-******************************}

{\itshape
{}-{}-*****RESTADOR DE N BITS*******}

{\itshape
{}-{}-******************************}

{\itshape
 \textbf{procedure} sub ( A, B : \textbf{in} bit\_vector;}

{\itshape
 \ \   resta : \textbf{out} bit\_vector;}

{\itshape
 over : \textbf{out} boolean ) \textbf{is}}

{\itshape
 \textbf{alias} op1 : bit\_vector(A\textbf{{\textquotesingle}length} - 1
\textbf{downto }0) \textbf{is }A;}

{\itshape
 \textbf{alias} op2 : bit\_vector(B\textbf{{\textquotesingle}length }{}-
1 \textbf{downto }0) \textbf{is }B;  }

{\itshape
 \textbf{variable} result :
bit\_vector(resta\textbf{{\textquotesingle}length }{}- 1 \textbf{downto
}0);}

{\itshape
 \textbf{variable} carry\_in : bit;}

{\itshape
\foreignlanguage{english}{
}\foreignlanguage{spanish}{\textbf{variable}}\foreignlanguage{spanish}{
carry\_out : bit := {\textquotesingle}1{\textquotesingle} 
}\foreignlanguage{spanish}{\textcolor[rgb]{0.7529412,0.7529412,0.7529412}{{}-{}-
Para realizar la suma en complemento a dos}}}

{\itshape
 \ \ \ \ \ \ \ \   \textcolor[rgb]{0.7529412,0.7529412,0.7529412}{{}-{}-
Es necesario realizar (A + Complemento (B) + 1).}}

{\itshape
 \textbf{begin}}

{\itshape\color[rgb]{0.7529412,0.7529412,0.7529412}
{}-{}-Implementación de un restador, utilizando suma en complemento a
dos}

{\itshape
\foreignlanguage{spanish}{
}\foreignlanguage{english}{\textbf{for}}\foreignlanguage{english}{
index }\foreignlanguage{english}{\textbf{in}}\foreignlanguage{english}{
result}\foreignlanguage{english}{\textbf{{\textquotesingle}reverse\_range}}\foreignlanguage{english}{
}\foreignlanguage{english}{\textbf{loop}}}

{\itshape
 carry\_in := carry\_out;  }

{\itshape
 result(index) := op1(index) \textbf{xor }(not op2(index)) \textbf{xor
}carry\_in;}

{\itshape
 carry\_out := (op1(index) \textbf{and }(\textbf{not }op2(index)))}

{\itshape
 \ \   \ \   \textbf{or }(carry\_in and (op1(index) \textbf{xor
}(\textbf{not }op2(index))));}

{\itshape
 \textbf{end loop};}

{\itshape
 resta := result;}

{\itshape
 over  := carry\_out /= carry\_in;}

{\itshape
 \textbf{end }sub;}
% 
% {\itshape
% {}-{}-*****************************}
% 
% {\itshape
% {}-{}-*****DIVISOR DE N BITS*******}
% 
% {\itshape
% {}-{}-*****************************}
% 
% {\itshape
%  \textbf{procedure }divisor}
% 
% {\itshape
%  ( Q, M : \textbf{in }bit\_vector;}
% 
% {\itshape
%  cociente : \textbf{out }bit\_vector;}
% 
% {\itshape
%  residuo  : \textbf{out }bit\_vector;}
% 
% {\itshape
%  div\_cero : \textbf{out }boolean ) \textbf{is}}
% 
% {\itshape
%  \textbf{constant }len : natural := Q\textbf{{\textquotesingle}length};}
% 
% {\itshape
%  \textbf{constant }zero\_divisor : bit\_vector(len - 1 \textbf{downto
% }0) := (\textbf{others }={\textgreater}
% {\textquotesingle}0{\textquotesingle});}
% 
% {\itshape
%  \textbf{alias }dividend : bit\_vector(Q\textbf{{\textquotesingle}length
% }{}- 1 \textbf{downto }0) \textbf{is }Q;}
% 
% {\itshape
%  \textbf{variable }divisor :
% bit\_vector(M\textbf{{\textquotesingle}length downto }0) :=
% {\textquotesingle}0{\textquotesingle} \& M;}
% 
% {\itshape
%  \textbf{variable }quotient : bit\_vector(len - 1 \textbf{downto }0);}
% 
% {\itshape
%  \textbf{variable }remainder : bit\_vector(len \textbf{downto }0) :=
% (\textbf{others }={\textgreater}
% {\textquotesingle}0{\textquotesingle});}
% 
% {\itshape
%  \textbf{variable }ignore\_overflow  : boolean;}
% 
% {\itshape
% \foreignlanguage{english}{ }\foreignlanguage{spanish}{\textbf{begin}}}
% 
% {\itshape
%  \textcolor[rgb]{0.7529412,0.7529412,0.7529412}{{}-{}-  Revisa si se
% está dividiendo por cero.}}
% 
% {\itshape
% \foreignlanguage{spanish}{ }\foreignlanguage{english}{\textbf{if
% }}\foreignlanguage{english}{M = zero\_divisor
% }\foreignlanguage{english}{\textbf{then}}}
% 
% {\itshape
% \foreignlanguage{english}{ }\foreignlanguage{spanish}{div\_cero := true;
% 
% }\foreignlanguage{spanish}{\textcolor[rgb]{0.7529412,0.7529412,0.7529412}{{}-{}-
% Si M = 0; div\_cero = true}}}
% 
% {\itshape
%  \textbf{return};  \textcolor[rgb]{0.7529412,0.7529412,0.7529412}{{}-{}-
% Salir del procedimiento}}
% 
% {\itshape
%  \textbf{end if};}
% 
% {\itshape
%  \textcolor[rgb]{0.7529412,0.7529412,0.7529412}{{}-{}-  Algoritmo de
% división}}
% 
% {\itshape
% \foreignlanguage{spanish}{ }\foreignlanguage{english}{\textbf{for
% }}\foreignlanguage{english}{iter }\foreignlanguage{english}{\textbf{in
% }}\foreignlanguage{english}{len - 1
% }\foreignlanguage{english}{\textbf{downto }}\foreignlanguage{english}{0
% }\foreignlanguage{english}{\textbf{loop}}}
% 
% {\itshape
% \foreignlanguage{english}{ }\foreignlanguage{spanish}{\textbf{if
% }}\foreignlanguage{spanish}{remainder(len) =
% {\textquotesingle}0{\textquotesingle}
% }\foreignlanguage{spanish}{\textbf{then 
% }}\foreignlanguage{spanish}{\textcolor[rgb]{0.7529412,0.7529412,0.7529412}{{}-{}-
% Si el MSB del residuo (A) es cero, el}}\foreignlanguage{spanish}{ }}
% 
% {\itshape
% \textbf{ }\textcolor[rgb]{0.7529412,0.7529412,0.7529412}{{}-{}- residuo
% es positivo}}
% 
% {\itshape
%  remainder := remainder \textbf{sll }1; 
% \textcolor[rgb]{0.7529412,0.7529412,0.7529412}{{}-{}- Rotación a la
% izquierda del residuo}}
% 
% {\itshape
%  remainder(0) := dividend(iter); 
% \textcolor[rgb]{0.7529412,0.7529412,0.7529412}{{}-{}- Se
% {\textquotedbl}baja{\textquotedbl} el siguiente bit del Dividendo} }
% 
% {\itshape\color[rgb]{0.7529412,0.7529412,0.7529412}
% {}-{}- Residuo (A) = Residuo + Divisor (M)}
% 
% {\itshape
%  \textbf{sub}(remainder, divisor, remainder, ignore\_overflow);
% \textbf{else}  \textcolor[rgb]{0.7529412,0.7529412,0.7529412}{{}-{}- Si
% el MSB del residuo es uno, el residuo es negativo}}
% 
% {\itshape
%  remainder := remainder \textbf{sll }1;\ \  
% \textcolor[rgb]{0.7529412,0.7529412,0.7529412}{{}-{}- Rotación a la
% izquierda del residuo}}
% 
% {\itshape
%  remainder(0) := dividend(iter); 
% \textcolor[rgb]{0.7529412,0.7529412,0.7529412}{{}-{}- Se
% {\textquotedbl}baja{\textquotedbl} el siguiente bit del Dividendo}}
% 
% {\itshape
% \textcolor[rgb]{0.7529412,0.7529412,0.7529412}{{}-{}- Residuo (A) =}
% \textcolor[rgb]{0.7529412,0.7529412,0.7529412}{Residuo - Divisor (M)}}
% 
% {\itshape
% \foreignlanguage{spanish}{
% }\foreignlanguage{english}{\textbf{add}}\foreignlanguage{english}{(remainder,
% divisor, remainder, ignore\_overflow);
% }\foreignlanguage{english}{\textbf{end
% if}}\foreignlanguage{english}{;}}
% 
% {\itshape
% \foreignlanguage{english}{ }\foreignlanguage{spanish}{quotient(iter) :=
% }\foreignlanguage{spanish}{\textbf{not
% }}\foreignlanguage{spanish}{remainder(len);
% }\foreignlanguage{spanish}{\textcolor[rgb]{0.7529412,0.7529412,0.7529412}{{}-{}-
% El bit actual del cociente es 1 si el}}\foreignlanguage{spanish}{ }}
% 
% {\itshape
%  \textcolor[rgb]{0.7529412,0.7529412,0.7529412}{{}-{}- residuo es
% positivo}}
% 
% {\itshape
%  \textbf{end loop}; 
% \textcolor[rgb]{0.7529412,0.7529412,0.7529412}{{}-{}- y es 0 si es
% negativo.}}
% 
% {\itshape\color[rgb]{0.7529412,0.7529412,0.7529412}
% {}-{}- Cuando el residuo es negativo se restaura el valor del mismo}
% 
% {\itshape
% \foreignlanguage{spanish}{ }\foreignlanguage{english}{\textbf{if
% }}\foreignlanguage{english}{remainder(len) =
% {\textquotesingle}1{\textquotesingle}
% }\foreignlanguage{english}{\textbf{then}}\foreignlanguage{english}{\textcolor[rgb]{0.7529412,0.7529412,0.7529412}{.}}}
% 
% {\itshape
%  \textbf{add}(remainder, divisor, remainder, ignore\_overflow); }
% 
% {\itshape
%  \textbf{end if};  }
% 
% {\itshape
%  cociente := quotient;}
% 
% {\itshape
% \foreignlanguage{english}{ }\foreignlanguage{spanish}{residuo  :=
% remainder(len - 1 }\foreignlanguage{spanish}{\textbf{downto
% }}\foreignlanguage{spanish}{0);}}
% 
% {\itshape
%  div\_cero := false;}
% 
% {\itshape
% \foreignlanguage{spanish}{ }\foreignlanguage{english}{\textbf{end
% }}\foreignlanguage{english}{divisor;}}

{\itshape
\textbf{end package body }aritmetico;}

{
A continuación se presenta un ejemplo de llamado del procedimiento
divisor por una entidad:}

{\itshape
\textbf{library} ieee;  }

{\itshape
\textbf{use} ieee.std\_logic\_1164.all;}

{\itshape\color[rgb]{0.7529412,0.7529412,0.7529412}
{}-{}-Al hacer el llamado del Package se debe indicar que se encuentra
en el }

{\itshape\color[rgb]{0.7529412,0.7529412,0.7529412}
{}-{}-directorio de trabajo (libreria work);}

{\itshape
\textbf{library} work;}

{\itshape
\textbf{use} work.aritmetico.all;}

{\itshape
{}-{}-Declaración de la Entidad}

{\itshape
\textbf{entity} cain \textbf{is}}

{\itshape
 \textbf{port}(}

{\itshape
 A,B : \textbf{in} bit\_vector (4 downto 1);}

{\itshape
 D,C : \textbf{out} bit\_vector(4 downto 1));}

{\itshape
\textbf{end entity }cain;}

{\itshape\color[rgb]{0.7529412,0.7529412,0.7529412}
{}-{}- Declaración de la arquitectura}

{\itshape
\textbf{architecture cain of }cain \textbf{is} }

{\bfseries\itshape
begin}

{\itshape
 test: \textbf{process} (A) }

{\itshape
 \textbf{variable} hh : boolean;}

{\itshape
 \textbf{variable} ss, tt : bit\_vector(4 \textbf{downto} 1);}

{\itshape
 \textbf{begin}}

{\itshape
 \textbf{divisor}(A, B, ss, tt,hh);}

{\itshape
 D {\textless}= ss;}

{\itshape
 C {\textless}= tt;}

{\itshape
 \textbf{end process }test;}

{\itshape
\textbf{end architecture }cain;}

{\centering 
\includegraphics[width=14.988cm,height=2.388cm]{FSM-img33.png} \par}

{\centering
En la Figura 33. Se muestra la simulación del divisor.
\par}

{\bfseries
EJEMPLO 4: Cronómetro digital}

{
Se desea diseñar un sistema digital que sea capaz de medir segundos y
décimas de segundo utilizando una fuente de reloj externa de FMHZ MHz y
dos displays de 7 segmentos para la visualización. El diagrama de
bloques del sistema aparece en la Figura 34.}

{\centering 
\includegraphics[width=8.518cm,height=3.704cm]{FSM-img34.png} \par}

{\centering
Figura 34. Diagrama de bloques del Cronómetro Digital.
\par}

{
\textbf{Divisor de frecuencia Programable (DIVISOR ):} Como se habrán
dado cuenta el divisor de frecuencia programable no tiene una entrada
fija, esta entrada depende de la disponibilidad del sistema, por lo que
en este caso es un \textit{genérico}. El código en VHDL del contador es
el siguiente:}

{\itshape
Library IEEE;}

{\itshape
use  IEEE.STD\_LOGIC\_1164.all;}

{\itshape
use  IEEE.STD\_LOGIC\_ARITH.all;}

{\itshape
use  IEEE.STD\_LOGIC\_UNSIGNED.all;}

{\itshape
\textbf{Entity} clk\_div \textbf{Is}}

{\itshape
\foreignlanguage{english}{
}\foreignlanguage{spanish}{\textbf{GENERIC}}\foreignlanguage{spanish}{(
FMHZ:
}\foreignlanguage{spanish}{\textbf{Natural}}\foreignlanguage{spanish}{
:= 8 );  {}-{}- FMHZ genérico 8MHz por defecto}}

{\itshape
 \textbf{PORT}(}

{\itshape
 clock\_FMHZ  : \textbf{IN}  \textbf{STD\_LOGIC};  {}-{}- Señal de reloj
externa.}

{\itshape
 Reset  : \textbf{IN  Std\_Logic};  {}-{}- Reset del Módulo}

{\itshape
 clock\_1Hz  : \textbf{OUT  STD\_LOGIC});  {}-{}- Salida a 1Hz.}

{\itshape
\textbf{end} clk\_div;}

{\itshape
\textbf{Architecture} RT \textbf{of} clk\_div \textbf{is}}

{\itshape
\ \   \textbf{Signal}  count\_1Mhz  : \textbf{Std\_Logic\_Vector}(4
\textbf{DOWNTO} 0);}

{\itshape
 \textbf{Signal}  Clock\_1MHz : \textbf{Std\_Logic};}

{\itshape
 \textbf{Signal}  Count\_1Hz  : \textbf{Integer} \textbf{Range} 0
\textbf{to} 1000000;}

{\bfseries\itshape
Begin}

{\itshape
 \textbf{Process }}

{\itshape
 \textbf{Begin}}

{\itshape
{}-{}- Divisor por FMHZ}

{\itshape
 \textbf{wait} \textbf{until}
clock\_FMHZ\textbf{{\textquotesingle}event} \textbf{and} clock\_FMHZ =
{\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{if} Reset = {\textquotesingle}1{\textquotesingle}
\textbf{then}}

{\itshape
 \textbf{if} count\_1Mhz {\textless} ( FMHZ - 1 ) \textbf{then}}

{\itshape
 count\_1Mhz {\textless}= count\_1Mhz + 1;}

{\itshape
 \textbf{else}}

{\itshape
 count\_1Mhz {\textless}= {\textquotedbl}00000{\textquotedbl};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{if} count\_1Mhz {\textless} FMHZ/2 \textbf{then}}

{\itshape
 clock\_1MHz {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{else}}

{\itshape
 clock\_1MHz {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{else}}

{\itshape
 Count\_1Mhz {\textless}= {\textquotedbl}00000{\textquotedbl};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{Process};\ \ }

{\itshape
{}-{}- Divisor por 1000000}

{\itshape
 \textbf{Process} ( clock\_1Mhz, Reset )}

{\itshape
 \textbf{Begin}}

{\itshape
 \textbf{if} Reset = {\textquotesingle}0{\textquotesingle}
\textbf{then}}

{\itshape
 Count\_1Hz {\textless}= 0;}

{\itshape
 \textbf{else }}

{\itshape
 \textbf{if} clock\_1Mhz\textbf{{\textquotesingle}event} \textbf{and}
clock\_1Mhz = {\textquotesingle}1{\textquotesingle} \textbf{then}}

{\itshape
 \textbf{if} count\_1Hz {\textless} 1000000 \textbf{then}}

{\itshape
 count\_1Hz {\textless}= count\_1Hz + 1;}

{\itshape
 \textbf{else}}

{\itshape
 count\_1Hz {\textless}= 0;}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{if} count\_1Hz {\textless} 5000000 \textbf{then}}

{\itshape
 clock\_1Hz {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{else}}

{\itshape
 clock\_1Hz {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{end} \textbf{if};\ \ }

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{Process};\ \ }

{\itshape
\textbf{end} \textbf{RT};}

{
 Como puede observarse existen dos procesos dentro de la arquitectura el
primero es un divisor de frecuencia por  FMHZ el cual proporciona una
señal de reloj de 1 MHz, esto se hizo con el fin de proporcionarle
adaptabilidad al sistema a cualquier señal de reloj mayor a 1 MHz. El
segundo proceso es un divisor de frecuencia por 1 millón, la salida de
este proceso es una señal con frecuencia de 1 Hz.}

{
\textbf{CONTADOR:} Una vez obtenida la frecuencia de 1 Hz se procede a
realizar el contador. El código VHDL del contador se muestra a
continuación:}

{\itshape
\textbf{Library} Ieee;}

{\itshape
\textbf{Use} Ieee.Std\_Logic\_1164.all;}

{\itshape
\textbf{Use} Ieee.Std\_Logic\_Arith.all;}

{\itshape
\textbf{Use} Ieee.Std\_Logic\_unsigned.all;}

{\itshape
\textbf{Entity} Contador \textbf{is}}

{\itshape
 \textbf{Port}(}

{\itshape
 Clock  : \textbf{In}  Std\_Logic;}

{\itshape
 Reset  : \textbf{In}  Std\_Logic;}

{\itshape
 Unidades : \textbf{Buffer}  Std\_Logic\_Vector( 3 \textbf{Downto} 0 );}

{\itshape
 Decenas  : \textbf{Buffer}  Std\_logic\_Vector( 3 \textbf{Downto} 0 )}

{\itshape
 );}

{\itshape
\textbf{end} \textbf{Entity} Contador;}

{\itshape
\textbf{Architecture} RT \textbf{of} Contador \textbf{is}}

{\bfseries\itshape
Begin}

{\itshape
 \textbf{Process} (Clock, Reset)}

{\itshape
 \textbf{Begin}}

{\itshape
 \textbf{If} Reset = {\textquotesingle}0{\textquotesingle}
\textbf{then}}

{\itshape
 Unidades {\textless}= {\textquotedbl}0000{\textquotedbl};}

{\itshape
 Decenas  {\textless}= {\textquotedbl}0000{\textquotedbl};}

{\itshape
 \textbf{else}}

{\itshape
 \textbf{if} Clock\textbf{{\textquotesingle}event} \textbf{and} Clock =
{\textquotesingle}1{\textquotesingle} \textbf{then}}

{\itshape
\foreignlanguage{english}{
}\foreignlanguage{spanish}{\textbf{If}}\foreignlanguage{spanish}{
Unidades {\textless} {\textquotedbl}1001{\textquotedbl}
}\foreignlanguage{spanish}{\textbf{then}}}

{\itshape
 Unidades  {\textless}= Unidades + {\textquotedbl}0001{\textquotedbl};}

{\itshape
\foreignlanguage{spanish}{ }\foreignlanguage{english}{\textbf{else}}}

{\itshape
 Unidades {\textless}= {\textquotedbl}0000{\textquotedbl};}

{\itshape
 \textbf{if} Decenas {\textless} {\textquotedbl}1001{\textquotedbl}
\textbf{then}}

{\itshape
\foreignlanguage{english}{ }\foreignlanguage{spanish}{Decenas 
{\textless}= Decenas + {\textquotedbl}0001{\textquotedbl};}}

{\itshape
 \textbf{else}}

{\itshape
 Unidades {\textless}= {\textquotedbl}0000{\textquotedbl};}

{\itshape
\foreignlanguage{spanish}{ }\foreignlanguage{english}{Decenas 
{\textless}= {\textquotedbl}0000{\textquotedbl};}}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{End} \textbf{Process};}

{\itshape
\textbf{End} \textbf{Architecture} RT;}

{
\textbf{VISUALIZACION: }Para este ejemplo utilizaremos visualización
dinámica; el  módulo debe contar con una salida que sea capaz de
manejar un display de 7 segmentos y señales para la selección del
display. A continuación se muestra el diagrama de bloques y las
entradas y salidas del visualizador:}

{\centering 
\includegraphics[width=7.565cm,height=3.545cm]{FSM-img35.png} \par}

{\centering
Figura. 35 Diagrama de Bloques de la visualización.
\par}

{
La visualización dinámica funciona de esta forma: Los segmentos comunes
de los Displays están unidos entre sí de tal forma que el valor a
desplegar se pueda mostrar en cualquiera de los dos. Las entradas de
selección indican en cual de ellos se mostrará el valor enviado. Por
ejemplo para mostrar el número 69 se deben seguir los siguientes
pasos:}

{
Seleccionar el Display de la Derecha haciendo Sel[0] = 1 y Sel[1] = 0.}

{
Colocar la información correspondiente al Número 9 en BCD\_Out:}

\begin{enumerate}
\item {
Esperar TD milisegundos.}
\item {
Hacer BCD\_Out = 0, ( Esto para evitar que por un breve instante de
tiempo se muestre la información del otro display )}
\item {
Seleccionar el Display de la izquierda haciendo Sel[0] = 0 y Sel[1] =
1.}
\item {
Colocar la información correspondiente al Número 6 en BCD\_Out:}
\item {
Esperar TD milisegundos.}
\item {
Repetir el paso 1.}
\end{enumerate}
{
Los pasos que debe realizar el módulo de visualización son lo mismos del
ejemplo, pero la información que muestran en cada momento son los
valores de las entradas {\textquotedblleft}Unidades{\textquotedblright}
y {\textquotedblleft}Decenas{\textquotedblright}.}

{
Debido a que necesitamos una señal de reloj con un período de TD ms,
podemos incluir un divisor de frecuencia dentro de la visualización,
pero esto implica gastar más compuertas lógicas; la solución más óptima
es incluir el divisor de frecuencia en el módulo divisor. Con lo que el
código del divisor queda de la siguiente forma:}

{\itshape
\textbf{Library} IEEE;}

{\itshape
\textbf{use}  IEEE.STD\_LOGIC\_1164.all;}

{\itshape
\textbf{use}  IEEE.STD\_LOGIC\_ARITH.all;}

{\itshape
\textbf{use}  IEEE.STD\_LOGIC\_UNSIGNED.all;}

{\itshape
\textbf{Entity} clk\_div2 \textbf{Is}}

{\itshape
\foreignlanguage{english}{
}\foreignlanguage{spanish}{\textbf{GENERIC}}\foreignlanguage{spanish}{(
}}

{\itshape
 FMHZ: Natural := 8;}

{\itshape
 TD  : Natural := 20 );  {}-{}- FMHZ genérico 8MHz por defecto}

{\itshape
\foreignlanguage{spanish}{
}\foreignlanguage{english}{\textbf{PORT}}\foreignlanguage{english}{(}}

{\itshape
 clock\_FMHZ  : \textbf{In}  Std\_Logic;  {}-{}- Señal de reloj
externa.}

{\itshape
 Reset  : \textbf{In}  Std\_Logic;  {}-{}- Reset del Módulo}

{\itshape
 clock\_1Hz  : \textbf{Out}  Std\_Logic;}

{\itshape
 Clock\_TD  : \textbf{Out}  Std\_Logic ); -{}- Salida a 1Hz.}

{\itshape
\textbf{END} clk\_div2;}

{\itshape
\textbf{Architecture} RT \textbf{of} clk\_div2 \textbf{is}}

{\itshape
 \textbf{Signal}  count\_1Mhz : STD\_LOGIC\_VECTOR(4 DOWNTO 0);}

{\itshape
 \textbf{Signal}  Clock\_1MHz : Std\_Logic;}

{\itshape
 \textbf{Signal}  Clock\_1ms  : Std\_Logic;}

{\itshape
 \textbf{Signal}  Count\_1Hz  : Integer Range 0 to 100;}

{\itshape
 \textbf{Signal}  Count\_1ms  : Integer Range 0 to 100;}

{\itshape
 \textbf{Signal}  Count\_TDms : Integer Range 0 to 100;}

{\bfseries\itshape
Begin}

{\itshape
 \textbf{Process}}

{\itshape
 \textbf{Begin}}

{\itshape
{}-{}- Divisor por FMHZ}

{\itshape
 \textbf{wait} \textbf{until}
clock\_FMHZ\textbf{{\textquotesingle}event} \textbf{and} clock\_FMHZ =
{\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{if} Reset = {\textquotesingle}1{\textquotesingle}
\textbf{then}}

{\itshape
 \textbf{if} count\_1Mhz {\textless} ( FMHZ - 1 ) \textbf{then}}

{\itshape
 count\_1Mhz {\textless}= count\_1Mhz + 1;}

{\itshape
 \textbf{else}}

{\itshape
 count\_1Mhz {\textless}= {\textquotedbl}00000{\textquotedbl};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{if} count\_1Mhz {\textless} FMHZ/2 \textbf{then}}

{\itshape
 clock\_1MHz {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{else}}

{\itshape
 clock\_1MHz {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{else}}

{\itshape
 Count\_1Mhz {\textless}= {\textquotedbl}00000{\textquotedbl};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{Process};\ \ }

{\itshape
{}-{}- Divisor por 1000}

{\itshape
 \textbf{Process} ( clock\_1Mhz, Reset )}

{\itshape
 \textbf{Begin}}

{\itshape
 \textbf{if} Reset = {\textquotesingle}0{\textquotesingle}
\textbf{then}}

{\itshape
 Count\_1ms {\textless}= 0;}

{\itshape
 \textbf{else }}

{\itshape
 \textbf{if} clock\_1Mhz\textbf{{\textquotesingle}event} \textbf{and}
clock\_1Mhz = {\textquotesingle}1{\textquotesingle} \textbf{then}}

{\itshape
 \textbf{if} count\_1ms {\textless} 1000 \textbf{then}}

{\itshape
 count\_1ms {\textless}= count\_1ms + 1;}

{\itshape
 \textbf{else}}

{\itshape
 count\_1ms {\textless}= 0;}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{if} count\_1ms {\textless} 500 \textbf{then}}

{\itshape
 clock\_1ms {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{else}}

{\itshape
 clock\_1ms {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{end} \textbf{if};\ \ }

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{End} \textbf{Process};}

{\itshape
{}-{}- Divisor por 1000}

{\itshape
 \textbf{Process} ( clock\_1ms, Reset )}

{\itshape
 \textbf{Begin}}

{\itshape
 \textbf{if} Reset = {\textquotesingle}0{\textquotesingle}
\textbf{then}}

{\itshape
 Count\_1Hz {\textless}= 0;}

{\itshape
 \textbf{else }}

{\itshape
 \textbf{if} clock\_1ms\textbf{{\textquotesingle}event} \textbf{and}
clock\_1ms = {\textquotesingle}1{\textquotesingle} \textbf{then}}

{\itshape
 \textbf{if} count\_1Hz {\textless} 1000 \textbf{then}}

{\itshape
 count\_1Hz {\textless}= count\_1Hz + 1;}

{\itshape
 \textbf{else}}

{\itshape
 count\_1Hz {\textless}= 0;}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{if} count\_1Hz {\textless} 500 \textbf{then}}

{\itshape
 clock\_1Hz {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{else}}

{\itshape
 clock\_1Hz {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{end} \textbf{if};\ \ }

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{End} \textbf{Process};}

{\itshape
{}-{}- Base De tiempo para la visualización dinámica}

{\itshape
\foreignlanguage{spanish}{
}\foreignlanguage{english}{\textbf{Process}}\foreignlanguage{english}{
( clock\_1ms, Reset )}}

{\bfseries\itshape
 Begin}

{\itshape
 \textbf{if} Reset = {\textquotesingle}0{\textquotesingle}
\textbf{then}}

{\itshape
 Count\_TDms {\textless}= 0;}

{\itshape
 \textbf{else }}

{\itshape
 \textbf{if} clock\_1ms\textbf{{\textquotesingle}event} \textbf{and}
clock\_1ms = {\textquotesingle}1{\textquotesingle} \textbf{then}}

{\itshape
 \textbf{if} count\_TDms {\textless} TD \textbf{then}}

{\itshape
 count\_TDms {\textless}= count\_TDms + 1;}

{\itshape
 \textbf{else}}

{\itshape
 count\_TDms {\textless}= 0;}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{if} count\_TDms {\textless} TD/2 \textbf{then}}

{\itshape
 clock\_TD {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{else}}

{\itshape
 clock\_TD {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{end} \textbf{if};\ \ }

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{Process};\ \ }

{\itshape
\textbf{END} RT;}

{
En esta versión del divisor de frecuencia se obtiene una señal con una
frecuencia de 1KHz al realizar la división de la señal de 1MHz entre
1000. Esta señal se toma como base para obtener las señales de Base de
tiempo para la visualización dinámica (Dividiendo por TD) y base de
tiempo de 1 Hz.}

{
Finalmente el código del módulo de visualización se muestra a
continuación:}

{\itshape
\textbf{Library} Ieee;}

{\itshape
\textbf{Use }Ieee.Std\_Logic\_1164.all;}

{\itshape
\textbf{Use }Ieee.Std\_Logic\_Arith.all;}

{\itshape
\textbf{Use} Ieee.Std\_Logic\_unsigned.all;}

{\itshape
\textbf{Entity }Show \textbf{is}}

{\itshape
 \textbf{Port}(}

{\itshape
 Unidades  : \textbf{In  }Std\_Logic\_vector( 3 \textbf{downto }0 );}

{\itshape
 Decenas  : \textbf{In  }Std\_Logic\_vector( 3 \textbf{downto} 0 );}

{\itshape
 Clk\_TDms : \textbf{In  }Std\_Logic;}

{\itshape
 Sel  : \textbf{Out }Std\_Logic\_vector( 1 \textbf{downto }0 );}

{\itshape
 BCD\_Out  : \textbf{Out }Std\_Logic\_Vector( 6 \textbf{downto }0 ) }

{\itshape
{}-{}-  BCD\_Out[7..0] = a, b, c, d, e, f, g}

{\itshape
 );}

{\itshape
\textbf{End Entity }Show;}

{\itshape
\textbf{Architecture }RT \textbf{of }Show \textbf{is}}

{\itshape
 \textbf{Signal }Binary : Std\_logic\_Vector ( 3 \textbf{downto }0 );}

{\itshape
 \textbf{Type  }Estados is ( Show\_Decenas, Show\_Unidades );}

{\itshape
 \textbf{Signal }State : Estados;}

{\bfseries\itshape
Begin}

{\itshape
 \textbf{Process}( Binary )}

{\itshape
 \textbf{Begin}}

{\itshape
 \textbf{Case} Binary \textbf{is}}

{\itshape
 \textbf{When }{\textquotedbl}0000{\textquotedbl} ={\textgreater}}

{\itshape
 BCD\_Out {\textless}= {\textquotedbl}0111111{\textquotedbl};}

{\itshape
 \textbf{When }{\textquotedbl}0001{\textquotedbl} ={\textgreater}}

{\itshape
 BCD\_Out {\textless}= {\textquotedbl}0100001{\textquotedbl};}

{\itshape
 \textbf{When }{\textquotedbl}0010{\textquotedbl} ={\textgreater}}

{\itshape
 BCD\_Out {\textless}= {\textquotedbl}1110110{\textquotedbl};}

{\itshape
 \textbf{When }{\textquotedbl}0011{\textquotedbl} ={\textgreater}}

{\itshape
 BCD\_Out {\textless}= {\textquotedbl}1110011{\textquotedbl};}

{\itshape
 \textbf{When }{\textquotedbl}0100{\textquotedbl} ={\textgreater}}

{\itshape
 BCD\_Out {\textless}= {\textquotedbl}1101001{\textquotedbl};}

{\itshape
 \textbf{When }{\textquotedbl}0101{\textquotedbl} ={\textgreater}}

{\itshape
 BCD\_Out {\textless}= {\textquotedbl}1011011{\textquotedbl};}

{\itshape
 \textbf{When }{\textquotedbl}0110{\textquotedbl} ={\textgreater}}

{\itshape
 BCD\_Out {\textless}= {\textquotedbl}1011111{\textquotedbl};}

{\itshape
 \textbf{When }{\textquotedbl}0111{\textquotedbl} ={\textgreater}}

{\itshape
 BCD\_Out {\textless}= {\textquotedbl}0110001{\textquotedbl};}

{\itshape
 \textbf{When }{\textquotedbl}1000{\textquotedbl} ={\textgreater}}

{\itshape
 BCD\_Out {\textless}= {\textquotedbl}1111111{\textquotedbl};}

{\itshape
 \textbf{When }{\textquotedbl}1001{\textquotedbl} ={\textgreater}}

{\itshape
 BCD\_Out {\textless}= {\textquotedbl}1111011{\textquotedbl};}

{\itshape
 \textbf{When others }={\textgreater}}

{\itshape
 BCD\_Out {\textless}= {\textquotedbl}0000000{\textquotedbl};}

{\itshape
 \textbf{end Case};}

{\itshape
 \textbf{End Process};}

{\itshape
 \textbf{Process}(Clk\_TDms)}

{\itshape
 \textbf{Begin}}

{\itshape
 \textbf{If }(Clk\_TDms\textbf{{\textquotesingle}event} \textbf{and
}Clk\_TDms = {\textquotesingle}1{\textquotesingle}) \textbf{Then}}

{\itshape
 \textbf{Case }State \textbf{is}}

{\itshape
 \textbf{When }Show\_Decenas ={\textgreater}}

{\itshape
 Binary {\textless}= Decenas;}

{\itshape
 State  {\textless}= Show\_Unidades;}

{\itshape
 Sel  {\textless}= {\textquotedbl}01{\textquotedbl};}

{\itshape
 \textbf{When }Show\_Unidades ={\textgreater}}

{\itshape
 Binary {\textless}= Unidades;}

{\itshape
 State  {\textless}= Show\_Decenas;}

{\itshape
 Sel  {\textless}= {\textquotedbl}10{\textquotedbl};}

{\itshape
 \textbf{End Case};}

{\itshape
 \textbf{End If};}

{\itshape
 \textbf{End Process};}

{\itshape
\textbf{End Architecture }RT;}

{
Una vez realizados los diferentes módulos del sistema se debe realizar
una descripción estructural para realizar la interconexión entre
ellos:}

{\itshape
\textbf{Library} IEEE;}

{\itshape
\textbf{USE }IEEE.STD\_LOGIC\_1164.all;}

{\itshape
\textbf{USE }IEEE.STD\_LOGIC\_ARITH.all;}

{\itshape
\textbf{USE} IEEE.STD\_LOGIC\_UNSIGNED.all;}

{\itshape
\textbf{Entity }Cronometro \textbf{is}}

{\itshape
\textbf{Port}(}

{\itshape
\ \ Reset,clk\ \ : \textbf{IN} STD\_LOGIC;}

{\itshape
\ \ Sel\ \   : \textbf{Out} STD\_LOGIC\_VECTOR( 1 \textbf{downto} 0 );}

{\itshape
\ \ Seven\_Seg  : \textbf{Out} STD\_LOGIC\_VECTOR( 6 \textbf{downto} 0 )
);}

{\itshape
\textbf{End Entity }Cronometro;}

{\itshape
\textbf{Architecture }Estructural \textbf{Of }Cronometro \textbf{is}}

{\itshape
\textbf{Component }Show}

{\itshape
 \textbf{Port}(}

{\itshape
 Unidades  : \textbf{In  }Std\_Logic\_vector( 3 \textbf{downto }0 );}

{\itshape
 Decenas  : \textbf{In  }Std\_Logic\_vector( 3 \textbf{downto }0 );}

{\itshape
 Clk\_TDms  : \textbf{In  }Std\_Logic;}

{\itshape
 Sel  : \textbf{Out }Std\_Logic\_vector( 1 \textbf{downto }0 );}

{\itshape
 BCD\_Out  : \textbf{Out }Std\_Logic\_Vector( 6 \textbf{downto }0 ) );}

{\itshape
\textbf{End Component }Show;}

{\itshape
\textbf{Component }Contador}

{\itshape
 \textbf{Port}(}

{\itshape
\foreignlanguage{spanish}{ }\foreignlanguage{english}{Clock  :
}\foreignlanguage{english}{\textbf{In 
}}\foreignlanguage{english}{Std\_Logic;}}

{\itshape
 Reset  : \textbf{In  }Std\_Logic;}

{\itshape
 Unidades : \textbf{Buffer  }Std\_Logic\_Vector( 3 \textbf{Downto }0 );}

{\itshape
 Decenas  : \textbf{Buffer  }Std\_logic\_Vector( 3 \textbf{Downto }0 )}

{\itshape
 );}

{\itshape
\textbf{end Component }Contador;}

{\itshape
\textbf{Component }clk\_div2}

{\itshape
 \textbf{GENERIC}( }

{\itshape
 FMHZ: Natural := 8;}

{\itshape
 TD  : Natural := 20 );}

{\itshape
 \textbf{PORT}(}

{\itshape
 clock\_FMHZ  : \textbf{In  }Std\_Logic;}

{\itshape
 Reset  : \textbf{In  }Std\_Logic;}

{\itshape
 clock\_1Hz  : \textbf{Out  } Std\_Logic;}

{\itshape
 Clock\_TD  : \textbf{Out } Std\_Logic );}

{\itshape
\textbf{END Component }clk\_div2;}

{\itshape
\textbf{Signal }CLK1Hz, CLKTD  : Std\_logic;}

{\itshape
\textbf{Signal }Unidades, Decenas : Std\_logic\_vector( 3 downto 0 );}

{\bfseries\itshape
Begin}

{\itshape
 A1: clk\_div2}

{\itshape
 \textbf{Generic map}(8, 20)}

{\itshape
 \textbf{Port Map}( clk, Reset, CLK1Hz, CLKTD );}

{\itshape
\foreignlanguage{english}{ }\foreignlanguage{spanish}{A2: Contador}}

{\itshape
 \textbf{port map}( CLK1Hz, Reset, Unidades, Decenas );}

{\itshape
\foreignlanguage{spanish}{ }\foreignlanguage{english}{A3: Show}}

{\itshape
 \textbf{port map}( Unidades, Decenas, CLKTD, Sel, Seven\_Seg );}

{\itshape
\textbf{End Architecture }Estructural;}

{
El código correspondiente al \textit{testbench} del cronometro es:}

{\itshape
\textbf{LIBRARY} ieee;}

{\itshape
\textbf{USE} ieee.std\_logic\_1164.ALL;}

{\itshape
\textbf{USE} ieee.numeric\_std.ALL;}

{\itshape
\textbf{ENTITY} testbench \textbf{IS}}

{\itshape
\textbf{END} testbench;}

{\itshape
\textbf{ARCHITECTURE} behavior \textbf{OF} testbench \textbf{IS} }

{\itshape
{}-{}- Component Declaration}

{\itshape
\ \ \textbf{Component} cronometro}

{\itshape
\ \ \textbf{PORT}(}

{\itshape
\ \ \ \ Reset, clk  : \textbf{IN}  std\_logic;}

{\itshape
\ \ \ \ Sel  : \textbf{OUT} std\_logic\_vector(1 \textbf{downto} 0);  }

{\itshape
\ \ \ \ Seven\_Seg  : \textbf{OUT} std\_logic\_vector(6 \textbf{downto}
0)}

{\itshape
\ \ \ \ );}

{\itshape
\ \ \textbf{END} \textbf{COMPONENT};}

{\itshape
\ \ \textbf{SIGNAL}  Reset  : std\_logic;}

{\itshape
\ \ \textbf{SIGNAL}  clk  : std\_logic;}

{\itshape
\ \ \textbf{SIGNAL}  Sel  : std\_logic\_vector(1 \textbf{downto} 0);}

{\itshape
\ \ \textbf{SIGNAL}  Seven\_Seg  : std\_logic\_vector(6 \textbf{downto}
0);}

{\itshape
 \textbf{constant} ncycles  : \textbf{integer} := 40000000;}

{\itshape
 \textbf{constant} halfperiod : time := 5 ns;\ \ }

{\bfseries\itshape
BEGIN}

{\itshape
{}-{}- Component Instantiation}

{\itshape
\ \ uut: cronometro \textbf{PORT} \textbf{MAP}(}

{\itshape
\ \ \ \ Reset  ={\textgreater} Reset,}

{\itshape
\ \ \ \ clk  ={\textgreater} clk,}

{\itshape
\ \ \ \ Sel  ={\textgreater} Sel,}

{\itshape
\ \ \ \ Seven\_Seg ={\textgreater} Seven\_Seg}

{\itshape
\ \ );}

{\itshape
 {}-{}- Generacion del Reloj}

{\itshape
 Clock\_Source: \textbf{process}}

{\itshape
 \textbf{begin}}

{\itshape
 \textbf{for} i \textbf{in} 0 \textbf{to} ncycles \textbf{loop}  {}-{}-
Genera ncyclos de periodo 10 ns}

{\itshape
 clk {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{wait} \textbf{for} halfperiod;}

{\itshape
 clk {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{wait} \textbf{for} halfperiod;}

{\itshape
 \textbf{end} \textbf{loop};}

{\itshape
 \textbf{wait};}

{\itshape
 \textbf{end} \textbf{process} Clock\_Source;}

{\itshape
 tb : \textbf{PROCESS}}

{\itshape
 \textbf{BEGIN}}

{\itshape
 Reset {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{wait} \textbf{until} clk{\textquotesingle}\textbf{event and}
clk = {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{wait} \textbf{until} clk{\textquotesingle}\textbf{event}
\textbf{and} clk = {\textquotesingle}1{\textquotesingle};}

{\itshape
 Reset {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{wait}; }

{\itshape
 \textbf{END} \textbf{PROCESS};}

{\itshape
\textbf{END};}

{\bfseries
EJEMPLO 5: Contador UP/DOWN}

{
En este ejemplo se diseñará un contador ascendente descendente de 0 a
99. El sistema tendrá como entradas de control tres pulsadores: Reset,
Aumento y dismunición. El diagrama de bloques del sistema se muestra en
la siguiente figura:}

{\centering 
\includegraphics[width=7.989cm,height=3.413cm]{FSM-img36.png} \par}

{\centering
Figura 36. Interfaz del Contador Up/Down
\par}

{
El diagrama de bloques de este sistema es el siguiente:}

{\centering 
\includegraphics[width=7.116cm,height=5.239cm]{FSM-img37.png} \par}

{\centering
Figura 37. Diagrama de Bloques del contador Up/Down
\par}

{
Como se puede ver el circuito de visualización es idéntico al del
ejemplo anterior. Debido a que utilizaremos elementos mecánicos (
pulsadores ) debemos diseñar un circuito que elimine el ruido eléctrico
introducido por estos.}

{
\textbf{ANTIREBOTE}: Este módulo se encarga de eliminar el ruido
eléctrico introducido por los pulsadores, previniendo de esta forma
conteos erróneos. Además incorpora un circuito que genera un pulso de
duración de un período de la señal de reloj para evitar que cuando se
deja oprimido el Pulsador se genere más de un conteo.}

{\centering 
\includegraphics[width=11.829cm,height=11.945cm]{FSM-img38.png} \par}

{\centering
Figura 38. Diagrama de estados del módulo antirrebote
\par}

{
El código en VHDL de este módulo es el siguiente:}

{\itshape
\textbf{library} IEEE;}

{\itshape
\textbf{use}  ieee.std\_logic\_1164.all;}

{\itshape
\textbf{use}  ieee.std\_logic\_arith.all;}

{\itshape
\textbf{Entity} debounce \textbf{Is}}

{\itshape
 \textbf{Port}(}

{\itshape
 Push\_Button, Clk : \textbf{In}  Std\_Logic;}

{\itshape
 Reset  : \textbf{In}  Std\_Logic;}

{\itshape
 PB\_D\ \   : \textbf{Out} Std\_Logic);}

{\itshape
\textbf{End} debounce;}

{\itshape
\textbf{Architecture} RT \textbf{OF} debounce \textbf{Is}}

{\itshape
\textbf{Type} estados \textbf{Is} ( Rise, fall, S0, S1 );}

{\itshape
\textbf{Signal} state\ \ : estados;}

{\itshape
\textbf{Signal} SHIFT\_PB : Std\_Logic\_Vector( 3 downto 0 );}

{\itshape
\textbf{Signal} PB\_DEBOUNCED  : Std\_Logic;}

{\bfseries\itshape
Begin}

{\itshape
 \textbf{Process  }{}-{}- Este proceso elimina el ruido eléctrico
generado por los pulsadores}

{\itshape
\foreignlanguage{spanish}{ }\foreignlanguage{english}{\textbf{begin}}}

{\itshape
 \textbf{wait} \textbf{until} ( Clk\textbf{{\textquotesingle}EVENT} )
\textbf{AND} ( Clk = {\textquotesingle}1{\textquotesingle} );}

{\itshape
 SHIFT\_PB( 2 \textbf{Downto} 0 ) {\textless}= SHIFT\_PB( 3
\textbf{Downto} 1 );}

{\itshape
 SHIFT\_PB(3) {\textless}= \textbf{NOT} Push\_Button;}

{\itshape
 \textbf{If} SHIFT\_PB( 3 \textbf{Downto} 0
)={\textquotedbl}0000{\textquotedbl} \textbf{THEN}}

{\itshape
 PB\_DEBOUNCED {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{Else}}

{\itshape
 PB\_DEBOUNCED {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{End} \textbf{if};}

{\itshape
 \textbf{end} \textbf{process};}

{\itshape
 \textbf{Process} ( Clk, PB\_DEBOUNCED, Reset )}

{\itshape
 \textbf{Begin}}

{\itshape
 \textbf{If} Reset = {\textquotesingle}1{\textquotesingle}
\textbf{then}}

{\itshape
 state {\textless}= Rise;}

{\itshape
 PB\_D {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{else}}

{\itshape
 \textbf{If} Clk\textbf{{\textquotesingle}event} and Clk =
{\textquotesingle}0{\textquotesingle} \textbf{then}}

{\itshape
 \textbf{Case} state \textbf{is}}

{\itshape
 \textbf{When} Rise ={\textgreater}}

{\itshape
 PB\_D {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{If} PB\_DEBOUNCED = {\textquotesingle}0{\textquotesingle}
\textbf{then} }

{\itshape
 State {\textless}= Rise;}

{\itshape
 \textbf{else}}

{\itshape
 State {\textless}= S0;}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{When} S0 ={\textgreater}}

{\itshape
 PB\_D {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 State {\textless}= S1;  }

{\itshape
 \textbf{When} S1 ={\textgreater}}

{\itshape
 PB\_D {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 State {\textless}= Fall;  }

{\itshape
 \textbf{When} Fall ={\textgreater}}

{\itshape
 PB\_D {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{If} PB\_DEBOUNCED = {\textquotesingle}1{\textquotesingle}
\textbf{then} }

{\itshape
 State {\textless}= Fall;}

{\itshape
 \textbf{else}}

{\itshape
 State {\textless}= Rise;}

{\itshape
 \textbf{end} \textbf{if};  }

{\itshape
 \textbf{When} Others ={\textgreater}}

{\itshape
 State {\textless}= Rise;}

{\itshape
 \textbf{End} \textbf{Case};}

{\itshape
 \textbf{End} \textbf{If};}

{\itshape
 \textbf{End} \textbf{If};  }

{\itshape
 \textbf{End} \textbf{Process};}

{\itshape
\textbf{end} \textbf{architecture} RT;}

{\centering 
\includegraphics[width=7.618cm,height=3.307cm]{FSM-img39.png} \par}

{\centering
Figura 39. Interfaz del módulo contador.
\par}

{
\textbf{CONTADOR}: Este módulo está encargado de aumentar o disminuir el
valor de sus salidas de acuerdo a la entrada que este actuando. La
interfaz de este módulo se muestra en la figura anterior y el código en
VHDL se muestra a continuación.}

{\itshape
\textbf{Library} Ieee;}

{\itshape
\textbf{Use} Ieee.Std\_Logic\_1164.all;}

{\itshape
\textbf{Use} Ieee.Std\_Logic\_Arith.all;}

{\itshape
\textbf{Use} Ieee.Std\_Logic\_unsigned.all;}

{\itshape
\textbf{Entity} Contador \textbf{is}}

{\itshape
 \textbf{Port}(}

{\itshape
 Up  : \textbf{In}  Std\_Logic;}

{\itshape
 Down  : \textbf{In}  Std\_Logic;}

{\itshape
 Reset  : \textbf{In}  Std\_logic;}

{\itshape
 Clk  : \textbf{In}  Std\_logic;}

{\itshape
 Unidades : \textbf{Buffer}  Std\_Logic\_Vector( 3 \textbf{Downto} 0 );}

{\itshape
 Decenas  : \textbf{Buffer}  Std\_logic\_Vector( 3 \textbf{Downto} 0 )}

{\itshape
 );}

{\itshape
\textbf{end} \textbf{Entity} Contador;}

{\itshape
\textbf{Architecture} RT \textbf{of} Contador \textbf{is}}

{\bfseries\itshape
Begin}

{\itshape
 \textbf{Process} ( Up, Down, Reset, Clk )}

{\itshape
 \textbf{Begin}}

{\itshape
 \textbf{If} Reset = {\textquotesingle}1{\textquotesingle}
\textbf{then}}

{\itshape
 Unidades {\textless}= {\textquotedbl}0000{\textquotedbl};}

{\itshape
 Decenas  {\textless}= {\textquotedbl}0000{\textquotedbl};}

{\itshape
 \textbf{else}}

{\itshape
 \textbf{If} Clk\textbf{{\textquotesingle}event} \textbf{and}
clk={\textquotesingle}1{\textquotesingle} \textbf{then}}

{\itshape
 \textbf{if} Up = {\textquotesingle}1{\textquotesingle} \textbf{and}
Down  = {\textquotesingle}0{\textquotesingle} \textbf{then}}

{\itshape
\foreignlanguage{english}{ }\textbf{If} Unidades {\textless}
{\textquotedbl}1001{\textquotedbl} \textbf{then}}

{\itshape
 Unidades  {\textless}= Unidades + {\textquotedbl}0001{\textquotedbl};}

{\itshape
 \foreignlanguage{english}{\textbf{else}}}

{\itshape
 Unidades {\textless}= {\textquotedbl}0000{\textquotedbl};}

{\itshape
 \textbf{if} Decenas {\textless} {\textquotedbl}1001{\textquotedbl}
\textbf{then}}

{\itshape
\foreignlanguage{english}{ }Decenas  {\textless}= Decenas +
{\textquotedbl}0001{\textquotedbl};}

{\itshape
 \textbf{else}}

{\itshape
 Unidades {\textless}= {\textquotedbl}0000{\textquotedbl};}

{\itshape
 \foreignlanguage{english}{Decenas  {\textless}=
{\textquotedbl}0000{\textquotedbl};}}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{elsif} Up = {\textquotesingle}0{\textquotesingle} \textbf{and}
Down = {\textquotesingle}1{\textquotesingle} \textbf{then}}

{\itshape
\foreignlanguage{english}{ }\textbf{If} Unidades {\textgreater}
{\textquotedbl}0000{\textquotedbl} \textbf{then}}

{\itshape
 Unidades  {\textless}= Unidades - {\textquotedbl}0001{\textquotedbl};}

{\itshape
 \foreignlanguage{english}{\textbf{else}}}

{\itshape
 Unidades {\textless}= {\textquotedbl}1001{\textquotedbl};}

{\itshape
 \textbf{if} Decenas {\textgreater} {\textquotedbl}0000{\textquotedbl}
\textbf{then}}

{\itshape
\foreignlanguage{english}{ }Decenas  {\textless}= Decenas -
{\textquotedbl}0001{\textquotedbl};}

{\itshape
 \textbf{else}}

{\itshape
 Unidades {\textless}= {\textquotedbl}1001{\textquotedbl};}

{\itshape
 \foreignlanguage{english}{Decenas  {\textless}=
{\textquotedbl}1001{\textquotedbl};}}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
\foreignlanguage{english}{ }\textbf{end} \textbf{if};}

{\itshape
 \textbf{else}}

{\itshape
 Unidades {\textless}= Unidades;}

{\itshape
 Decenas  {\textless}= Decenas;}

{\itshape
 \foreignlanguage{english}{\textbf{end}}\foreignlanguage{english}{
}\foreignlanguage{english}{\textbf{if}}\foreignlanguage{english}{;}}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{End} \textbf{Process};}

{\itshape
\textbf{End} \textbf{Architecture} RT;}

{
La descripción estructural del contador Up/Down es la siguiente:}

{\itshape
\textbf{library} IEEE;}

{\itshape
\textbf{use} IEEE.std\_logic\_1164.all;}

{\itshape
\textbf{entity} UDCounter \textbf{is}}

{\itshape
 \textbf{port} (}

{\itshape
 Up  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Down  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Clk  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Reset : \textbf{in}  STD\_LOGIC;}

{\itshape
 Sel  : \textbf{Buffer} STD\_LOGIC\_VECTOR (1 \textbf{downto} 0);}

{\itshape
 SEG  : \textbf{out}  STD\_LOGIC\_VECTOR (6 \textbf{downto} 0)}

{\itshape
 );}

{\itshape
\textbf{end} UDCounter;}

{\itshape
\textbf{architecture} UDCounter\_arch \textbf{of} UDCounter \textbf{is}}

{\itshape
\textbf{Component} Show}

{\itshape
 \textbf{Port}(}

{\itshape
 Unidades : In  Std\_Logic\_vector( 3 downto 0 );}

{\itshape
 Decenas  : In  Std\_Logic\_vector( 3 downto 0 );}

{\itshape
 Clk\_TDms : In  Std\_Logic;}

{\itshape
 Sel  : Buffer Std\_Logic\_vector( 1 downto 0 );}

{\itshape
 BCD\_Out  : Out  Std\_Logic\_Vector( 6 downto 0 ) );}

{\itshape
\textbf{End} \textbf{Component} Show;}

{\itshape
\textbf{Component} Contador}

{\itshape
 \textbf{Port}(}

{\itshape
\foreignlanguage{spanish}{ }\foreignlanguage{english}{Up  :
}\foreignlanguage{english}{\textbf{In}}\foreignlanguage{english}{ 
Std\_Logic;}}

{\itshape
 Down  : \textbf{In}  Std\_Logic;}

{\itshape
 Reset  : \textbf{In}  Std\_logic;}

{\itshape
 Clk  : \textbf{In}  Std\_logic;}

{\itshape
 Unidades : \textbf{Buffer}  Std\_Logic\_Vector( 3 Downto 0 );}

{\itshape
 Decenas  : \textbf{Out}  Std\_logic\_Vector( 3 Downto 0 )}

{\itshape
 );}

{\itshape
\textbf{end} \textbf{Component} Contador;}

{\itshape
\textbf{Component} debounce}

{\itshape
 \textbf{Port}(}

{\itshape
 Push\_Button, Clk : \textbf{In}  Std\_Logic;}

{\itshape
 Reset  : \textbf{In}  Std\_Logic;}

{\itshape
 PB\_D\ \   : \textbf{Out} Std\_Logic);}

{\itshape
\textbf{End} \textbf{Component} debounce;}

{\itshape
\textbf{Component} clk\_div2}

{\itshape
 \textbf{GENERIC}( }

{\itshape
 FMHZ: Natural := 8;}

{\itshape
 TD  : Natural := 20 );}

{\itshape
 \textbf{PORT}(}

{\itshape
 clock\_FMHZ  : \textbf{In}  Std\_Logic;}

{\itshape
 Reset  : \textbf{In}  Std\_Logic;}

{\itshape
 clock\_1Hz  : \textbf{Out}  Std\_Logic;}

{\itshape
 Clock\_TD  : \textbf{Out}  Std\_Logic );}

{\itshape
\textbf{END} \textbf{Component} clk\_div2;}

{\itshape
\textbf{Signal} CLKTD, CLK1Hz, UPI, DNI  : Std\_Logic;}

{\itshape
\textbf{Signal} Unidades, Decenas : Std\_logic\_vector( 3
\textbf{downto} 0 );}

{\bfseries\itshape
begin}

{\itshape
 A1: clk\_div2}

{\itshape
 \textbf{Generic} \textbf{map}(8, 20)}

{\itshape
 \textbf{Port} \textbf{Map}( Clk, Reset, CLK1Hz, CLKTD );}

{\itshape
 A2: debounce}

{\itshape
 \textbf{Port} \textbf{Map}( Up, CLKTD, Reset, UPI );}

{\itshape
 A3: debounce}

{\itshape
 \textbf{Port} \textbf{Map}( Down, CLKTD, Reset, DNI );}

{\itshape
\foreignlanguage{english}{ }A4: Contador}

{\itshape
 \textbf{Port} \textbf{Map}( UPI, DNI, Reset, CLKTD, Unidades, Decenas
);}

{\itshape
 \foreignlanguage{english}{A5: Show}}

{\itshape
 \textbf{Port} \textbf{Map}( Unidades, Decenas, CLKTD, Sel, SEG );}

{\itshape
\textbf{end} UDCounter\_arch;}

{\bfseries
Ejemplo 6: UART ( Universal Asynchronous Receiver \& Transmitter )}

{
La comunicación asíncrona es ampliamente utilizada en los sistemas
digitales, por esta razón en este ejemplo se diseñará un sistema capáz
de realizar una comunicación serial asíncrona. }

{
En la Figura 40 se muestra una trama típica de este tipo de
comunicación, el primer bit en ser enviado es el Bit de Start ( Cero
Lógico ), después se envían los bits de datos los cuales pueden variar
de 6 a 8 Bits, a continuación el bit de paridad el cual es útil para la
detección de errores en la transferencia; Este bit no es obligatorio y
en este ejemplo no lo utilizaremos y por último está el bit de stop.}

 \includegraphics[width=12.596cm,height=3.713cm]{FSM-img40.png} 

{
Figura 40. Trama básica de la transmisión asíncrona: 1 bit de Start, 8
bits de Datos, un bit de paridad ( opcional ) y un Bit de Stop.}

{
En un protocolo asíncrono el emisor y el receptor no comparten el mismo
reloj, debido a esto se debe conocer la velocidad de transmisión ( Baud
Rate ) antes de iniciarse las comunicaciones. Por lo cual los relojes
internos del transmisor y el receptor se deben fijar a la misma
frecuencia. El receptor sincroniza su reloj interno al iniciar cada
trama, esto se puede realizar detectando la transición de alto a bajo
en señal de recepción. }

{
Un concepto clave en el diseño de UARTs es que el reloj interno de la
UART debe ser más rápido que la velocidad de transmisión. En la UART
16450 su reloj es 16 veces más rápido que la Tasa de Baudios. Una vez
que el inicio de la transmisión se detecta se debe esperar un tiempo
igual a 24 ciclos de muestreo ( 16 del Bit de Start + 8 del Bit ) esto
se hace para que el receptor pueda relizar la lectura del dato entrante
en la mitad de cada BIT. Después de esto se muestrea la señal de
entrada cada 16 ciclos del reloj de muestreo. En la Figura 41 se
muestra este concepto.}

{\centering 
\includegraphics[width=12.598cm,height=7.856cm]{FSM-img41.png} \par}

{\centering
Figura 41. Puntos de muestreo del receptor.
\par}

{
El diseño del transmisor es más sencillo ya que el puede iniciar a
enviar datos en cualquier momento y simplemente debe realizar el
corrimiento de los datos cada 1/Baud Rate.}

{
En la siguiente figura se muestra la interfaz y el diagrama de bloques
de la UART.}

{\centering 
\includegraphics[width=11.19cm,height=11.164cm]{FSM-img42.png} \par}

{\centering
Figura 42. Diagrama de Bloques de la UART.
\par}

{
Donde:}

{
Reset  : Reset general del sistema activa alta.}

{
Clk  : Señal de Reloj.}

{
Rx  : Señal de entrada serial asíncrona.}

{
Read\_Data  : Activa alta le informa al receptor que el dato a sido
leído.}

{
Data\_Ready  : Indica la recepción de un dato por la línea Rx. El dato
está disponible }

{
 en Data\_Rx.}

{
Data\_Rx( 7..0 ) : Dato recibido por el receptor.}

{
Data\_Tx( 7..0 ) : Dato a transmitir por la UART.}

{
Start\_Tx  : Inicio de la transmisión.}

{
Tx  : Señal de salida serial}

{
Tx\_Empty  : En estado lógico alto ndica que el transmisor está
disponible para una }

{
 nueva transmisión.}

{
\textbf{Generador de Muestreo}: Este módulo está encargado de generar la
frecuencia de muestreo del receptor y el reloj del transmisor. En la
siguiente figura se muestra la interfaz y el diagrama de bloques de
este módulo.}

{\centering 
\includegraphics[width=11.455cm,height=10.052cm]{FSM-img43.png} \par}

{\centering
Figura 43. Diagrama de bloques del generador de muestreo.
\par}

{
El bloque {\textquotedblleft} Divisor x 16 {\textquotedblright} como su
nombre lo indica divide la señal de entrada en 16. El divisor de
frecuencia programable es capaz de dividir la señal de entrada de 1 a
FFFF H ( 65535 ). El factor de división debe ser ingresado de la
siguiente forma: Colocar el byte menos significativo en
\textit{cte\_div} y hacer \textit{Load\_Hi = 0} y \textit{Load\_Low }=
1. Colocar el byte más significativo en \textit{cte\_div} y hacer
\textit{Load\_Hi} = 1 y \textit{Load\_Low} = 0.
\foreignlanguage{english}{Asignar
}\foreignlanguage{english}{\textit{Load\_Hi = 0
}}\foreignlanguage{english}{y}\foreignlanguage{english}{\textit{
Load\_Low = 0}}\foreignlanguage{english}{. }Como se observa en la
Figura anterior el reloj del transmisor Clk\_Txs se genere al dividir
la señal de reloj entrante entre 16*16*cte\_div, si por ejemplo tenemos
un cristal de 4.9125 Mhz y deseamos realizar una transmisión a 2400 BPS
\textit{cte\_div} será igual a:}

\begin{equation*}
{\normalsubformula{\text{cte}}_{\normalsubformula{\text{div}}}=\frac{\normalsubformula{\text{fin}}}{\normalsubformula{\text{BPS}}\ast
\text{256}}}
\end{equation*}
{
Que para nuestro ejemplo sería:}

% \begin{equation*}
% \begin{matrix}{\frac{\text{4915200}}{\text{2400}\ast
% \text{256}}=8=\text{0008}H}\hfill\null \\\hfill\null \end{matrix}\hfill
% 
% \end{equation*}
{
A continuación se muestrá el código de los módulos div16 y div\_ms:}

{\itshape
{}-{}- Inicio del módulo div16}

{\itshape
\textbf{Library} Ieee;}

{\itshape
\textbf{Use} Ieee.Std\_Logic\_1164.all;}

{\itshape
\textbf{Use} Ieee.Std\_Logic\_Arith.all;}

{
\textbf{Use} Ieee.Std\_Logic\_unsigned.all;}

{\itshape
\textbf{entity} div16 \textbf{is}}

{\itshape
 \textbf{port }(}

{\itshape
 Reset: \textbf{in} STD\_LOGIC;}

{\itshape
 Clk: \textbf{in} STD\_LOGIC;}

{\itshape
 Clk\_In: \textbf{in} STD\_LOGIC;}

{\itshape
 Clk\_Out: \textbf{out} STD\_LOGIC}

{\itshape
 );}

{\itshape
\textbf{end} div16;}

{\itshape
\textbf{architecture} div16\_arch \textbf{of} div16 \textbf{is}}

{\itshape
\textbf{Signal} divider  : Std\_Logic\_Vector( 3 \textbf{downto} 0 );}

{\bfseries\itshape
begin}

{\itshape
 \textbf{Process}( CLK, Reset )}

{\itshape
 \textbf{Begin}}

{\itshape
 \textbf{if} clk\textbf{{\textquotesingle}event and} clk =
{\textquotesingle}1{\textquotesingle} \textbf{then}}

{\itshape
 \textbf{if} Reset = {\textquotesingle}1{\textquotesingle}
\textbf{then}}

{\itshape
 divider {\textless}= {\textquotedbl}0000{\textquotedbl};}

{\itshape
 \textbf{elsif} Clk\_In = {\textquotesingle}1{\textquotesingle}
\textbf{then}}

{\itshape
 \textbf{if} divider = {\textquotedbl}1111{\textquotedbl} \textbf{then}}

{\itshape
 divider {\textless}= {\textquotedbl}0000{\textquotedbl};}

{\itshape
 Clk\_Out {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{else}}

{\itshape
 divider {\textless}= divider + {\textquotedbl}0001{\textquotedbl};}

{\itshape
 Clk\_Out {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{process};}

{\itshape
\textbf{end} div16\_arch;}

{\itshape
{}-{}-Inicio del módulo div\_ms}

{\itshape
\textbf{Library} Ieee;}

{\itshape
\textbf{Use} Ieee.Std\_Logic\_1164.all;}

{\itshape
\textbf{Use} Ieee.Std\_Logic\_Arith.all;}

{
\textbf{Use} Ieee.Std\_Logic\_unsigned.all;}

{\itshape
\textbf{entity} Div\_ms \textbf{is}}

{\itshape
 \textbf{port} (}

{\itshape
 Reset  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Clk  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Clk\_In  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Divider  : \textbf{in}  STD\_LOGIC\_Vector( 7 \textbf{downto} 0 );}

{\itshape
 Ld\_Div\_Low  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Ld\_Div\_Hi  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Clk\_Out  : \textbf{out} STD\_LOGIC}

{\itshape
 );}

{\itshape
\textbf{end} Div\_ms;}

{\itshape
\textbf{architecture} Div\_ms\_arch of Div\_ms \textbf{is}}

{\itshape
\textbf{Signal} count, Div\_Factor : Std\_Logic\_Vector( 15
\textbf{downto} 0 );}

{\bfseries\itshape
begin}

{\itshape
 \textbf{Process}( CLK, Reset )}

{\itshape
 \textbf{Begin}}

{\itshape
 \textbf{if} clk\textbf{{\textquotesingle}event and} clk =
{\textquotesingle}1{\textquotesingle} then }

{\itshape
 \textbf{If} Reset = {\textquotesingle}1{\textquotesingle}
\textbf{then}}

{\itshape
 count {\textless}= ( others ={\textgreater}
{\textquotesingle}0{\textquotesingle} );}

{\itshape
 \textbf{else}}

{\itshape
 \textbf{if} Ld\_Div\_Low = {\textquotesingle}1{\textquotesingle}
\textbf{then}}

{\itshape
 Div\_Factor( 7 \textbf{downto} 0 ) {\textless}= Divider;}

{\itshape
 count {\textless}= ( others ={\textgreater}
{\textquotesingle}0{\textquotesingle} );}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{if} Ld\_Div\_Hi = {\textquotesingle}1{\textquotesingle}
\textbf{then}}

{\itshape
 Div\_Factor( 15 \textbf{downto} 8 ) {\textless}= Divider;}

{\itshape
 count {\textless}= ( others ={\textgreater}
{\textquotesingle}0{\textquotesingle} );}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{if} count = Div\_Factor \textbf{then}}

{\itshape
 count {\textless}= ( others ={\textgreater}
{\textquotesingle}0{\textquotesingle} );}

{\itshape
 Clk\_Out {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{else}}

{\itshape
 \textbf{if} Clk\_In = {\textquotesingle}1{\textquotesingle}
\textbf{then}}

{\itshape
 count {\textless}= count + 1;}

{\itshape
 Clk\_Out {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{if} ;}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{process};}

{\itshape
\textbf{end} Div\_ms\_arch;}

{
\textbf{Transmisor}: Este módulo está encargado de generar la trama a la
velocidad determinada en la señal Tx. El transmisor es bastante
sencillo ya que lo único que debe hacer es realizar un corrimiento a la
izquierda de un registro de 10 bits conformado de la siguiente forma:}

{
Dígito 0  : 0 ( Bit de Start ).}

{
Dígitos 1 -- 9 : Dato a transmitir.}

{
Dígito 10  : Bit de Stop.}

{
El código en VHDL del transmisor se muestra a continuación:}

{\itshape
\textbf{Library} Ieee;}

{\itshape
\textbf{Use} Ieee.Std\_Logic\_1164.all;}

{\itshape
\textbf{Use} Ieee.Std\_Logic\_Arith.all;}

{\itshape
\textbf{Use} Ieee.Std\_Logic\_unsigned.all;}

{\itshape
\textbf{entity} Buffer\_TX \textbf{is}}

{\itshape
 \textbf{port} (}

{\itshape
 Reset  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Clk  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Load  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Shift  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Data\_IN  : \textbf{in}  STD\_LOGIC\_VECTOR (7 \textbf{downto} 0);}

{\itshape
 Tx  : \textbf{out} STD\_LOGIC;}

{\itshape
 Tx\_Empty  : Buffer STD\_LOGIC}

{\itshape
 );}

{\itshape
\textbf{end} Buffer\_TX;}

{\itshape
\textbf{architecture} Buffer\_TX\_arch \textbf{of} Buffer\_TX
\textbf{is}}

{\itshape
\textbf{Signal} Count\_Tx : Std\_Logic\_Vector ( 3 \textbf{downto} 0 );}

{\itshape
\textbf{Signal} Reg\_Tx : Std\_Logic\_Vector( 9 \textbf{downto }0 );}

{\itshape
\textbf{Signal} Tx\_On  : Std\_Logic;  {}-{}-
{\textquoteleft}1{\textquoteright} indica transmisión en progreso}

{\bfseries\itshape
Bejín}

{\itshape
{}-{}- Este proceso realiza un corrimiento cada vez que la señal Shift
(Clk\_Txs ) es igual a {\textquoteleft}1{\textquoteright}}

{\itshape
 \foreignlanguage{english}{\textbf{Process}}\foreignlanguage{english}{(
CLK, Reset, Load, Shift )}}

{\itshape
 \textbf{Begin}}

{\itshape
 \textbf{if} clk{\textquotesingle}\textbf{event and }clk =
{\textquotesingle}1{\textquotesingle} \textbf{then}}

{\itshape
 \textbf{If} Reset = {\textquotesingle}1{\textquotesingle} \textbf{then}
 }

{\itshape
 Reg\_Tx {\textless}= ( \textbf{others} ={\textgreater}
{\textquotesingle}1{\textquotesingle} );}

{\itshape
 Tx  {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{else}}

{\itshape
 \textbf{if} Load = {\textquotesingle}1{\textquotesingle} \textbf{and}
Tx\_On = {\textquotesingle}0{\textquotesingle} \textbf{then 
}{}-{}-Formación de la trama a transmitir.}

{\itshape
 Reg\_Tx( 8 \textbf{downto} 1 ) {\textless}= Data\_In;}

{\itshape
 Reg\_Tx( 0 ) {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 Reg\_Tx( 9 ) {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{else}}

{\itshape
 \textbf{if} Shift = {\textquotesingle}1{\textquotesingle} \textbf{then
}{}-- Corrimiento de la trama.}

{\itshape
 Reg\_Tx( 8 \textbf{downto} 0 ) {\textless}= Reg\_Tx( 9 \textbf{downto}
1 );}

{\itshape
 Tx {\textless}= Reg\_Tx( 0 );}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{process}; }

{\itshape
 \textbf{Process}( CLK, Reset, Load, Shift )}

{\itshape
{}-{}- Este proceso controla el número de corrimientos realizados por el
transmisor}

{\itshape
 \foreignlanguage{english}{\textbf{Begin}}}

{\itshape
 \textbf{if} clk\textbf{{\textquotesingle}event and} clk =
{\textquotesingle}1{\textquotesingle} \textbf{then}}

{\itshape
 \textbf{If} Reset = {\textquotesingle}1{\textquotesingle} \textbf{then}
 }

{\itshape
 Tx\_On  {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 Tx\_Empty {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 Count\_Tx {\textless}= {\textquotedbl}0000{\textquotedbl};}

{\itshape
 \textbf{else}}

{\itshape
 \textbf{if} Load = {\textquotesingle}1{\textquotesingle} \textbf{and}
Tx\_On = {\textquotesingle}0{\textquotesingle} \textbf{then}}

{\itshape
 Tx\_Empty {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 Tx\_On  {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{elsif} Shift = {\textquotesingle}1{\textquotesingle}
\textbf{then}}

{\itshape
 \textbf{if} Tx\_On = {\textquotesingle}1{\textquotesingle}
\textbf{then}}

{\itshape
 Count\_Tx {\textless}= Count\_Tx + 1;}

{\itshape
 \textbf{if} Count\_Tx = {\textquotedbl}1001{\textquotedbl}
\textbf{then}}

{\itshape
 Count\_Tx {\textless}= {\textquotedbl}0000{\textquotedbl};}

{\itshape
 Tx\_On  {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 Tx\_Empty {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{else}}

{\itshape
 Tx\_On  {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{else}}

{\itshape
 Tx\_Empty {\textless}= Tx\_Empty;}

{\itshape
 Tx\_On  {\textless}= Tx\_On;}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{if};  }

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{process};}

{
\textbf{end} Buffer\_TX\_arch;}

{
\textbf{Receptor}: El receptor está encargado de generar los pulsos de
muestreo en la mitad de cada Bit y detectar el inicio y fin de la trama
( Bit de Start y Bit de Stop ). Como puede verse en la Figura 43. El
generador de pulsos de muestreo produce la señal \textit{clkls} la cual
es 16 veces más rápida que la señal Clk\_Txs la cual se produce cada
1/Baud Rate. Por lo tanto el receptor debe esperar 8 ciclos de la señal
clkls para leer los bits de datos y Stop. En la siguiente figura se
muestra la interfaz y el diagrama de bloques del receptor.}

{\centering 
\includegraphics[width=12.612cm,height=9.409cm]{FSM-img44.png} \par}

{\centering
Figura 46. Diagrama de bloques del receptor.
\par}

{
Interface\_Rx : Está encargada de sincronizar la señal de entrada
\textit{Rx }con la señal \textit{clkls}. Como salida tiene la señal
\textit{RxDs}.}

{\itshape
\textbf{library} IEEE;}

{\itshape
\textbf{use} IEEE.std\_logic\_1164.all;}

{\itshape
\textbf{entity} Interface\_Rx \textbf{is}}

{\itshape
 \textbf{port} (}

{\itshape
 Reset: \textbf{in} STD\_LOGIC;}

{\itshape
 Clk: \textbf{in} STD\_LOGIC;}

{\itshape
 clk\_ms: \textbf{in} STD\_LOGIC;}

{\itshape
 RxD: \textbf{in} STD\_LOGIC;}

{\itshape
 RxDs: \textbf{out} STD\_LOGIC}

{\itshape
 );}

{\itshape
\textbf{end} Interface\_Rx;}

{\itshape
\textbf{architecture} Interface\_Rx\_arch \textbf{of} Interface\_Rx
\textbf{is}}

{\itshape
\textbf{Signal} ifrxd : Std\_Logic\_Vector( 2 \textbf{downto} 0 );}

{\bfseries\itshape
begin}

{\itshape
 \textbf{Process}( CLK, Reset )}

{\itshape
 \textbf{Begin}}

{\itshape
 \textbf{if} clk{\textquotesingle}\textbf{event and }clk =
{\textquotesingle}1{\textquotesingle} \textbf{then }}

{\itshape
 \textbf{if} Reset = {\textquotesingle}1{\textquotesingle}
\textbf{then}}

{\itshape
 ifrxd {\textless}= {\textquotedbl}111{\textquotedbl};}

{\itshape
 \textbf{else}}

{\itshape
 \textbf{if} ( ifrxd(0) = ifrxd(2) ) \textbf{and} ( ifrxd(0) /= ifrxd(1)
) \textbf{then}}

{\itshape
 ifrxd(2) {\textless}= ifrxd(0);}

{\itshape
 \textbf{else}}

{\itshape
 ifrxd(2) {\textless}= ifrxd(1);}

{\itshape
 ifrxd(1) {\textless}= ifrxd(0);}

{\itshape
 ifrxd(0) {\textless}= RxD;}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 RxDs {\textless}= ifrxd(2);}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{process};}

{\itshape
\textbf{end} Interface\_Rx\_arch;}

{
Sample\_Rx: Este módulo está encargado de generar la señal de muestreo
\textit{samples}. La generación de pulsos inicia al detectar una
transición de alto a bajo en la línea \textit{RxDs} y finaliza cuando
la señal \textit{Rx\_Full }sea igual a
{\textquoteleft}1{\textquoteright}.}

{\itshape
\textbf{library} IEEE;}

{\itshape
\textbf{use} IEEE.std\_logic\_1164.all;}

{\itshape
\textbf{Use} Ieee.Std\_Logic\_Arith.all;}

{\itshape
\textbf{Use} Ieee.Std\_Logic\_unsigned.all;}

{\itshape
\textbf{entity} SAMPLE\_RX \textbf{is}}

{\itshape
 \textbf{port} (}

{\itshape
 Reset: \textbf{in} STD\_LOGIC;}

{\itshape
 CLK: \textbf{in} STD\_LOGIC;}

{\itshape
 Rst\_S: \textbf{in} STD\_LOGIC;}

{\itshape
 Clkms: \textbf{in} STD\_LOGIC;}

{\itshape
 RxDs: \textbf{in} STD\_LOGIC;}

{\itshape
 Sample: \textbf{out} STD\_LOGIC}

{\itshape
 );}

{\itshape
\textbf{end} SAMPLE\_RX;}

{\itshape
\textbf{architecture} SAMPLE\_RX\_arch \textbf{of} SAMPLE\_RX
\textbf{is}}

{\itshape
\textbf{Signal} cont\_m : Std\_Logic\_Vector( 3 \textbf{downto} 0 );
-{}- Contador del modulo de muestreo}

{\itshape
\textbf{Signal} Flag\_Rx: Std\_Logic;  {}-{}- Flag de Recepcion en
curso}

{\bfseries\itshape
begin}

{\itshape
 \textbf{Process}( CLK, Reset )}

{\itshape
 \textbf{Begin}}

{\itshape
 \textbf{if} clk\textbf{{\textquotesingle}event and} clk =
{\textquotesingle}1{\textquotesingle} \textbf{then} }

{\itshape
 \textbf{If} Reset = {\textquotesingle}1{\textquotesingle}
\textbf{then}}

{\itshape
 cont\_m  {\textless}= {\textquotedbl}0000{\textquotedbl};}

{\itshape
 sample  {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 Flag\_Rx {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{elsif} Rst\_S = {\textquotesingle}1{\textquotesingle}
\textbf{then}}

{\itshape
 cont\_m  {\textless}= {\textquotedbl}0000{\textquotedbl};}

{\itshape
 sample  {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 Flag\_Rx {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{elsif} Clkms = {\textquotesingle}1{\textquotesingle}
\textbf{then}}

{\itshape
 \textbf{if} Flag\_Rx = {\textquotesingle}0{\textquotesingle}
\textbf{and} RxDs = {\textquotesingle}0{\textquotesingle} \textbf{then}
 {}-{}- Bit de Start}

{\itshape
\foreignlanguage{english}{ }Flag\_Rx {\textless}=
{\textquotesingle}1{\textquotesingle};  {}-{}- Inicio de la recepcion}

{\itshape
 \foreignlanguage{english}{\textbf{elsif}}\foreignlanguage{english}{
Flag\_Rx = {\textquotesingle}1{\textquotesingle}
}\foreignlanguage{english}{\textbf{then}}}

{\itshape
 cont\_m {\textless}= cont\_m + {\textquotedbl}0001{\textquotedbl};}

{\itshape
 \textbf{if} cont\_m = {\textquotedbl}0110{\textquotedbl} then}

{\itshape
 sample {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{else}}

{\itshape
 sample {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{End} \textbf{Process};}

{\itshape
\textbf{end} SAMPLE\_RX\_arch;}

{
ctrl\_tx: Esté módulo es básicamente un contador de pulsos de muestreo
samples, cuando el conteo llega a 10 ( Bit de Start, 8 bits de datos y
Bit de Stor ), la señal Rx\_Full es igual a
{\textquoteleft}1{\textquoteright}.}

{\itshape
\textbf{library} IEEE;}

{\itshape
\textbf{use} IEEE.std\_logic\_1164.all;}

{\itshape
\textbf{USE} IEEE.STD\_LOGIC\_ARITH.all;}

{\itshape
\textbf{USE} IEEE.STD\_LOGIC\_UNSIGNED.all;}

{\itshape
\textbf{entity} ctrl\_tx \textbf{is}}

{\itshape
 \textbf{port} (}

{\itshape
 Reset  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Clk  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Load  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Shift  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Tx\_Empty : \textbf{Buffer} STD\_LOGIC}

{\itshape
 );}

{\itshape
\textbf{end} ctrl\_tx;}

{\itshape
\textbf{architecture} ctrl\_tx\_arch \textbf{of} ctrl\_tx \textbf{is}}

{\itshape
\textbf{Signal} Count\_Tx : Std\_Logic\_Vector ( 3 \textbf{downto} 0 );}

{\itshape
\textbf{Signal} Tx\_On  : Std\_Logic;}

{\bfseries\itshape
begin}

{\itshape
 \textbf{Process}( CLK, Reset, Load, Shift )}

{\itshape
 \textbf{Begin}}

{\itshape
 \textbf{if} clk{\textquotesingle}\textbf{event and }clk =
{\textquotesingle}1{\textquotesingle} \textbf{then}}

{\itshape
 \textbf{If} Reset = {\textquotesingle}1{\textquotesingle} \textbf{then}
 }

{\itshape
 Tx\_On  {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 Tx\_Empty {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 Count\_Tx {\textless}= {\textquotedbl}0000{\textquotedbl};}

{\itshape
 \textbf{else}}

{\itshape
 \textbf{if} Load = {\textquotesingle}1{\textquotesingle} \textbf{and}
Tx\_On = {\textquotesingle}0{\textquotesingle} \textbf{then}}

{\itshape
 Tx\_Empty {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 Tx\_On  {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{elsif} Shift = {\textquotesingle}1{\textquotesingle}
\textbf{then}}

{\itshape
 \textbf{if} Tx\_On = {\textquotesingle}1{\textquotesingle}
\textbf{then}}

{\itshape
 Count\_Tx {\textless}= Count\_Tx + 1;}

{\itshape
 \textbf{if} Count\_Tx = {\textquotedbl}1001{\textquotedbl}
\textbf{then}}

{\itshape
 Count\_Tx {\textless}= {\textquotedbl}0000{\textquotedbl};}

{\itshape
 Tx\_On  {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 Tx\_Empty {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{else}}

{\itshape
 Tx\_On  {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{else}}

{\itshape
 Tx\_Empty {\textless}= Tx\_Empty;}

{\itshape
 Tx\_On  {\textless}= Tx\_On;}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{if};  }

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{process};}

{\itshape
\textbf{end} ctrl\_tx\_arch;}

{
Buffer\_Rx: Está encargado de realizar la conversión de seria a paralelo
del dato de entrada.}

{\itshape
\textbf{library} IEEE;}

{\itshape
\textbf{use} IEEE.std\_logic\_1164.all;}

{\itshape
\textbf{USE} IEEE.STD\_LOGIC\_ARITH.all;}

{\itshape
\textbf{USE} IEEE.STD\_LOGIC\_UNSIGNED.all;}

{\itshape
\textbf{entity} Buffer\_TX \textbf{is}}

{\itshape
 \textbf{port} (}

{\itshape
 Reset  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Clk  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Load  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Shift  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Data\_IN  : \textbf{in}  STD\_LOGIC\_VECTOR (7 \textbf{downto} 0);}

{\itshape
 Tx  : \textbf{out} STD\_LOGIC;}

{\itshape
 Tx\_Empty  : \textbf{Buffer} STD\_LOGIC}

{\itshape
 );}

{\itshape
\textbf{end} Buffer\_TX;}

{\itshape
\textbf{architecture} Buffer\_TX\_arch \textbf{of} Buffer\_TX
\textbf{is}}

{\itshape
\textbf{Signal} Count\_Tx : Std\_Logic\_Vector ( 3 \textbf{downto} 0 );}

{\itshape
\textbf{Signal} Reg\_Tx : Std\_Logic\_Vector( 9 \textbf{downto} 0 );}

{\itshape
\textbf{Signal} Tx\_On  : Std\_Logic;}

{\bfseries\itshape
begin}

{\itshape
 \textbf{Process}( CLK, Reset, Load, Shift )}

{\itshape
 \textbf{Begin}}

{\itshape
 \textbf{if} clk\textbf{{\textquotesingle}event and} clk =
{\textquotesingle}1{\textquotesingle} \textbf{then}}

{\itshape
 \textbf{If} Reset = {\textquotesingle}1{\textquotesingle} \textbf{then}
 }

{\itshape
 Reg\_Tx {\textless}= ( \textbf{others} ={\textgreater}
{\textquotesingle}1{\textquotesingle} );}

{\itshape
 Tx  {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{else}}

{\itshape
 \textbf{if} Load = {\textquotesingle}1{\textquotesingle} \textbf{and}
Tx\_On = {\textquotesingle}0{\textquotesingle} \textbf{then}}

{\itshape
 Reg\_Tx( 8 downto 1 ) {\textless}= Data\_In;}

{\itshape
 Reg\_Tx( 0 ) {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 Reg\_Tx( 9 ) {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{else}}

{\itshape
 \textbf{if} Shift = {\textquotesingle}1{\textquotesingle}
\textbf{then}}

{\itshape
 Reg\_Tx( 8 \textbf{downto} 0 ) {\textless}= Reg\_Tx( 9 \textbf{downto}
1 );}

{\itshape
 Tx {\textless}= Reg\_Tx( 0 );}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{process}; }

{\itshape
 \textbf{Process}( CLK, Reset, Load, Shift )}

{\itshape
 \textbf{Begin}}

{\itshape
 \textbf{if} clk\textbf{{\textquotesingle}event and} clk =
{\textquotesingle}1{\textquotesingle} \textbf{then}}

{\itshape
 \textbf{If} Reset = {\textquotesingle}1{\textquotesingle} \textbf{then}
 }

{\itshape
 Tx\_On  {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 Tx\_Empty {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 Count\_Tx {\textless}= {\textquotedbl}0000{\textquotedbl};}

{\itshape
 \textbf{else}}

{\itshape
 \textbf{if} Load = {\textquotesingle}1{\textquotesingle} \textbf{and}
Tx\_On = {\textquotesingle}0{\textquotesingle} \textbf{then}}

{\itshape
 Tx\_Empty {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 Tx\_On  {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{elsif} Shift = {\textquotesingle}1{\textquotesingle}
\textbf{then}}

{\itshape
 \textbf{if} Tx\_On = {\textquotesingle}1{\textquotesingle}
\textbf{then}}

{\itshape
 Count\_Tx {\textless}= Count\_Tx + 1;}

{\itshape
 \textbf{if} Count\_Tx = {\textquotedbl}1001{\textquotedbl}
\textbf{then}}

{\itshape
 Count\_Tx {\textless}= {\textquotedbl}0000{\textquotedbl};}

{\itshape
 Tx\_On  {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 Tx\_Empty {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{else}}

{\itshape
 Tx\_On  {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{end if};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{else}}

{\itshape
 Tx\_Empty {\textless}= Tx\_Empty;}

{\itshape
 Tx\_On  {\textless}= Tx\_On;}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{if};  }

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{process};}

{\itshape
\textbf{end} Buffer\_TX\_arch;}

{
A continuación se presenta la descripción estructural de la Uart:}

{\itshape
\textbf{library }IEEE;}

{\itshape
\textbf{Use} Ieee.Std\_Logic\_1164.all;}

{\itshape
\textbf{Use} Ieee.Std\_Logic\_Arith.all;}

{
\textbf{Use} Ieee.Std\_Logic\_unsigned.all;}

{\itshape
\textbf{entity} uart \textbf{is}}

{\itshape
 \textbf{port} (}

{\itshape
 {}-{}- Senales comunes}

{\itshape
 Reset  : \textbf{in}  STD\_LOGIC;  {}-{}- Reset Activo Alto}

{\itshape
 Clk  : \textbf{in}  STD\_LOGIC;  {}-{}- Clock del sistema}

{\itshape
 {}-{}- Receptor}

{\itshape
 Rx  : \textbf{in}  STD\_LOGIC;  {}-{}- Linea de recepcion}

{\itshape
\foreignlanguage{english}{ }\foreignlanguage{spanish}{Read\_Data  :
}\foreignlanguage{spanish}{\textbf{in}}\foreignlanguage{spanish}{ 
STD\_LOGIC;  {}-{}- {\textquotesingle}1{\textquotesingle} : Lectura del
dato recibido}}

{\itshape
\foreignlanguage{spanish}{ }\foreignlanguage{english}{Data\_Ready  :
}\foreignlanguage{english}{\textbf{out}}\foreignlanguage{english}{ 
STD\_LOGIC; -{}- {\textquotesingle}1{\textquotesingle} : Dato
disponible}}

{\itshape
 Data\_Rx  : \textbf{out} STD\_LOGIC\_VECTOR ( 7 \textbf{downto} 0 );}

{\itshape
 {}-{}- Transmisor}

{\itshape
 Data\_Tx  : \textbf{in}  STD\_LOGIC\_Vector( 7 \textbf{downto} 0 ); 
{}-{}- Dato a transmitir}

{\itshape
 Start\_Tx  : \textbf{in}  STD\_LOGIC;  {}-{}-
{\textquotesingle}1{\textquotesingle} : Inicio de la transmision}

{\itshape
 Tx  : \textbf{Out} STD\_LOGIC;  {}-{}- Linea de transmision}

{\itshape
 Tx\_Empty  : \textbf{Buffer} STD\_LOGIC  {}-{}-
{\textquotesingle}1{\textquotesingle} Transmisor disponible.}

{\itshape
 );}

{\itshape
\textbf{end} UART;}

{\itshape
\textbf{architecture} UART\_arch of UART \textbf{is}}

{\itshape
\textbf{Signal} Hi: Std\_Logic;}

{\itshape
\textbf{Component} SAMPLE\_RX}

{\itshape
 \textbf{port} (}

{\itshape
 Reset  : \textbf{in}  STD\_LOGIC;}

{\itshape
 CLK  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Rst\_S  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Clkms  : \textbf{in}  STD\_LOGIC;}

{\itshape
 RxDs  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Sample : out STD\_LOGIC}

{\itshape
 );}

{\itshape
\textbf{end} \textbf{Component} SAMPLE\_RX;}

{\itshape
\textbf{Component} Ctrl\_Rx}

{\itshape
 \textbf{port} (}

{\itshape
 Reset  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Clk  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Samples  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Read\_Data : \textbf{in}  STD\_LOGIC;}

{\itshape
 Data\_Ready: \textbf{out}  STD\_LOGIC;}

{\itshape
 Rx\_Full  : \textbf{Buffer} STD\_LOGIC}

{\itshape
 );}

{\itshape
\textbf{end} \textbf{Component} Ctrl\_Rx;}

{\itshape
\textbf{Component} Buffer\_Rx}

{\itshape
 \textbf{port} (}

{\itshape
 Reset  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Clk  : \textbf{in}  STD\_LOGIC;}

{\itshape
 RxDs  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Samples  : \textbf{in  }STD\_LOGIC;}

{\itshape
 End\_Rx  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Data\_Rx  : \textbf{out} STD\_LOGIC\_VECTOR (7 \textbf{downto} 0)}

{\itshape
 );}

{\itshape
\textbf{end} \textbf{Component} Buffer\_Rx;}

{\itshape
\textbf{Component} Interface\_Rx}

{\itshape
 \textbf{port} (}

{\itshape
 Reset  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Clk  : \textbf{in}  STD\_LOGIC;}

{\itshape
 clk\_ms : \textbf{in}  STD\_LOGIC;}

{\itshape
 RxD  : \textbf{in}  STD\_LOGIC;}

{\itshape
 RxDs  : \textbf{out} STD\_LOGIC}

{\itshape
 );}

{\itshape
\textbf{end} \textbf{Component} Interface\_Rx;}

{\itshape
\textbf{Component} div16}

{\itshape
 \textbf{port} (}

{\itshape
 Reset  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Clk  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Clk\_In  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Clk\_Out : \textbf{out} STD\_LOGIC}

{\itshape
 );}

{\itshape
\textbf{end} \textbf{Component} div16;}

{\itshape
\textbf{Component} pulso}

{\itshape
 \textbf{port} (}

{\itshape
 Reset  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Clk  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Data\_asyn : \textbf{in}  STD\_LOGIC;}

{\itshape
 Data\_syn  : \textbf{out} STD\_LOGIC}

{\itshape
 );}

{\itshape
\textbf{end} \textbf{Component} pulso;}

{\itshape
\textbf{Component} Div\_ms}

{\itshape
 \textbf{port} (}

{\itshape
 Reset  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Clk  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Clk\_In  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Divider  : \textbf{in}  STD\_LOGIC\_Vector( 7 \textbf{downto} 0 );}

{\itshape
 Ld\_Div\_Low  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Ld\_Div\_Hi  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Clk\_Out  : \textbf{out} STD\_LOGIC}

{\itshape
 );}

{\itshape
\textbf{end} \textbf{Component} Div\_ms;}

{\itshape
 \textbf{Component} Control\_RX}

{\itshape
 \textbf{GENERIC}( }

{\itshape
 Div\_Hi  : Integer := 0;}

{\itshape
 Div\_Low : Integer := 2 );}

{\itshape
 \textbf{port} (}

{\itshape
 Reset  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Clk  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Ld\_Div\_Low : \textbf{out} STD\_LOGIC;}

{\itshape
 Ld\_Div\_Hi  : \textbf{out} STD\_LOGIC;}

{\itshape
 Data\_Out  : \textbf{out} STD\_LOGIC\_VECTOR (7 \textbf{downto} 0)}

{\itshape
 );}

{\itshape
\textbf{end} \textbf{Component} Control\_RX;}

{\itshape
\textbf{Component} Buffer\_TX}

{\itshape
 \textbf{port} (}

{\itshape
 Reset  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Clk  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Load  : \textbf{in}  STD\_LOGIC;}

{\itshape
 Shift  : in  STD\_LOGIC;}

{\itshape
 Data\_IN  : \textbf{in}  STD\_LOGIC\_VECTOR (7 \textbf{downto} 0);}

{\itshape
 Tx  : \textbf{out}  STD\_LOGIC;}

{\itshape
 TX\_Empty  : \textbf{Buffer} STD\_LOGIC}

{\itshape
 );}

{\itshape
\textbf{end} \textbf{Component} Buffer\_TX;}

{\itshape
\textbf{Signal} Rx\_Full, RxDs, samples, sample, clk\_pres, clkls, clkl
: Std\_Logic;}

{\itshape
\textbf{Signal} Clk\_Tx, Clk\_Txs : STD\_LOGIC;}

{\itshape
\textbf{Signal} carga\_div\_low, carga\_div\_Hi : STD\_LOGIC;}

{\itshape
\textbf{Signal} Data\_In : STD\_LOGIC\_VECTOR( 7 \textbf{downto} 0 );}

{\itshape
begin}

{\itshape
 Hi {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
\foreignlanguage{english}{
}{}-{}-\foreignlanguage{spanish}{***********************************************}*****************************************************}

{\itshape
 {}-{}- * Generador de Frecuencia: La frecuencia de muestreo debe ser 16
veces mayor que *}

{\itshape
\foreignlanguage{spanish}{ }\foreignlanguage{spanish}{{}-{}- * la
velocidad de transmision.  }\foreignlanguage{english}{*}}

{\itshape
 {}-{}-
***************************************************************************************************}

{\itshape
 A1 : div16}

{\itshape
 \textbf{port} \textbf{map}( Reset, CLK, Hi, clk\_pres );}

{\itshape
 A2 : div\_ms }

{\itshape
 \textbf{port} \textbf{map}( Reset, CLK, clk\_pres,data\_in,
carga\_div\_low, carga\_div\_Hi, clkl );}

{\itshape
 A3 : pulso}

{\itshape
 \textbf{port} \textbf{map}( Reset, CLK, clkl, clkls );}

{\itshape
 A4 : div16}

{\itshape
 \textbf{port} \textbf{map}( Reset, CLK, clkls, Clk\_Tx );}

{\itshape
 A5 : pulso}

{\itshape
 \textbf{port} \textbf{map}( Reset, CLK, Clk\_Tx, Clk\_Txs );}

{\itshape
\foreignlanguage{english}{ }\foreignlanguage{spanish}{{}-{}-
**************}}

{\itshape
 {}-{}- * Receptor * }

{\itshape
 {}-{}- *************}

{\itshape
 {}-{}- Sincroniza la señal de entrada Rx con clkls, RxDs señal de
salida sincronizada}

{\itshape
\foreignlanguage{spanish}{ }\foreignlanguage{english}{A6 : Interface\_Rx
}}

{\itshape
 \textbf{port} \textbf{map}( Reset, CLK, clkls, Rx, RxDs );}

{\itshape
\foreignlanguage{english}{ }\foreignlanguage{spanish}{{}-{}- Detecta Bit
de Start y genera una señal (sample) que indica cuando se debe}}

{\itshape
 {}-{}- leer un bit. Sample tiene una duracion de un ciclo de reloj
CLK.}

{\itshape
\foreignlanguage{spanish}{ }\foreignlanguage{english}{A7 : Sample\_Rx 
}}

{\itshape
 \textbf{port} \textbf{map}( Reset, CLK, Rx\_Full, clkls, RxDs, sample
);}

{\itshape
\foreignlanguage{english}{ }\foreignlanguage{spanish}{{}-{}- Sincroniza
la senal de entrada sample, samples senal sincronizada.}}

{\itshape
\foreignlanguage{spanish}{ }\foreignlanguage{english}{A8 : pulso}}

{\itshape
 \textbf{port} \textbf{map}( Reset, CLK, sample, samples );}

{\itshape
\foreignlanguage{english}{ }\foreignlanguage{spanish}{{}-{}- Control del
numero de bits, cuando se reciben 10 pulsos de la señal sample }}

{\itshape
 {}-{}- Rx\_Full se hace igual a {\textquotesingle}1{\textquotesingle}.}

{\itshape
\foreignlanguage{spanish}{ }\foreignlanguage{english}{A9 : ctrl\_rx }}

{\itshape
 \textbf{port} \textbf{map}( Reset, CLK, samples, Read\_Data,
Data\_Ready, Rx\_Full );}

{\itshape
\foreignlanguage{english}{ }{}-{}- Realiza la conversión de serie a
paralelo del dato recibido.}

{\itshape
 \foreignlanguage{english}{A10: Buffer\_Rx}}

{\itshape
 \textbf{port} \textbf{map}( Reset, CLK, RxDs, samples, Rx\_Full,
Data\_Rx );}

{\itshape
\foreignlanguage{english}{ }\foreignlanguage{spanish}{{}-{}- Carga los
registros del divisor para funcionar a 9600 BPS}}

{\itshape
\foreignlanguage{spanish}{ }\foreignlanguage{english}{A11: Control\_RX}}

{\itshape
 \textbf{generic} \textbf{map}( 0, 2 )}

{\itshape
 \textbf{port} \textbf{map}( Reset, CLK, carga\_div\_low,
carga\_div\_Hi, Data\_In );}

{\itshape
 {}-{}- **************}

{\itshape
 {}-{}- * Transmisor * }

{\itshape
 {}-{}- **************}

{\itshape
 A12: Buffer\_Tx}

{\itshape
 \textbf{port} \textbf{map}( Reset, Clk, Start\_Tx, Clk\_Txs, Data\_Tx,
Tx, Tx\_Empty );}

{\itshape
\textbf{end} UART\_arch;}

{
El test bench de la UART se muestra a continuación, junto con su
correspondiente simulación.}

{\itshape
\textbf{Use} Ieee.Std\_Logic\_1164.all;}

{\itshape
\textbf{Use} Ieee.Std\_Logic\_Arith.all;}

{\itshape
\textbf{Use} Ieee.Std\_Logic\_unsigned.all;}

{\itshape
\textbf{ENTITY} testbench \textbf{IS}}

{\itshape
\textbf{END} testbench;}

{\itshape
\textbf{ARCHITECTURE} behavior OF testbench IS }

{\itshape
{}-{}- Component Declaration}

{\itshape
 \textbf{Component} UART}

{\itshape
 \textbf{port} (}

{\itshape
 {}-{}- Senales comunes}

{\itshape
 Reset  : \textbf{in}  STD\_LOGIC;  {}-{}- Reset Activo Alto}

{\itshape
 Clk  : \textbf{in}  STD\_LOGIC;  {}-{}- Clock del sistema}

{\itshape
 {}-{}- Receptor}

{\itshape
 Rx  : \textbf{in}  STD\_LOGIC;  {}-{}- Linea de recepcion}

{\itshape
\foreignlanguage{english}{ }Read\_Data  : \textbf{in}  STD\_LOGIC; 
{}-{}- {\textquotesingle}1{\textquotesingle} : Lectura del dato
recibido}

{\itshape
 \foreignlanguage{english}{Data\_Ready  :
}\foreignlanguage{english}{\textbf{out}}\foreignlanguage{english}{ 
STD\_LOGIC; -{}- {\textquotesingle}1{\textquotesingle} : Dato
disponible}}

{\itshape
 Data\_Rx  : \textbf{out} STD\_LOGIC\_VECTOR ( 7 \textbf{downto} 0 );}

{\itshape
 {}-{}- Transmisor}

{\itshape
 Data\_Tx  : \textbf{in}  STD\_LOGIC\_Vector( 7 \textbf{downto} 0 ); 
{}-{}- Dato a transmitir}

{\itshape
 Start\_Tx  : \textbf{in}  STD\_LOGIC;  {}-{}-
{\textquotesingle}1{\textquotesingle} : Inicio de la transmision}

{\itshape
 Tx  : \textbf{Out} STD\_LOGIC;  {}-{}- Linea de transmision}

{\itshape
 Tx\_Empty  : \textbf{Buffer} STD\_LOGIC  {}-{}-
{\textquotesingle}1{\textquotesingle} Transmisor disponible.}

{\itshape
 );}

{\itshape
 \textbf{end} \textbf{component};}

{\itshape
 \textbf{SIGNAL} Reset  : STD\_LOGIC;}

{\itshape
 \textbf{SIGNAL} Clk  : STD\_LOGIC;}

{\itshape
 \textbf{SIGNAL} Rx  : STD\_LOGIC;}

{\itshape
 \textbf{SIGNAL} Read\_Data  : STD\_LOGIC;}

{\itshape
 \textbf{SIGNAL} Data\_Ready  : STD\_LOGIC;}

{\itshape
 \textbf{SIGNAL} Data\_Rx  : STD\_LOGIC\_VECTOR (7 \textbf{downto} 0);}

{\itshape
 \textbf{SIGNAL} Data\_Tx  : STD\_LOGIC\_VECTOR (7 \textbf{downto} 0);}

{\itshape
 \textbf{SIGNAL} Start\_Tx  : STD\_LOGIC;}

{\itshape
 \textbf{SIGNAL} Tx  : STD\_LOGIC;}

{\itshape
 \textbf{SIGNAL} Tx\_Empty  : STD\_LOGIC;}

{\itshape
 \textbf{constant} ncycles  : integer := 999999999;}

{\itshape
 \textbf{constant} halfperiod : time  := 101.72 ns;\ \ }

{\itshape
 \textbf{constant} tbit  : integer := 512;}

{\bfseries\itshape
BEGIN}

{\itshape
{}-{}- Component Instantiation}

{\itshape
\ \ uut: Uart \textbf{PORT} \textbf{MAP}(}

{\itshape
 Reset  ={\textgreater} Reset,}

{\itshape
 Clk  ={\textgreater} Clk,}

{\itshape
 Rx  ={\textgreater} Rx,}

{\itshape
 Read\_Data  ={\textgreater} Read\_Data,}

{\itshape
 Data\_Ready  ={\textgreater} Data\_Ready,}

{\itshape
 Data\_Rx  ={\textgreater} Data\_Rx,}

{\itshape
 Data\_Tx  ={\textgreater} Data\_Tx,}

{\itshape
 Start\_Tx  ={\textgreater} Start\_Tx,}

{\itshape
 Tx  ={\textgreater} Tx,}

{\itshape
 Tx\_Empty  ={\textgreater} Tx\_Empty}

{\itshape
\ \ );}

{\itshape
 {}-{}- Generacion del Reloj}

{\itshape
 Clock\_Source: \textbf{process}}

{\itshape
 \textbf{begin}}

{\itshape
 \textbf{for} i \textbf{in} 0 \textbf{to} ncycles*10 \textbf{loop} 
{}-{}- Genera ncyclos de periodo 10 ns}

{\itshape
 clk {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{wait} \textbf{for} halfperiod;}

{\itshape
 clk {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{wait} \textbf{for} halfperiod;}

{\itshape
 \textbf{end} \textbf{loop};}

{\itshape
 \textbf{wait};}

{\itshape
 \textbf{end} \textbf{process} Clock\_Source;}

{\itshape
 Receiver : \textbf{PROCESS}}

{\itshape
 \textbf{BEGIN}}

{\itshape
 Reset  {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 Rx  {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 Read\_Data  {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{wait} \textbf{until} clk\textbf{{\textquotesingle}event}
\textbf{and} clk = {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{wait} \textbf{until} clk\textbf{{\textquotesingle}event}
\textbf{and} clk = {\textquotesingle}1{\textquotesingle};}

{\itshape
 Reset {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{wait} \textbf{until} clk\textbf{{\textquotesingle}event}
\textbf{and} clk = {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{wait} \textbf{until} clk\textbf{{\textquotesingle}event}
\textbf{and} clk = {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{wait} \textbf{until} clk\textbf{{\textquotesingle}event}
\textbf{and} clk = {\textquotesingle}1{\textquotesingle};}

{\itshape
 {}-{}- BIT DE START}

{\itshape
 Rx  {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{for} i \textbf{in} 0 \textbf{to} tbit \textbf{loop}}

{\itshape
 \textbf{wait} \textbf{until} clk{\textquotesingle}\textbf{event}
\textbf{and} clk = {\textquotesingle}1{\textquotesingle};}

{\itshape
 end loop;}

{\itshape
 {}-{}- D0}

{\itshape
 Rx  {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{for} i \textbf{in} 0 \textbf{to} tbit \textbf{loop}}

{\itshape
 \textbf{wait} \textbf{until} clk{\textquotesingle}\textbf{event}
\textbf{and} clk = {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{end} \textbf{loop};}

{\itshape
 {}-{}- D1}

{\itshape
 Rx  {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{for} i \textbf{in} 0 \textbf{to} tbit \textbf{loop}}

{\itshape
 \textbf{wait} \textbf{until} clk{\textquotesingle}\textbf{event}
\textbf{and} clk = {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{end} \textbf{loop};}

{\itshape
 {}-{}- D2}

{\itshape
 Rx  {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{for} i \textbf{in} 0 \textbf{to} tbit \textbf{loop}}

{\itshape
 \textbf{wait} \textbf{until} clk{\textquotesingle}\textbf{event}
\textbf{and} clk = {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{end} \textbf{loop};}

{\itshape
 {}-{}- D3}

{\itshape
 Rx  {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{for} i \textbf{in} 0 \textbf{to} tbit \textbf{loop}}

{\itshape
 wait until clk{\textquotesingle}\textbf{even}t \textbf{and} clk =
{\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{end} \textbf{loop};}

{\itshape
 {}-{}- D4}

{\itshape
 Rx  {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{for} i \textbf{in} 0 \textbf{to} tbit \textbf{loop}}

{\itshape
 \textbf{wait} \textbf{until} clk{\textquotesingle}\textbf{event}
\textbf{and} clk = {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{end} \textbf{loop};}

{\itshape
 {}-{}- D5}

{\itshape
 Rx  {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{for} i \textbf{in} 0 \textbf{to} tbit \textbf{loop}}

{\itshape
 \textbf{wait} \textbf{until} clk{\textquotesingle}\textbf{event}
\textbf{and} clk = {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{end} \textbf{loop};}

{\itshape
 {}-{}- D6}

{\itshape
 Rx  {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{for} i \textbf{in} 0 \textbf{to} tbit \textbf{loop}}

{\itshape
 \textbf{wait} \textbf{until} clk{\textquotesingle}\textbf{event}
\textbf{and} clk = {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{end} \textbf{loop};}

{\itshape
 {}-{}- D7}

{\itshape
 Rx  {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{for} i \textbf{in} 0 \textbf{to} tbit \textbf{loop}}

{\itshape
 \textbf{wait} \textbf{until} clk{\textquotesingle}\textbf{event}
\textbf{and} clk = {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{end} \textbf{loop};}

{\itshape
 {}-{}- BSTOP}

{\itshape
 Rx  {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{for} i \textbf{in} 0 \textbf{to} tbit \textbf{loop}}

{\itshape
 \textbf{wait} \textbf{until} clk{\textquotesingle}\textbf{event}
\textbf{and} clk = {\textquotesingle}1{\textquotesingle};}

{\itshape
\foreignlanguage{english}{ }\textbf{end} \textbf{loop};}

{\itshape
 {}-{}- SEGUNDO BIT ENVIADO}

{\itshape
 \foreignlanguage{english}{{}-{}- BIT DE START}}

{\itshape
 Rx  {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{for} i \textbf{in} 0 \textbf{to} tbit \textbf{loop}}

{\itshape
 \textbf{wait} \textbf{until} clk{\textquotesingle}\textbf{event}
\textbf{and} clk = {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{end} \textbf{loop};}

{\itshape
 {}-{}- D0}

{\itshape
 Rx  {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{for} i \textbf{in} 0 \textbf{to} tbit \textbf{loop}}

{\itshape
 \textbf{wait} \textbf{until} clk{\textquotesingle}\textbf{event}
\textbf{and} clk = {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{end} \textbf{loop};}

{\itshape
 {}-{}- D1}

{\itshape
 Rx  {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{for} i \textbf{in} 0 \textbf{to} tbit \textbf{loop}}

{\itshape
 \textbf{wait} \textbf{until} clk{\textquotesingle}\textbf{event}
\textbf{and} clk = {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{end} \textbf{loop};}

{\itshape
 {}-{}- LECTURA DEL PRIMER BIT RECIVIDO}

{\itshape
 Read\_Data {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{wait} \textbf{until} clk{\textquotesingle}\textbf{event}
\textbf{and} clk = {\textquotesingle}1{\textquotesingle};}

{\itshape
 Read\_Data {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 {}-{}- D2}

{\itshape
 Rx  {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{for} i \textbf{in} 0 \textbf{to} tbit \textbf{loop}}

{\itshape
 \textbf{wait} \textbf{until} clk{\textquotesingle}\textbf{event}
\textbf{and} clk = = {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{end} \textbf{loop};}

{\itshape
 {}-{}- D3}

{\itshape
 Rx  {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{for} i \textbf{in} 0 \textbf{to} tbit \textbf{loop}}

{\itshape
 \textbf{wait} \textbf{until} clk{\textquotesingle}\textbf{event}
\textbf{and} clk = {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{end} \textbf{loop};}

{\itshape
 {}-{}- D4}

{\itshape
 Rx  {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{for} i \textbf{in} 0 \textbf{to} tbit \textbf{loop}}

{\itshape
 \textbf{wait} \textbf{until} clk{\textquotesingle}\textbf{event}
\textbf{and} clk = {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{end} \textbf{loop};}

{\itshape
 {}-{}- D5}

{\itshape
 Rx  {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{for} i \textbf{in} 0 \textbf{to} tbit \textbf{loop}}

{\itshape
 \textbf{wait} \textbf{until} clk{\textquotesingle}\textbf{event}
\textbf{and} clk = {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{end} \textbf{loop};}

{\itshape
 {}-{}- D6}

{\itshape
 Rx  {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{for} i \textbf{in} 0 \textbf{to} tbit \textbf{loop}}

{\itshape
 \textbf{wait} \textbf{until} clk{\textquotesingle}\textbf{event}
\textbf{and} clk = = {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{end} \textbf{loop};}

{\itshape
 {}-{}- D7}

{\itshape
 Rx  {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{for} i \textbf{in} 0 \textbf{to} tbit \textbf{loop}}

{\itshape
 \textbf{wait} \textbf{until} clk{\textquotesingle}\textbf{event}
\textbf{and} clk = {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{end} \textbf{loop};}

{\itshape
 {}-{}- BSTOP}

{\itshape
 Rx  {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{for} i \textbf{in} 0 \textbf{to} tbit \textbf{loop}}

{\itshape
 \textbf{wait} \textbf{until} clk{\textquotesingle}\textbf{event}
\textbf{and} clk = {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{end} \textbf{loop};}

{\itshape
 wait; -{}- will wait forever}

{\itshape
 \textbf{END} \textbf{PROCESS};}

{\itshape
 Transmiter : \textbf{Process}}

{\itshape
 \textbf{Begin}}

{\itshape
 \textbf{for} i \textbf{in} 0 \textbf{to} 10 \textbf{loop}}

{\itshape
 \textbf{wait} \textbf{until} clk{\textquotesingle}\textbf{event}
\textbf{and} clk ={\textquoteright}1{\textquoteright};}

{\itshape
 \textbf{end} \textbf{loop};}

{\itshape
 Data\_Tx {\textless}= {\textquotedbl}10101010{\textquotedbl};}

{\itshape
 \textbf{wait} \textbf{until} clk{\textquotesingle}\textbf{event}
\textbf{and} clk = {\textquotesingle}1{\textquotesingle};}

{\itshape
 Start\_Tx {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{wait} \textbf{until} clk{\textquotesingle}\textbf{event}
\textbf{and} clk = {\textquotesingle}1{\textquotesingle};}

{\itshape
 Start\_Tx {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{wait} \textbf{until} clk{\textquotesingle}\textbf{event}
\textbf{and} clk = = {\textquotesingle}1{\textquotesingle};}

{\itshape
{}-{}-  Envía un nuevo dato antes de terminar la transmisión}

{\itshape
 \foreignlanguage{english}{\textbf{for}}\foreignlanguage{english}{ i
}\foreignlanguage{english}{\textbf{in}}\foreignlanguage{english}{ 0
}\foreignlanguage{english}{\textbf{to}}\foreignlanguage{english}{ 1000
}\foreignlanguage{english}{\textbf{loop}}}

{\itshape
 \textbf{wait} \textbf{until} clk{\textquotesingle}\textbf{event}
\textbf{and} clk = {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{end} \textbf{loop};}

{\itshape
 Data\_Tx {\textless}= {\textquotedbl}11100011{\textquotedbl};}

{\itshape
 \textbf{wait} \textbf{until} clk{\textquotesingle}\textbf{event}
\textbf{and} clk = {\textquotesingle}1{\textquotesingle};}

{\itshape
 Start\_Tx {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{wait} \textbf{until} clk{\textquotesingle}\textbf{event}
\textbf{and} clk = {\textquotesingle}1{\textquotesingle};}

{\itshape
 Start\_Tx {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{wait} \textbf{until} clk{\textquotesingle}\textbf{event}
\textbf{and} clk = {\textquotesingle}1{\textquotesingle};}

{\itshape
{}-{}-  Espera a que el transmisor este listo para la transmision}

{\itshape
 \foreignlanguage{english}{\textbf{wait}}\foreignlanguage{english}{
until Tx\_Empty = {\textquotesingle}1{\textquotesingle};}}

{\itshape
 \textbf{for} i \textbf{in} 0 \textbf{to} 1000 \textbf{loop}}

{\itshape
 \textbf{wait} \textbf{until} clk{\textquotesingle}\textbf{event}
\textbf{and} clk = {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{end} \textbf{loop};}

{\itshape
 Data\_Tx {\textless}= {\textquotedbl}11100011{\textquotedbl};}

{\itshape
 \textbf{wait} \textbf{until} clk{\textquotesingle}\textbf{event}
\textbf{and} clk = {\textquotesingle}1{\textquotesingle};}

{\itshape
 Start\_Tx {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{wait} \textbf{until} clk{\textquotesingle}\textbf{event}
\textbf{and} clk = {\textquotesingle}1{\textquotesingle};}

{\itshape
 Start\_Tx {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \textbf{wait} \textbf{until} clk{\textquotesingle}\textbf{event}
\textbf{and} clk = {\textquotesingle}1{\textquotesingle};}

{\itshape
 \textbf{wait};}

{\itshape
 \textbf{End} \textbf{Process};}

{
\textbf{\textit{END}};}

{\centering 
\includegraphics[width=14.99cm,height=6.087cm]{FSM-img45.png} \par}

{\centering
Figura 45. Simulación de la UART.
\par}

{\bfseries
EJEMPLO 7: Diseño de un Computador Sencillo}

{
Un computador está formado principalmente por tres unidades: La Unidad
Central de Procesamiento; La memoria que está encargada de almacenar
las instrucciones del programa y datos; Y las unidades de entrada
salida cuya función es permitir el intercambio de información con el
exterior.}

{\centering 
\includegraphics[width=10.423cm,height=3.678cm]{FSM-img46.png} \par}

{
Internamente la CPU está dividida en: El camino de datos o
\textit{Datapath} el cual a su vez está formado por:}

{
PC: ( Program Counter ) Encargado de almacenar la dirección de memoria
de la instrucción que se está ejecutando actualmente.}

{
IR: ( Instruction Register ) Encargado de almacenar el código de la
instrucción en ejecución.}

{
ACC: ( Acumulator ) Utilizado para realizar cálculos y como
almacenamiento temporal de datos de programa.}

{
MAR: ( Memory Address Register ) Utilizado para el direccionamiento de
la memoria de programa.}

{
y  la lógica de control que está encargada de manejar el
\textit{Datapath} dependiendo de la instrucción en ejecución.}

{
El primer paso en el diseño de un computador es definir las operaciones
que se podrán realizar, este conjunto de operaciones recibe el nombre
de \textit{Set de Instrucciones}. Nuestro computador será capaz de
realizar operaciones de Suma ( ADD ) , Resta ( SUB ), LOAD y STORE;
Debido a que tenemos 4 instrucciones serán necesarios dos bits para su
codificación ( opcode ), es importante notar que cada instrucción debe
tener un código único:}

\begin{center}
\tablehead{}
\begin{supertabular}{|m{1.908cm}|m{1.4629999cm}|}
\hline
\centering  Operación &
\centering\arraybslash  Código\\\hline
\centering \bfseries ADD &
\centering\arraybslash  00\\\hline
\centering \bfseries SUB &
\centering\arraybslash  01\\\hline
\centering \bfseries LOAD &
\centering\arraybslash  10\\\hline
\centering \bfseries STORE &
\centering\arraybslash  11\\\hline
\end{supertabular}
\end{center}
{
La siguiente figura muestra una arquitectura simplificada del
Computador:}

{\centering 
\includegraphics[width=8.333cm,height=12.963cm]{FSM-img47.png} \par}

{
La función LOAD carga el contenido de un registro del Banco en el
Registro A o en el Registro B, razón por la cual su codificación debe
indicar en cual registro se desea almacenar la información para esto
debemos utilizar un tercer bit que nos indique el registro:}

{
LOAD REG A = 100}

{
LOAD REG B = 101}

{
Por otro lado las funciones STORE y LOAD deben indicar hacia y de donde
se debe transferir la información por lo que estas funciones deben
indicar el registro origen o fuente, esto se logra asignándole a cada
registro una dirección de memoria e indicando la dirección del mismo en
el código de la instrucción. La siguiente figura muestra la forma de
decodificar la dirección dentro de la instrucción.}

{\centering
  \includegraphics[width=6.985cm,height=5.027cm]{FSM-img48.png} 
\par}

{
Donde \textbf{{}-} indica Don´t Care y \textbf{X} 0 o 1.}

{
Para comprender mejor el funcionamiento de nuestro computador
consideremos el siguiente ejemplo:}

{\itshape
\foreignlanguage{english}{Load regA, 0  ; regA
}\foreignlanguage{spanish}{[F0DF?]}\foreignlanguage{english}{ Reg[0]}}

{\itshape
\foreignlanguage{english}{Load regB, 1  ; regB
}\foreignlanguage{spanish}{[F0DF?]}\foreignlanguage{english}{ Reg[1]}}

{\itshape
\foreignlanguage{english}{Add  ; result
}\foreignlanguage{spanish}{[F0DF?]}\foreignlanguage{english}{ regA +
regB}}

{\itshape
Store 2  ; reg[2][F0DF?] resultReg}

{
En binario el código es:}

{\itshape
\textbf{\textcolor{blue}{1 0}}\textbf{
}\textbf{\textcolor[rgb]{0.8,0.0,0.0}{0}}\textbf{
}\textbf{\textcolor[rgb]{0.0,0.5019608,0.0}{0 0 0 0 0 
}}\textcolor{black}{;Carga el contenido del registro 0 en regA.}}

{\itshape
\textbf{\textcolor{blue}{1 0}}\textbf{
}\textbf{\textcolor[rgb]{0.8,0.0,0.0}{1}}\textbf{
}\textbf{\textcolor[rgb]{0.0,0.5019608,0.0}{0 0 0 0 1 
}}\textcolor{black}{;Carga el contenido del registro 1 en regB.}}

{\itshape
\textbf{\textcolor{blue}{0 0}}\textbf{
}\textbf{\textcolor[rgb]{0.8,0.0,0.0}{0}}\textbf{
}\textbf{\textcolor[rgb]{0.0,0.5019608,0.0}{0 0 0 0 0 
}}\textcolor{black}{;Realiza regA + regB y lo almacena en result.}}

{\itshape
\textbf{\textcolor{blue}{1 1}}\textbf{
}\textbf{\textcolor[rgb]{0.8,0.0,0.0}{0}}\textbf{
}\textbf{\textcolor[rgb]{0.0,0.5019608,0.0}{0 0 0 1 0 
}}\textcolor{black}{;Carga result en el registro 2.}}

{
Con la codificación anterior no se podría cargar datos desde la memoria
de programa al Banco de Registro, y nuestro computador estaría aislado
del mundo externo. Para solucionar esto debemos incluir otra
instrucción que nos permita el ingreso de datos desde el exterior.
Podemos ampliar la función STORE de la siguiente forma:}

{
\textbf{1 1 0 X X X X X} Almacena el contenido del registro de salida de
la ALU en la dirección XXXXX }

{
\textbf{1 1 1 X X X X X} Almacena el contenido de la memoria a la
dirección XXXXX.}

{
Para mayor claridad en la codificación de las instrucciones es mejor
dividir la instrucción STORE en STORE ( 110 ) y STOREX (111) para
indicar que la fuente es externa.}

{
Para entender el funcionamiento de esta instrucción consideremos el
siguiente programa:}

{\itshape
\foreignlanguage{english}{Load  regA, 0  ; regA
}\foreignlanguage{spanish}{[F0DF?]}\foreignlanguage{english}{ Reg[0]}}

{\itshape
\foreignlanguage{english}{Storex  1  ; reg1
}\foreignlanguage{spanish}{[F0DF?]}\foreignlanguage{english}{ PC+1 }}

{\itshape
\foreignlanguage{english}{Load  regB, 1  ; regB
}\foreignlanguage{spanish}{[F0DF?]}\foreignlanguage{english}{ Reg[1]}}

{\itshape
\foreignlanguage{english}{Add  ; result
}\foreignlanguage{spanish}{[F0DF?]}\foreignlanguage{english}{ regA +
regB}}

{\itshape
Store 2  ; mem[2][F0DF?] resultReg}

{
En binario el código es:}

{\itshape\color{black}
\textbf{1 0 0 0 0 0 0 0  };Carga el contenido del registro 0 en regA.}

{\itshape\color{blue}
\textbf{1 1 1 0 0 0 0 1 }\textbf{\textup{ }};Carga 10101010 (PC+1: línea
siguiente)en reg1}

{\itshape\color{blue}
\textbf{1 0 1 0 1 0 1 0  };Dato a almacenar}

{\itshape\color{black}
\textbf{1 0 1 0 0 0 0 1  };Carga el contenido del registro 1 en regB.}

{\itshape\color{black}
\textbf{0 0 0 0 0 0 0 0  };Realiza regA + regB y lo almacena en result.}

{\itshape\color{black}
\textbf{1 1 0 0 0 0 1 0  };Carga result en el registro 2.}

{
Para poder realizar estas operaciones la lógica de control debe ser
capáz de distinguir las diferentes instrucciones y actuar
consecuentemente, es decir asignar los valores lógicos adecuados para
cada función. Los pasos que se deben realizar para la lectura de una
instrucción son los siguientes:}

\begin{enumerate}
\item {
Inicializar el Contador de Programa  ( PC = Dirección base ) para leer
la primera instrucción.}
\item {
Transferir el contenido del Contador de Programa al Registro de
Dirección de Memoria ( MAR ) }
\item {
El contenido de la Memoria debe ser transferido al Registro de
Instrucción ( IR ).}
\item {
Decodificar la Instrucción y realizar las operaciones adecuadas.}
\item {
Aumentar en 1 el contenido del contador de Programa en uno y repetir el
proceso para la siguiente instrucción.}
\end{enumerate}
{\centering 
\includegraphics[width=8.941cm,height=8.941cm]{FSM-img49.png} \par}

{
La siguiente figura muestra una arquitectura que nos servirá para
realizar las operaciones de la lógica de control.  La unidad de control
es la encargada de sincronizar las tareas que deben realizarse para
ejecutar las instrucciones sobre el \textit{datapath}. }

{\centering 
\includegraphics[width=12.778cm,height=5.741cm]{FSM-img50.png} \par}

{
Implementación del \textit{Datapath}}

{
Una vez diseñada la arquitectura de nuestro computador procedemos a la
implementación de sus componentes, iniciando por el \textit{datapath};
El cual está compuesto de:}

{
ALU: Esta unidad está encargada de realizar las operaciones aritméticas
y lógicas requeridas por las instrucciones, de acuerdo a nuestro set de
instrucciones, necesitamos únicamente de la SUMA y de la RESTA ( para
set de instrucciones más complicados es necesario incluir las
operaciones necesarias tales como: Complemento, corrimientos, etc ). La
siguiente figura muestra la interfaz de la ALU.}

{\centering 
\includegraphics[width=4.948cm,height=3.942cm]{FSM-img51.png} \par}

{
Y su código correspondiente en VHDL es:}

{\itshape
\textbf{library} IEEE;}

{\itshape
\textbf{use} IEEE.STD\_LOGIC\_1164.ALL;}

{\itshape
\textbf{use} IEEE.STD\_LOGIC\_ARITH.ALL;}

{\itshape
\textbf{use} IEEE.STD\_LOGIC\_UNSIGNED.ALL;}

{\itshape
\textbf{entity} ALU \textbf{is}}

{\itshape
 \textbf{Port} ( A  : \textbf{in} std\_logic\_vector(7 \textbf{downto}
0);}

{\itshape
 B  : \textbf{in} std\_logic\_vector(7 \textbf{downto} 0);}

{\itshape
 Opera  : \textbf{in} std\_logic;}

{\itshape
 Operacion  : \textbf{in} std\_logic\_vector(1 \textbf{downto} 0);}

{\itshape
 Resultado  : \textbf{out} std\_logic\_vector(7 \textbf{downto} 0));}

{\itshape
\textbf{end} \textbf{entity} ALU;}

{\itshape
\textbf{architecture} RT \textbf{of} ALU \textbf{is}}

{\bfseries\itshape
begin}

{\itshape
 \textbf{Process} ( A, B, Opera, Operacion )}

{\itshape
 \textbf{Begin}}

{\itshape
 \textbf{If} Opera = {\textquotesingle}1{\textquotesingle}
\textbf{then}}

{\itshape
 \textbf{Case} Operacion \textbf{is}}

{\itshape
 \textbf{When} {\textquotedbl}00{\textquotedbl} ={\textgreater}  {}-{}-
Suma}

{\itshape
\foreignlanguage{english}{ }\foreignlanguage{spanish}{Resultado
{\textless}= A + B;}}

{\itshape
 \textbf{When} {\textquotedbl}01{\textquotedbl} ={\textgreater}  {}-{}-
Resta}

{\itshape
 Resultado {\textless}= A - B;}

{\itshape
\foreignlanguage{spanish}{
}\foreignlanguage{english}{\textbf{When}}\foreignlanguage{english}{
{\textquotedbl}10{\textquotedbl} ={\textgreater}  {}-{}- And logico}}

{\itshape
 Resultado {\textless}= A and B;  }

{\itshape
 \textbf{When} {\textquotedbl}11{\textquotedbl} ={\textgreater}  {}-{}-
Or logico}

{\itshape
 Resultado {\textless}= A or B;}

{\itshape
 \textbf{When} Others ={\textgreater}  {}-{}- Error}

{\itshape
 Resultado {\textless}= {\textquotedbl}XXXXXXXX{\textquotedbl};}

{\itshape
\textbf{ }\textbf{end} \textbf{case};}

{\itshape
\foreignlanguage{english}{\textbf{
}}\foreignlanguage{spanish}{\textbf{else}}\foreignlanguage{spanish}{ 
{}-{}- Si no hay operación el resultado es A}}

{\itshape
\foreignlanguage{spanish}{ }\foreignlanguage{english}{Resultado
{\textless}= A;}}

{\itshape
\textbf{ }\textbf{end} \textbf{if};}

{\itshape
 \textbf{End} \textbf{Process};}

{\itshape
\textbf{end} \textbf{architecture} RT;}

{
Banco de Registros: El banco de registro posee 4 registros de propósito
general en los que se almacenan datos provenientes de la memoria y de
resultados temporales de las operaciones. Este módulo tiene la interfaz
que se muestra en la siguiente figura.}

{\centering 
\includegraphics[width=6.456cm,height=4.366cm]{FSM-img52.png} \par}

{
Para realizar una escritura se debe colocar la señal \textit{Write} en
{\textquoteleft}1{\textquoteright} e indicar el registro destino
asignándole el valor adecuado a \textit{SelWriteReg}  y esperar un
flanco de subida en la señal del reloj. El proceso de lectura es
bastante sencillo, basta con indicar el registro a leer ( asignándole
un valor a \textit{SelReadReg} ). El código en VHDL del Banco de
Registros se muestra a continuación.}

{\itshape
\textbf{library} IEEE;}

{\itshape
\textbf{use} IEEE.STD\_LOGIC\_1164.ALL;}

{\itshape
\textbf{use} IEEE.STD\_LOGIC\_ARITH.ALL;}

{\itshape
\textbf{use} IEEE.STD\_LOGIC\_UNSIGNED.ALL;}

{\itshape
\textbf{entity} RagBank \textbf{is}}

{\itshape
 \textbf{Port} ( Clk  : \textbf{in} std\_logic;}

{\itshape
 Init  : \textbf{in} std\_logic;}

{\itshape
 DataWrite  : \textbf{in} std\_logic\_vector(7 \textbf{downto} 0);}

{\itshape
 SelWriteReg : \textbf{in} std\_logic\_vector(1 \textbf{downto} 0);}

{\itshape
 Write  : \textbf{in} std\_logic;}

{\itshape
 SelReadReg  : \textbf{in} std\_logic\_vector(1 \textbf{downto} 0);}

{\itshape
 DataRead  : \textbf{out} std\_logic\_vector(7 \textbf{downto} 0));}

{\itshape
\textbf{end} RagBank;}

{\itshape
\textbf{architecture} RT \textbf{of} RagBank \textbf{is}}

{\bfseries\itshape
begin}

{\itshape
 \textbf{Process}(Clk, Init, Write)}

{\itshape
 \textbf{type} RegBank \textbf{is} \textbf{array} ( 0 \textbf{to} 3 )
\textbf{of} std\_logic\_vector( 7 \textbf{downto} 0 );  }

{\itshape
 \textbf{variable} Registers: RegBank;}

{\itshape
 \textbf{Begin }}

{\itshape
 \textbf{If} Init = {\textquotesingle}1{\textquotesingle} \textbf{then}}

{\itshape
 \textbf{for} i \textbf{in} 0 \textbf{to} 3 loop}

{\itshape
 Registers( i ) := {\textquotedbl}00000000{\textquotedbl};}

{\itshape
 \textbf{end} \textbf{loop};}

{\itshape
 \textbf{elsif} Write = {\textquotesingle}1{\textquotesingle}
\textbf{then}}

{\itshape
 \textbf{if} Clk\textbf{{\textquotesingle}event} \textbf{and} clk =
{\textquotesingle}1{\textquotesingle} \textbf{then}}

{\itshape
 Registers( conv\_integer( SelWriteReg ) ) := DataWrite;}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 DataRead {\textless}= Registers( conv\_integer( SelReadReg ) );}

{\itshape
 \textbf{End} \textbf{Process};}

{\itshape
\textbf{end} RT;}

{
Nótese que se utilizó la función \textit{conv\_integer} la cual
convierte a entero un valor dado en \textit{std\_logic\_vector}, esto
se debe hacer ya que el subíndice de un arreglo debe ser de tipo
entero.}

{
Registros A, B y de salida: Estos registros están encargados de
almacenar los operandos y el resultados de las operaciones de la ALU.
Su interfaz se muestra en la siguiente figura.}

{\centering 
\includegraphics[width=6.006cm,height=3.916cm]{FSM-img53.png} \par}

{\itshape
El código en VHDL de este registro es el siguiente:}

{\itshape
\textbf{library} IEEE;}

{\itshape
\textbf{use} IEEE.STD\_LOGIC\_1164.ALL;}

{\itshape
\textbf{use} IEEE.STD\_LOGIC\_ARITH.ALL;}

{\itshape
\textbf{use} IEEE.STD\_LOGIC\_UNSIGNED.ALL;}

{\itshape
\textbf{entity} Reg \textbf{is}}

{\itshape
 \textbf{Port} ( Clk  : \textbf{in} std\_logic;}

{\itshape
 INR  : \textbf{in} std\_logic\_vector(7 \textbf{downto} 0);}

{\itshape
 Reset : \textbf{in} std\_logic;}

{\itshape
 Load  : \textbf{in} std\_logic;}

{\itshape
 OUTR  : \textbf{out} std\_logic\_vector(7 \textbf{downto} 0));}

{\itshape
\textbf{end} Reg;}

{\itshape
\textbf{architecture} RT \textbf{of} Reg \textbf{is}}

{\bfseries\itshape
begin}

{\itshape
 \textbf{Process}( clk, load, reset )}

{\itshape
 \textbf{Begin}}

{\itshape
 \textbf{if} Reset = {\textquotesingle}1{\textquotesingle}
\textbf{then}}

{\itshape
 OUTR {\textless}= {\textquotedbl}00000000{\textquotedbl};}

{\itshape
 \textbf{else}}

{\itshape
 \textbf{if} clk\textbf{{\textquotesingle}event} \textbf{and} clk =
{\textquotesingle}1{\textquotesingle} \textbf{then}}

{\itshape
 \textbf{if} load = {\textquotesingle}1{\textquotesingle} \textbf{then}}

{\itshape
 OUTR {\textless}= INR;}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{End} \textbf{Process};}

{\itshape
\textbf{end} \textbf{RT};}

{
Implementación de la lógica de control:}

{
Contador de Programa: El contador de programa está encargado de mantener
la dorección de memoria donde se encuentra la última instrucción
ejecutada.}

{\centering 
\includegraphics[width=7.645cm,height=1.799cm]{FSM-img54.png} \par}

{
El código en VHDL del Contador de Programa es el siguiente:}

{\itshape
\textbf{library} IEEE;}

{\itshape
\textbf{use} IEEE.STD\_LOGIC\_1164.ALL;}

{\itshape
\textbf{use} IEEE.STD\_LOGIC\_ARITH.ALL;}

{\itshape
\textbf{use} IEEE.STD\_LOGIC\_UNSIGNED.ALL;}

{\itshape
\textbf{entity} ProgCount is}

{\itshape
 \textbf{Port} ( Clk  : in std\_logic;}

{\itshape
 Reset : in std\_logic;}

{\itshape
 IncCP : in std\_logic;}

{\itshape
 OutCP : buffer std\_logic\_vector(7 downto 0));}

{\itshape
\textbf{end }ProgCount;}

{\itshape
\textbf{architecture} Behavioral of ProgCount is}

{\bfseries\itshape
begin}

{\itshape
 \textbf{Process}( Clk, Reset, IncCP )}

{\itshape
 \textbf{Begin}}

{\itshape
 \textbf{if} Reset = {\textquotesingle}1{\textquotesingle} \textbf{then}
}

{\itshape
 OutCP {\textless}= {\textquotedbl}00000000{\textquotedbl};}

{\itshape
 \textbf{else}}

{\itshape
 \textbf{if} IncCP = {\textquotesingle}1{\textquotesingle}
\textbf{then}}

{\itshape
 \textbf{if} clk\textbf{{\textquotesingle}event} \textbf{and} clk =
{\textquotesingle}1{\textquotesingle} \textbf{then}}

{\itshape
 OutCP {\textless}= OutCP + {\textquotedbl}00000001{\textquotedbl};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{else}}

{\itshape
 OutCP {\textless}= OutCP;}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{end} \textbf{if};}

{\itshape
 \textbf{End} \textbf{Process};}

{\itshape
\textbf{end} Behavioral;}

{
Registro de Instrucciones Decodificador y Unidad de Control: Estos
módulos están encargados de realizar todas las microinstrucciones
necesarias para realizar las instrucciones. Este módulo tiene la
interfaz mostrada en la siguiente figura.}

{\centering 
\includegraphics[width=9.47cm,height=7.063cm]{FSM-img55.png} \par}

{
Y el código en VHDL de la lógica de control se muestra a continuación.}

{\itshape
library IEEE;}

{\itshape
use IEEE.STD\_LOGIC\_1164.ALL;}

{\itshape
use IEEE.STD\_LOGIC\_ARITH.ALL;}

{\itshape
use IEEE.STD\_LOGIC\_UNSIGNED.ALL;}

{\itshape
entity LogControl is}

{\itshape
 Port ( -{}- }

{\itshape
 Clk  : in std\_logic;}

{\itshape
 SysReset  : in std\_logic;}

{\itshape
\ \   {}-{}- Memory Interface}

{\itshape
 DataMem  : in std\_logic\_vector(7 downto 0);}

{\itshape
 {}-{}- Specific Register Control}

{\itshape
 LoadA  : out std\_logic;}

{\itshape
 LoadB  : out std\_logic;}

{\itshape
 LoadResult  : out std\_logic;}

{\itshape
 LoadMAR  : out std\_logic;}

{\itshape
 IncCP  : out std\_logic;}

{\itshape
 Erase  : out std\_logic;}

{\itshape
 {}-{}- ALU Control}

{\itshape
 Operate  : out std\_logic;}

{\itshape
 Operation  : out std\_logic\_vector(1 downto 0);}

{\itshape
 {}-{}- Register Bank Control}

{\itshape
 SelReadReg  : out std\_logic\_vector(1 downto 0);}

{\itshape
 SelWriteReg : out std\_logic\_vector(1 downto 0);}

{\itshape
 Write  : out std\_logic);}

{\itshape
end LogControl;}

{\itshape
architecture Behavioral of LogControl is}

{\itshape
 type state\_type is ( ResetPC, Fetch, Decode, PCOperation, IncrementPC
);}

{\itshape
 Signal State : State\_type;}

{\itshape
 type Operation\_type is ( OPAdd, OPSub, OPLoad, OPStore, OPStorex );}

{\itshape
 Signal Oper  : Operation\_type;}

{\itshape
 Signal IR  : std\_logic\_vector( 7 downto 0 );}

{\itshape
 type Inter\_type is ( onein, twoin, threein );}

{\itshape
 Signal Inter : Inter\_type;}

{\itshape
begin}

{\itshape
 Process ( Clk, SysReset )}

{\itshape
 Begin}

{\itshape
 if SysReset = {\textquotesingle}1{\textquotesingle} then}

{\itshape
 state {\textless}= ResetPC;}

{\itshape
\ \ \ \ Inter {\textless}= onein;}

{\itshape
 else}

{\itshape
 if ( Clk{\textquotesingle}event and Clk =
{\textquotesingle}1{\textquotesingle} ) then}

{\itshape
 Case State is}

{\itshape
 when ResetPC ={\textgreater}}

{\itshape
\foreignlanguage{english}{ }Erase  {\textless}=
{\textquotesingle}1{\textquotesingle}; LoadA  {\textless}=
{\textquotesingle}0{\textquotesingle};}

{\itshape
 \foreignlanguage{english}{LoadB  {\textless}=
{\textquotesingle}0{\textquotesingle}; LoadResult {\textless}=
{\textquotesingle}0{\textquotesingle};}}

{\itshape
 IncCp  {\textless}= {\textquotesingle}0{\textquotesingle}; Operate 
{\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 Write  {\textless}= {\textquotesingle}0{\textquotesingle}; LoadMAR 
{\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 State  {\textless}= Fetch;}

{\itshape
 when Fetch  ={\textgreater}}

{\itshape
\foreignlanguage{english}{ }Erase  {\textless}=
{\textquotesingle}0{\textquotesingle}; LoadA  {\textless}=
{\textquotesingle}0{\textquotesingle};}

{\itshape
 \foreignlanguage{english}{LoadB  {\textless}=
{\textquotesingle}0{\textquotesingle}; LoadResult {\textless}=
{\textquotesingle}0{\textquotesingle};}}

{\itshape
 IncCp  {\textless}= {\textquotesingle}0{\textquotesingle}; Operate 
{\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 Write  {\textless}= {\textquotesingle}0{\textquotesingle}; LoadMAR 
{\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 state  {\textless}= Decode;}

{\itshape
 IR  {\textless}= DataMem;}

{\itshape
 when Decode  ={\textgreater}}

{\itshape
\foreignlanguage{english}{ }Erase  {\textless}=
{\textquotesingle}0{\textquotesingle}; LoadA  {\textless}=
{\textquotesingle}0{\textquotesingle};}

{\itshape
 \foreignlanguage{english}{LoadB  {\textless}=
{\textquotesingle}0{\textquotesingle}; LoadResult {\textless}=
{\textquotesingle}0{\textquotesingle};}}

{\itshape
 IncCp  {\textless}= {\textquotesingle}0{\textquotesingle}; Operate 
{\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 Write  {\textless}= {\textquotesingle}0{\textquotesingle}; LoadMAR 
{\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 Case IR( 7 downto 5 ) is}

{\itshape
 when {\textquotedbl}00X{\textquotedbl} ={\textgreater}}

{\itshape
\ \ \ \ \ \ \ \   Oper {\textless}= OPAdd;}

{\itshape
 when {\textquotedbl}01X{\textquotedbl} ={\textgreater}}

{\itshape
\ \ \ \ \ \ \ \   Oper {\textless}= OPSub;}

{\itshape
 when {\textquotedbl}10X{\textquotedbl} ={\textgreater}}

{\itshape
\ \ \ \ \ \ \ \   Oper {\textless}= OPLoad;}

{\itshape
 when {\textquotedbl}110{\textquotedbl} ={\textgreater}}

{\itshape
\ \ \ \ \ \ \ \   Oper {\textless}= OPStore;}

{\itshape
 when {\textquotedbl}111{\textquotedbl} ={\textgreater}}

{\itshape
\ \ \ \ \ \ \ \   Oper {\textless}= OPStorex;}

{\itshape
 when others ={\textgreater}}

{\itshape
 end case;}

{\itshape
 State {\textless}= PCOperation;}

{\itshape
 Inter {\textless}= onein;}

{\itshape
 when PCOperation ={\textgreater}}

{\itshape
 Case Oper is}

{\itshape
 when OPAdd={\textgreater}}

{\itshape
 Erase  {\textless}= {\textquotesingle}0{\textquotesingle}; LoadA 
{\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 LoadB  {\textless}= {\textquotesingle}0{\textquotesingle}; LoadResult
{\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 IncCp  {\textless}= {\textquotesingle}0{\textquotesingle}; Operate 
{\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 Write  {\textless}= {\textquotesingle}0{\textquotesingle}; LoadMAR 
{\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 Operation {\textless}= {\textquotedbl}00{\textquotedbl};}

{\itshape
 State {\textless}= IncrementPC;}

{\itshape
 when OPSub={\textgreater}}

{\itshape
 Erase  {\textless}= {\textquotesingle}0{\textquotesingle}; LoadA 
{\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 LoadB  {\textless}= {\textquotesingle}0{\textquotesingle}; LoadResult
{\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 IncCp  {\textless}= {\textquotesingle}0{\textquotesingle}; Operate 
{\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 Write  {\textless}= {\textquotesingle}0{\textquotesingle}; LoadMAR 
{\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 Operation {\textless}= {\textquotedbl}01{\textquotedbl};}

{\itshape
 State {\textless}= IncrementPC;}

{\itshape
 when OPLoad ={\textgreater}}

{\itshape
 Erase  {\textless}= {\textquotesingle}0{\textquotesingle}; LoadResult
{\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 IncCp  {\textless}= {\textquotesingle}0{\textquotesingle}; Operate 
{\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 Write  {\textless}= {\textquotesingle}0{\textquotesingle}; LoadMAR 
{\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 Case Inter is}

{\itshape
 when onein ={\textgreater}}

{\itshape
 SelReadReg {\textless}= IR( 1 downto 0 );}

{\itshape
 Inter {\textless}= twoin;}

{\itshape
 when twoin ={\textgreater}}

{\itshape
 if IR( 5 ) = {\textquotesingle}1{\textquotesingle} then}

{\itshape
 LoadB {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 LoadA {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 else}

{\itshape
 LoadB {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 LoadA {\textless}= {\textquotesingle}1{\textquotesingle};  }

{\itshape
 end if;}

{\itshape
 Inter {\textless}= threein;}

{\itshape
 when threein ={\textgreater}}

{\itshape
 LoadB {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 LoadA {\textless}= {\textquotesingle}1{\textquotesingle};  }

{\itshape
 State {\textless}= IncrementPC;}

{\itshape
 Inter {\textless}= onein;}

{\itshape
 End Case;  }

{\itshape
 \ \   when OPStore={\textgreater}}

{\itshape
\foreignlanguage{english}{ }Erase  {\textless}=
{\textquotesingle}0{\textquotesingle}; LoadA  {\textless}=
{\textquotesingle}0{\textquotesingle};}

{\itshape
 \foreignlanguage{english}{LoadB  {\textless}=
{\textquotesingle}0{\textquotesingle}; LoadResult {\textless}=
{\textquotesingle}0{\textquotesingle};}}

{\itshape
 IncCp  {\textless}= {\textquotesingle}0{\textquotesingle}; Operate 
{\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 Write  {\textless}= {\textquotesingle}0{\textquotesingle}; LoadMAR 
{\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 Case Inter is}

{\itshape
 when onein ={\textgreater}}

{\itshape
 SelWriteReg {\textless}= IR( 1 downto 0 );}

{\itshape
 write {\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 Inter {\textless}= twoin;}

{\itshape
 when twoin ={\textgreater}}

{\itshape
 Write {\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 State {\textless}= IncrementPC;}

{\itshape
 Inter {\textless}= onein;}

{\itshape
 when others ={\textgreater}}

{\itshape
 Inter {\textless}= onein;}

{\itshape
 End Case;}

{\itshape
\foreignlanguage{english}{ }when OPStorex={\textgreater}}

{\itshape
 Erase  {\textless}= {\textquotesingle}0{\textquotesingle}; LoadA 
{\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 \foreignlanguage{english}{LoadB  {\textless}=
{\textquotesingle}0{\textquotesingle}; LoadResult {\textless}=
{\textquotesingle}0{\textquotesingle};}}

{\itshape
 IncCp  {\textless}= {\textquotesingle}0{\textquotesingle}; Operate 
{\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 Write  {\textless}= {\textquotesingle}0{\textquotesingle}; LoadMAR 
{\textless}= {\textquotesingle}0{\textquotesingle};  }

{\itshape
 end case;}

{\itshape
 when IncrementPC ={\textgreater}}

{\itshape
\foreignlanguage{english}{ }Erase  {\textless}=
{\textquotesingle}0{\textquotesingle}; LoadA  {\textless}=
{\textquotesingle}0{\textquotesingle};}

{\itshape
 \foreignlanguage{english}{LoadB  {\textless}=
{\textquotesingle}0{\textquotesingle}; LoadResult {\textless}=
{\textquotesingle}0{\textquotesingle};}}

{\itshape
 IncCp  {\textless}= {\textquotesingle}1{\textquotesingle}; Operate 
{\textless}= {\textquotesingle}0{\textquotesingle};}

{\itshape
 Write  {\textless}= {\textquotesingle}0{\textquotesingle}; LoadMAR 
{\textless}= {\textquotesingle}1{\textquotesingle};}

{\itshape
 state  {\textless}= Fetch;}

{\itshape
 end case;}

{\itshape
 end if;  }

{\itshape
 end if;}

{\itshape
 end Process;}

{\itshape
end Behavioral;}

\subsection{EJERCICIOS}
\begin{enumerate}
\item {
Escribir el código en VHDL de la máquina de estados representada por el
siguiente diagrama:}
\end{enumerate}
{\centering 
\includegraphics[width=5.946cm,height=10.918cm]{FSM-img56.png} \par}

\begin{enumerate}
\item {
En un estacionamiento se cuenta con dos sensores que deben detectar el
ingreso o salida de vehículos. Cuando un vehículo se encuentra frente a
uno de los sensores genera un nivel lógico
{\textquoteleft}1{\textquoteright}. En la siguiente figura se muestra
el diagrama de tiempos de las señales generadas por los sensores al
entrar y al salir un vehículo.}
\end{enumerate}
{\centering 
\includegraphics[width=12.928cm,height=6.606cm]{FSM-img57.png} \par}

{
El sistema debe entregar dos señales UP y DOWN las cuales se colocan en
un nivel lógico alto cuando se detecta la secuencia completa de entrada
y salida de un automóvil respectivamente. }

{
3. Diseñar el decodificador del teclado matricial que se muestra en la
siguiente figura. Cuando no se tiene ninguna tecla presionada, en las
entradas R0 a R3 se tiene una lectura de
{\textquotedblleft}0000{\textquotedblright}. Si por ejemplo se presiona
la tecla superior izquierda, se recibirá un
{\textquoteleft}1{\textquoteright} lógico en R0 cuando la secuencia de
las columnas C0 a C3 sea {\textquotedblleft}1000{\textquotedblright}.
Por lo tanto un valor lógico alto en las entradas R0 a R3 indica la
fila de la tecla oprimida, pero no sabemos cual de las cuatro teclas de
la fila está presionada. Para averiguarlo debemos colocar un
{\textquoteleft}1{\textquoteright} lógico en solo una de las columnas y
rotarlo por todas ellas. R0 será igual a
{\textquoteleft}1{\textquoteright} sólo cuando se coloque el
{\textquoteleft}1{\textquoteright} lógico en la columna de la tecla
oprimida y {\textquoteleft}0{\textquoteright} en los otros casos.}

{\centering 
\includegraphics[width=9.206cm,height=8.227cm]{FSM-img58.png} \par}

{
Una vez detectada la tecla oprimida el decodificador debe generar un
código único para cada una de ellas y debe indicar el evento haciendo
\textit{key\_press = {\textquoteleft}1{\textquoteright}}.}

\begin{enumerate}
\item {
Diseñar el sistema de control de los semáforos de un cruce de
vehículos.}
\end{enumerate}
{\centering 
\includegraphics[width=12.266cm,height=6.682cm]{FSM-img59.png} \par}

\begin{enumerate}
\item {
Diseñar un sistema que sea capáz de generar caracteres ASCII en un
monitor VGA. Una trama de video VGA está compuesta por  480 líneas de
640 pixels. El monitor cuenta con las siguientes señales de control:}
\end{enumerate}
\begin{enumerate}
\item \begin{itemize}
\item {
Red, Green, Blue : Entradas de señal análoga de color, estas entradas
tienen un rango de 0 a 0.7 V}
\item {
Sincronismo Horizontal : Indica el principio y fín de cada línea de
video ( 480 líneas ).}
\item {
Sincronismo Vertical : Indica el principio y fin de cada trama de
video.}
\end{itemize}
\end{enumerate}
{
El flanco de bajada de la señal de sincronismo horizontal indica el
inicio de la línea y al colocar en alto esta señal se asegura que la
información contenida en la línea de video (Red, Green, Blue ) se
despliegue en la parte visible de la pantalla. En la siguiente figura
puede verse la forma de onda y el diagrama de tiempos de esta señal.}

{\centering 
\includegraphics[width=8.98cm,height=8.419cm]{FSM-img60.png} \par}

{
De igual forma el flanco de bajada en la señal de sincronismo vertical
indica el inicio y fin de la trama de video formada por 480 líneas.
Como puede verse en la figura anterior una línea tiene una duración de
31.77 us y las 480 líneas tiene una duración de 31.77 us x 480 = 15.25
ms. }

{
En la siguiente figura se ilustra el funcionamiento del monitor VGA y se
indican las zonas no visibles de la pantalla.}

{\centering 
\includegraphics[width=11.368cm,height=11.501cm]{FSM-img61.png} \par}

\begin{enumerate}
\item {
Diseñar el control de un display inteligente. Este display tiene como
elemento de visualización una matriz de leds de 7x5. Se desea
visualizar los caracteres ASCII desde el 20H {\textquoteleft}
{\textquoteleft} hasta el 7EH {\textquoteleft} \~{} {\textquoteright}.
La siguiente figura muestra el diagrama de bloques propuesto.}
\end{enumerate}
{\centering 
\includegraphics[width=7.327cm,height=5.662cm]{FSM-img62.png} \par}

{
Debido a que los dispositivos lógicos programables no pueden suministrar
la corriente necesaria para manejar los leds, es necesario utilizar el
siguiente circuito para manejar la matriz:}

{\centering 
\includegraphics[width=9.035cm,height=11.335cm]{FSM-img63.png} \par}

{
El contenido de la memoria debe ser el siguiente:}

{\centering\bfseries
{\textquotesingle} {\textquotesingle}000h,000h,000h,000h,000h
\par}

{\centering\bfseries
{\textquotesingle}!{\textquotesingle}000h,000h,0FAh,000h,000h
\par}

{\centering\bfseries
{\textquotesingle}{\textquotedbl}{\textquotesingle}000h,0E0h,000h,0E0h,000h
\par}

{\centering\bfseries
{\textquotesingle}\#{\textquotesingle}044h,0FEh,044h,0FEh,044h
\par}

{\centering\bfseries
{\textquotesingle}\${\textquotesingle}048h,054h,0FEh,054h,024h
\par}

{\centering\bfseries
{\textquotesingle}\%{\textquotesingle}046h,026h,010h,0C8h,0C4h
\par}

{\centering\bfseries
{\textquotesingle}\&{\textquotesingle}00Ah,044h,0AAh,092h,06Ch
\par}

{\centering\bfseries
{\textquotesingle}{\textquotesingle}{\textquotesingle}000h,0C0h,0A0h,000h,000h
\par}

{\centering\bfseries
{\textquotesingle}({\textquotesingle}000h,082h,044h,038h,000h
\par}

{\centering\bfseries
{\textquotesingle}){\textquotesingle}000h,038h,044h,082h,000h
\par}

{\centering\bfseries
{\textquotesingle}*{\textquotesingle}028h,010h,07Ch,010h,028h
\par}

{\centering\bfseries
{\textquotesingle}+{\textquotesingle}010h,010h,07Ch,010h,010h
\par}

{\centering\bfseries
{\textquotesingle},{\textquotesingle}000h,00Ch,00Ah,000h,000h
\par}

{\centering\bfseries
{\textquotesingle}-{\textquotesingle}010h,010h,010h,010h,010h
\par}

{\centering\bfseries
{\textquotesingle}.{\textquotesingle}000h,006h,006h,000h,000h
\par}

{\centering\bfseries
{\textquotesingle}/{\textquotesingle}040h,020h,010h,008h,004h
\par}

{\centering\bfseries
{\textquotesingle}0{\textquotesingle}07Ch,0A2h,092h,08Ah,07Ch
\par}

{\centering\bfseries
{\textquotesingle}1{\textquotesingle}000h,002h,0FEh,042h,000h
\par}

{\centering\bfseries
{\textquotesingle}2{\textquotesingle}062h,092h,08Ah,086h,042h
\par}

{\centering\bfseries
{\textquotesingle}3{\textquotesingle}05Ch,0A2h,0A2h,082h,044h
\par}

{\centering\bfseries
{\textquotesingle}4{\textquotesingle}008h,0FEh,048h,028h,018h
\par}

{\centering\bfseries
{\textquotesingle}5{\textquotesingle}09Ch,0A2h,0A2h,0A2h,0E4h
\par}

{\centering\bfseries
{\textquotesingle}6{\textquotesingle}04Ch,092h,092h,092h,07Ch
\par}

{\centering\bfseries
{\textquotesingle}7{\textquotesingle}0C0h,0A0h,090h,08Eh,080h
\par}

{\centering\bfseries
{\textquotesingle}8{\textquotesingle}06Ch,092h,092h,092h,06Ch
\par}

{\centering\bfseries
{\textquotesingle}9{\textquotesingle}07Ch,092h,092h,092h,064h
\par}

{\centering\bfseries
{\textquotesingle}:{\textquotesingle}000h,06Ch,06Ch,000h,000h
\par}

{\centering\bfseries
{\textquotesingle};{\textquotesingle}000h,06Ch,06Ah,000h,000h
\par}

{\centering\bfseries
{\textquotesingle}{\textless}{\textquotesingle}082h,044h,028h,010h,000h
\par}

{\centering\bfseries
{\textquotesingle}={\textquotesingle}014h,014h,014h,014h,014h
\par}

{\centering\bfseries
{\textquotesingle}{\textgreater}{\textquotesingle}010h,028h,044h,082h,000h
\par}

{\centering\bfseries
{\textquotesingle}?{\textquotesingle}060h,090h,08Ah,080h,040h
\par}

{\centering\bfseries
{\textquotesingle}@{\textquotesingle}07Ch,082h,09Eh,092h,04Ch
\par}

{\centering\bfseries
{\textquotesingle}A{\textquotesingle}03Eh,048h,088h,048h,03Eh
\par}

{\centering\bfseries
{\textquotesingle}B{\textquotesingle}06Ch,092h,092h,092h,0FEh
\par}

{\centering\bfseries
{\textquotesingle}C{\textquotesingle}044h,082h,082h,082h,07Ch
\par}

{\centering\bfseries
{\textquotesingle}D{\textquotesingle}07Ch,082h,082h,082h,0FEh
\par}

{\centering\bfseries
{\textquotesingle}E{\textquotesingle}082h,082h,092h,092h,0FEh
\par}

{\centering\bfseries
{\textquotesingle}F{\textquotesingle}080h,090h,090h,090h,0FEh
\par}

{\centering\bfseries
{\textquotesingle}G{\textquotesingle}05Eh,092h,092h,082h,07Ch
\par}

{\centering\bfseries
{\textquotesingle}H{\textquotesingle}0FEh,010h,010h,010h,0FEh
\par}

{\centering\bfseries
{\textquotesingle}I{\textquotesingle}000h,082h,0FEh,082h,000h
\par}

{\centering\bfseries
{\textquotesingle}J{\textquotesingle}080h,0FCh,082h,002h,004h
\par}

{\centering\bfseries
{\textquotesingle}K{\textquotesingle}082h,044h,028h,010h,0FEh
\par}

{\centering\bfseries
{\textquotesingle}L{\textquotesingle}002h,002h,002h,002h,0FEh
\par}

{\centering\bfseries
{\textquotesingle}M{\textquotesingle}0FEh,040h,030h,040h,0FEh
\par}

{\centering\bfseries
{\textquotesingle}N{\textquotesingle}0FEh,008h,010h,020h,0FEh
\par}

{\centering\bfseries
{\textquotesingle}O{\textquotesingle}07Ch,082h,082h,082h,07Ch
\par}

{\centering\bfseries
{\textquotesingle}P{\textquotesingle}060h,090h,090h,090h,0FEh
\par}

{\centering\bfseries
{\textquotesingle}Q{\textquotesingle}07Ah,084h,08Ah,082h,07Ch
\par}

{\centering\bfseries
{\textquotesingle}R{\textquotesingle}062h,094h,098h,090h,0FEh
\par}

{\centering\bfseries
{\textquotesingle}S{\textquotesingle}04Ch,092h,092h,092h,064h
\par}

{\centering\bfseries
{\textquotesingle}T{\textquotesingle}080h,080h,0FEh,080h,080h
\par}

{\centering\bfseries
{\textquotesingle}U{\textquotesingle}0FCh,002h,002h,002h,0FCh
\par}

{\centering\bfseries
{\textquotesingle}V{\textquotesingle}0F8h,004h,002h,004h,0F8h
\par}

{\centering\bfseries
{\textquotesingle}W{\textquotesingle}0FCh,002h,01Ch,002h,0FCh
\par}

{\centering\bfseries
{\textquotesingle}X{\textquotesingle}0C6h,028h,010h,028h,0C6h
\par}

{\centering\bfseries
{\textquotesingle}Y{\textquotesingle}0E0h,010h,00Eh,010h,0E0h
\par}

{\centering\bfseries
{\textquotesingle}Z{\textquotesingle}0C2h,0A2h,092h,08Ah,086h
\par}

{\centering\bfseries
{\textquotesingle}[{\textquotesingle}000h,082h,082h,0FEh,000h
\par}

{\centering\bfseries
{\textquotesingle}{\textbackslash}{\textquotesingle}004h,008h,010h,020h,040h
\par}

{\centering\bfseries
{\textquotesingle}]{\textquotesingle}000h,0FEh,082h,082h,000h
\par}

{\centering\bfseries
{\textquotesingle}\^{}{\textquotesingle}020h,040h,080h,040h,020h
\par}

{\centering\bfseries
{\textquotesingle}\_{\textquotesingle}002h,002h,002h,002h,002h
\par}

{\centering\bfseries
{\textquotesingle}´{\textquotesingle}000h,020h,040h,080h,000h
\par}

{\centering\bfseries
{\textquotesingle}a{\textquotesingle}01Eh,02Ah,02Ah,02Ah,004h
\par}

{\centering\bfseries
{\textquotesingle}b{\textquotesingle}01Ch,022h,022h,012h,0FEh
\par}

{\centering\bfseries
{\textquotesingle}c{\textquotesingle}004h,022h,022h,022h,01Ch
\par}

{\centering\bfseries
{\textquotesingle}d{\textquotesingle}0FEh,012h,022h,022h,01Ch
\par}

{\centering\bfseries
{\textquotesingle}e{\textquotesingle}018h,02Ah,02Ah,02Ah,01Ch
\par}

{\centering\bfseries
{\textquotesingle}f{\textquotesingle}040h,080h,090h,07Eh,010h
\par}

{\centering\bfseries
{\textquotesingle}g{\textquotesingle}07Ch,04Ah,04Ah,04Ah,030h
\par}

{\centering\bfseries
{\textquotesingle}h{\textquotesingle}01Eh,020h,020h,010h,0FEh
\par}

{\centering\bfseries
{\textquotesingle}i{\textquotesingle}000h,002h,0BEh,022h,000h
\par}

{\centering\bfseries
{\textquotesingle}j{\textquotesingle}000h,0BCh,022h,002h,004h
\par}

{\centering\bfseries
{\textquotesingle}k{\textquotesingle}000h,022h,014h,008h,0FEh
\par}

{\centering\bfseries
{\textquotesingle}l{\textquotesingle}000h,002h,0FEh,082h,000h
\par}

{\centering\bfseries
{\textquotesingle}m{\textquotesingle}01Eh,020h,018h,020h,03Eh
\par}

{\centering\bfseries
{\textquotesingle}n{\textquotesingle}01Eh,020h,020h,010h,03Eh
\par}

{\centering\bfseries
{\textquotesingle}o{\textquotesingle}01Ch,022h,022h,022h,01Ch
\par}

{\centering\bfseries
{\textquotesingle}p{\textquotesingle}020h,050h,050h,050h,07Eh
\par}

{\centering\bfseries
{\textquotesingle}q{\textquotesingle}07Eh,030h,050h,050h,020h
\par}

{\centering\bfseries
{\textquotesingle}r{\textquotesingle}010h,020h,020h,010h,03Eh
\par}

{\centering\bfseries
{\textquotesingle}s{\textquotesingle}004h,02Ah,02Ah,02Ah,012h
\par}

{\centering\bfseries
{\textquotesingle}t{\textquotesingle}004h,002h,012h,07Ch,010h
\par}

{\centering\bfseries
{\textquotesingle}u{\textquotesingle}03Eh,004h,002h,002h,03Ch
\par}

{\centering\bfseries
{\textquotesingle}v{\textquotesingle}038h,004h,002h,004h,038h
\par}

{\centering\bfseries
{\textquotesingle}w{\textquotesingle}03Ch,002h,00Ch,002h,03Ch
\par}

{\centering\bfseries
{\textquotesingle}x{\textquotesingle}022h,014h,008h,014h,022h
\par}

{\centering\bfseries
{\textquotesingle}y{\textquotesingle}03Ch,00Ah,00Ah,00Ah,030h
\par}

{\centering\bfseries
{\textquotesingle}z{\textquotesingle}022h,032h,02Ah,026h,022h
\par}

{\centering\bfseries
{\textquotesingle}\{{\textquotesingle}082h,082h,06Ch,010h,000h
\par}

{\centering\bfseries
{\textquotesingle}{\textbar}{\textquotesingle}000h,000h,0FEh,000h,000h
\par}

{\centering\bfseries
{\textquotesingle}\}{\textquotesingle}000h,010h,06Ch,082h,082h
\par}

{\centering\bfseries
{\textquotesingle}\~{}{\textquotesingle}080h,040h,0C0h,080h,040h
\par}

\begin{enumerate}
\item {
Se desea diseñar un display formado por 5 matrices de Leds de 7x5 que
sea capáz de almacenar mensajes de 70 caracteres. El mensaje a
desplegar debe ser introducido via serial o por medio de un teclado.}
\end{enumerate}
\begin{enumerate}
\item {
Diseñar un circuito que permita detectar la tecla oprimida en un
teclado:}
\end{enumerate}
{
 Cada vez que se oprime una tecla en in teclado IBM el teclado envía un
código, este código es único para cada tecla. Por ejemplo si se oprime
la tecla {\textquoteleft}A{\textquoteright} se enviará el código 1CH.
Si se mantiene oprimida esta tecla el código se envía contínuamenta
hasta que se suelte o se oprima otra tecla. Cuando se suelta una tecla
el teclado envía el código F0H para indicar que se liberó una tecla y a
continuación envía el código de la tecla liberada en nuestro ejemplo
cuando se libera la tecla {\textquoteleft}A{\textquoteright} el teclado
envía los códigos F0H 1CH.}

{
El teclado siempre envía el mismo código para cada letra, por lo tanto
se debe tener en cuenta que cada vez que se oprima la tecla
{\textquoteleft}SHIFT{\textquoteright} la siguiente letra debe
cambiarse de mayúsculas a minúsculas o viceversa. También se debe tener
en cuenta el estado de la tecla {\textquoteleft}CAPS{\textquoteright}.}

{
\textbf{Host Commands} }

[Warning: Draw object ignored]

\begin{center}
\tablehead{}
\begin{supertabular}{m{0.521cm}m{11.205cm}}
\bfseries ED &
\bfseries Set Status LED{\textquotesingle}s -
This command can be used to turn on and off the Num Lock, Caps Lock \&
Scroll Lock LED{\textquotesingle}s. After Sending ED, keyboard will
reply with ACK (FA) and wait for another byte which determines their
Status. Bit 0 controls the Scroll Lock, Bit 1 the Num Lock and Bit 2
the Caps lock. Bits 3 to 7 are ignored.~\\
 &
\\
 EE &
 Echo - Upon sending a Echo command to the
Keyboard, the keyboard should reply with a Echo (EE)\\
 &
\\
\bfseries F0 &
\bfseries Set Scan Code Set. Upon Sending F0,
keyboard will reply with ACK (FA) and wait for another byte, 01-03
which determines the Scan Code Used. Sending 00 as the second byte will
return the Scan Code Set currently in Use~\\
 &
\\
 F3 &
 Set Typematic Repeat Rate. Keyboard will
Acknowledge command with FA and wait for second byte, which determines
the Typematic Repeat Rate.\\
 &
\\
\bfseries F4 &
\bfseries Keyboard Enable - Clears the keyboards
output buffer, enables Keyboard Scanning and returns an
Acknowledgment.\\
 &
\\
 F5 &
 Keyboard Disable - Resets the keyboard,
disables Keyboard Scanning and returns an Acknowledgment.\\
 &
\\
\bfseries FE &
\bfseries Resend - Upon receipt of the resend
command the keyboard will re- transmit the last byte sent.\\
 &
\\
 FF &
 Reset - Resets the Keyboard.\\
\end{supertabular}
\end{center}
{
\textbf{Commands} }

[Warning: Draw object ignored]

{
Now if the Host Commands are send from the host to the keyboard, then
the keyboard commands must be sent from the keyboard to host. If you
think this way, you must be correct. Below details some of the commands
which the keyboard can send. }

\begin{center}
\tablehead{}
\begin{supertabular}{m{0.544cm}m{11.182cm}}
\bfseries FA &
\bfseries Acknowledge\\
 &
\\
 AA &
 Power On Self Test Passed (BAT Completed)\\
 &
\\
\bfseries EE &
\bfseries See Echo Command (Host Commands)\\
 &
\\
 FE &
 Resend - Upon receipt of the resend command the
Host should re-transmit the last byte sent.~\\
 &
\\
\bfseries 00 &
\bfseries Error or Buffer Overflow\\
 &
\\
 FF &
 Error or Buffer Overflow\\
\end{supertabular}
\end{center}
[Warning: Draw object ignored]

{\bfseries
Sca}

{
El teclado riene una interfaz PS2 la cual cuenta con la disposición de
pines y el diagrama de tiempos indicados en la siguiente figura:}

{\centering 
\includegraphics[width=12.291cm,height=2.697cm]{FSM-img64.png} \par}

{
La figura anterior muestra la comunicación entre el teclado y el Host.
Como puede verse se trata de una comuniacación serial sincrónica en la
cual el teclado genera las señales Data y Clock. Solo durante el flanco
de bajado se debe leer el estado de la señal de datos.}

{
La comunicación entre el Host y el teclado se muestra en la siguiente
figura. Como puede verse el Host debe iniciar la transmisión generando
un flanco de bajada en la señal clock y un tiempo después generar el
Bit de Start, después de esto el teclado genera la señal de reloj y el
Host debe enviar serialmente el comando deseado, si el teclado recibe
correctamente la trama responde con ACK.}

{\centering 
\includegraphics[width=12.607cm,height=2.572cm]{FSM-img65.png} \par}

{
El conector PS2 tiene 6 pines los cuales tiene las siguientes
funciones:}

{\centering 
\includegraphics[width=5.556cm,height=3.069cm]{FSM-img66.png} \par}

{
Se desea que el driver de teclado tenga una salida ASCII, para poder ser
utilizado con el Display inteligente del ejercicio 6. La siguiente
tabla da una relación entre el código de la tecla y el código ASCII de
la letra o carácter correspondiente.}

\begin{flushleft}
\tablehead{}
\begin{supertabular}{|m{0.34500003cm}m{0.40500003cm}|m{0.34500003cm}m{0.40500003cm}|m{0.34500003cm}m{0.40500003cm}|m{0.34500003cm}m{0.40500003cm}|m{0.34500003cm}m{0.40500003cm}|m{0.34500003cm}m{0.40500003cm}|m{0.34500003cm}m{0.40500003cm}|m{0.34500003cm}m{0.40500003cm}|m{0.34500003cm}m{0.40500003cm}|m{0.34500003cm}m{0.40500003cm}|m{0.412cm}m{0.412cm}|m{0.393cm}m{0.40500003cm}|m{0.398cm}m{0.40500003cm}|m{0.541cm}m{0.34500003cm}|m{0.40500003cm}m{0.398cm}|m{0.375cm}m{0.11400001cm}|}
\hline
\multicolumn{2}{|m{0.9500001cm}|}{\centering
\bfseries NC} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries F9} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries NC} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries F5} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries F3} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries F1} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries F2} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries F12} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries NC} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries F10} &
\multicolumn{2}{m{1.0239999cm}|}{\centering
\bfseries F8} &
\multicolumn{2}{m{0.99799997cm}|}{\centering
\bfseries F6} &
\multicolumn{2}{m{1.003cm}|}{\centering
\bfseries F4} &
\multicolumn{2}{m{1.086cm}|}{\centering
\bfseries Tab} &
\multicolumn{2}{m{1.003cm}|}{\centering
\bfseries {\textbar}} &
\multicolumn{2}{m{0.689cm}|}{\centering
\bfseries NC}\\\hline
\multicolumn{1}{|m{0.34500003cm}|}{\centering 
00} &
\centering  FF &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
01} &
\centering  FF &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
02} &
\centering  FF &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
03} &
\centering  FF &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
04} &
\centering  FF &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
05} &
\centering  FF &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
06} &
\centering  FF &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
07} &
\centering  FF &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
08} &
\centering  FF &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
09} &
\centering  FF &
\multicolumn{1}{m{0.412cm}|}{\centering  0A} &
\centering  FF &
\multicolumn{1}{m{0.393cm}|}{\centering  0B} &
\centering  FF &
\multicolumn{1}{m{0.398cm}|}{\centering  0C} &
\centering  FF &
\multicolumn{1}{m{0.541cm}|}{\centering  OD} &
\centering  09 &
\multicolumn{1}{m{0.40500003cm}|}{\centering 
0E} &
\centering  7C &
\multicolumn{1}{m{0.375cm}|}{\centering  0F} &
\\\hline
\multicolumn{2}{|m{0.9500001cm}|}{\centering
\bfseries NC} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries Alt} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries SHL} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries NC} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries CTL} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries q} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries l} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries NC} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries NC} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries NC} &
\multicolumn{2}{m{1.0239999cm}|}{\centering
\bfseries z} &
\multicolumn{2}{m{0.99799997cm}|}{\centering
\bfseries s} &
\multicolumn{2}{m{1.003cm}|}{\centering
\bfseries a} &
\multicolumn{2}{m{1.086cm}|}{\centering
\bfseries w} &
\multicolumn{2}{m{1.003cm}|}{\centering
\bfseries 2} &
\multicolumn{2}{m{0.689cm}|}{\centering
\bfseries NC}\\\hline
\multicolumn{1}{|m{0.34500003cm}|}{\centering 
10} &
\centering  FF &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
11} &
\centering  FF &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
12} &
\centering  FF &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
13} &
\centering  FF &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
14} &
\centering  FF &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
15} &
\centering  71 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
16} &
\centering  31 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
17} &
\centering  FF &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
18} &
\centering  FF &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
19} &
\centering  FF &
\multicolumn{1}{m{0.412cm}|}{\centering  1A} &
\centering  7A &
\multicolumn{1}{m{0.393cm}|}{\centering  1B} &
\centering  73 &
\multicolumn{1}{m{0.398cm}|}{\centering  1C} &
\centering  61 &
\multicolumn{1}{m{0.541cm}|}{\centering  1D} &
\centering  77 &
\multicolumn{1}{m{0.40500003cm}|}{\centering 
1E} &
\centering  32 &
\multicolumn{1}{m{0.375cm}|}{\centering  1F} &
\\\hline
\multicolumn{2}{|m{0.9500001cm}|}{\centering
\bfseries NC} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries c} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries x} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries d} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries e} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries 4} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries 3} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries NC} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries NC} &
\multicolumn{2}{m{0.9500001cm}|}{} &
\multicolumn{2}{m{1.0239999cm}|}{\centering
\bfseries v} &
\multicolumn{2}{m{0.99799997cm}|}{\centering
\bfseries f} &
\multicolumn{2}{m{1.003cm}|}{\centering
\bfseries t} &
\multicolumn{2}{m{1.086cm}|}{\centering
\bfseries r} &
\multicolumn{2}{m{1.003cm}|}{\centering
\bfseries 5} &
\multicolumn{2}{m{0.689cm}|}{\centering
\bfseries NC}\\\hline
\multicolumn{1}{|m{0.34500003cm}|}{\centering 
20} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
21} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
22} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
23} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
24} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
25} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
26} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
27} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
28} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
29} &
 &
\multicolumn{1}{m{0.412cm}|}{\centering  2A} &
 &
\multicolumn{1}{m{0.393cm}|}{\centering  2B} &
 &
\multicolumn{1}{m{0.398cm}|}{\centering  2C} &
 &
\multicolumn{1}{m{0.541cm}|}{\centering  2D} &
 &
\multicolumn{1}{m{0.40500003cm}|}{\centering 
2E} &
 &
\multicolumn{1}{m{0.375cm}|}{\centering  2F} &
\\\hline
\multicolumn{2}{|m{0.9500001cm}|}{\centering
\bfseries NC} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries n} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries b} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries h} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries g} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries y} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries 6} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries NC} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries NC} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries NC} &
\multicolumn{2}{m{1.0239999cm}|}{\centering
\bfseries m} &
\multicolumn{2}{m{0.99799997cm}|}{\centering
\bfseries j} &
\multicolumn{2}{m{1.003cm}|}{\centering
\bfseries u} &
\multicolumn{2}{m{1.086cm}|}{\centering
\bfseries 7} &
\multicolumn{2}{m{1.003cm}|}{\centering
\bfseries 8} &
\multicolumn{2}{m{0.689cm}|}{\centering
\bfseries NC}\\\hline
\multicolumn{1}{|m{0.34500003cm}|}{\centering 
30} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
31} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
32} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
33} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
34} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
35} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
36} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
37} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
38} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
39} &
 &
\multicolumn{1}{m{0.412cm}|}{\centering  3A} &
 &
\multicolumn{1}{m{0.393cm}|}{\centering  3B} &
 &
\multicolumn{1}{m{0.398cm}|}{\centering  3C} &
 &
\multicolumn{1}{m{0.541cm}|}{\centering  3D} &
 &
\multicolumn{1}{m{0.40500003cm}|}{\centering 
3E} &
 &
\multicolumn{1}{m{0.375cm}|}{\centering  3F} &
\\\hline
\multicolumn{2}{|m{0.9500001cm}|}{\centering
\bfseries NC} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries ,} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries k} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries i} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries o} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries 0} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries 9} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries NC} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries NC} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries .} &
\multicolumn{2}{m{1.0239999cm}|}{\centering
\bfseries {}-} &
\multicolumn{2}{m{0.99799997cm}|}{\centering
\bfseries l} &
\multicolumn{2}{m{1.003cm}|}{\centering
\bfseries ñ} &
\multicolumn{2}{m{1.086cm}|}{\centering
\bfseries p} &
\multicolumn{2}{m{1.003cm}|}{\centering
\bfseries {\textquoteleft}} &
\multicolumn{2}{m{0.689cm}|}{\centering
\bfseries NC}\\\hline
\multicolumn{1}{|m{0.34500003cm}|}{\centering 
40} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
41} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
42} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
43} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
44} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
45} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
46} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
47} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
48} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
49} &
 &
\multicolumn{1}{m{0.412cm}|}{\centering  4A} &
 &
\multicolumn{1}{m{0.393cm}|}{\centering  4B} &
 &
\multicolumn{1}{m{0.398cm}|}{\centering  4C} &
 &
\multicolumn{1}{m{0.541cm}|}{\centering  4D} &
 &
\multicolumn{1}{m{0.40500003cm}|}{\centering 
4E} &
 &
\multicolumn{1}{m{0.375cm}|}{\centering  4F} &
\\\hline
\multicolumn{2}{|m{0.9500001cm}|}{\centering
\bfseries NC} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries NC} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries \{} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries NC} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries ´} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries ¿} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries NC} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries NC} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries CAP} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries SHR} &
\multicolumn{2}{m{1.0239999cm}|}{\centering
\bfseries ENT} &
\multicolumn{2}{m{0.99799997cm}|}{\centering
\bfseries +} &
\multicolumn{2}{m{1.003cm}|}{\centering
\bfseries NC} &
\multicolumn{2}{m{1.086cm}|}{\centering
\bfseries \}} &
\multicolumn{2}{m{1.003cm}|}{\centering
\bfseries NC} &
\multicolumn{2}{m{0.689cm}|}{\centering
\bfseries NC}\\\hline
\multicolumn{1}{|m{0.34500003cm}|}{\centering 
50} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
51} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
52} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
53} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
54} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
55} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
56} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
57} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
58} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
59} &
 &
\multicolumn{1}{m{0.412cm}|}{\centering  5A} &
 &
\multicolumn{1}{m{0.393cm}|}{\centering  5B} &
 &
\multicolumn{1}{m{0.398cm}|}{\centering  5C} &
 &
\multicolumn{1}{m{0.541cm}|}{\centering  5D} &
 &
\multicolumn{1}{m{0.40500003cm}|}{\centering 
5E} &
 &
\multicolumn{1}{m{0.375cm}|}{\centering  5F} &
\\\hline
\multicolumn{2}{|m{0.9500001cm}|}{\centering
\bfseries NC} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries {\textless}} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries NC} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries NC} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries NC} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries NC} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries BKS} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries NC} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries NC} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries 1} &
\multicolumn{2}{m{1.0239999cm}|}{\centering
\bfseries NC} &
\multicolumn{2}{m{0.99799997cm}|}{\centering
\bfseries 4} &
\multicolumn{2}{m{1.003cm}|}{\centering
\bfseries 7} &
\multicolumn{2}{m{1.086cm}|}{\centering
\bfseries NC} &
\multicolumn{2}{m{1.003cm}|}{\centering
\bfseries NC} &
\multicolumn{2}{m{0.689cm}|}{\centering
\bfseries NC}\\\hline
\multicolumn{1}{|m{0.34500003cm}|}{\centering 
60} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
61} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
62} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
63} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
64} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
65} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
66} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
67} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
68} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
69} &
 &
\multicolumn{1}{m{0.412cm}|}{\centering  6A} &
 &
\multicolumn{1}{m{0.393cm}|}{\centering  6B} &
 &
\multicolumn{1}{m{0.398cm}|}{\centering  6C} &
 &
\multicolumn{1}{m{0.541cm}|}{\centering  6D} &
 &
\multicolumn{1}{m{0.40500003cm}|}{\centering 
6E} &
 &
\multicolumn{1}{m{0.375cm}|}{\centering  6F} &
\\\hline
\multicolumn{2}{|m{0.9500001cm}|}{\centering
\bfseries 0} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries .} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries 2} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries 5} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries 6} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries 8} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries ESC} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries NUM} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries F11} &
\multicolumn{2}{m{0.9500001cm}|}{\centering
\bfseries +} &
\multicolumn{2}{m{1.0239999cm}|}{\centering
\bfseries 3} &
\multicolumn{2}{m{0.99799997cm}|}{\centering
\bfseries {}-} &
\multicolumn{2}{m{1.003cm}|}{\centering
\bfseries *} &
\multicolumn{2}{m{1.086cm}|}{\centering
\bfseries 9} &
\multicolumn{2}{m{1.003cm}|}{\centering
\bfseries BD} &
\multicolumn{2}{m{0.689cm}|}{\centering
\bfseries NC}\\\hline
\multicolumn{1}{|m{0.34500003cm}|}{\centering 
70} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
71} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
72} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
73} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
74} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
75} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
76} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
77} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
78} &
 &
\multicolumn{1}{m{0.34500003cm}|}{\centering 
79} &
 &
\multicolumn{1}{m{0.412cm}|}{\centering  7A} &
 &
\multicolumn{1}{m{0.393cm}|}{\centering  7B} &
 &
\multicolumn{1}{m{0.398cm}|}{\centering  7C} &
 &
\multicolumn{1}{m{0.541cm}|}{\centering  7D} &
 &
\multicolumn{1}{m{0.40500003cm}|}{\centering 
7E} &
 &
\multicolumn{1}{m{0.375cm}|}{\centering  7F} &
\\\hline
\end{supertabular}
\end{flushleft}
{
;SHIFT + KEY}

{
\ \ \ \ ;00 NC\ \ 01 F9\ \ 02 NC\ \ 03 F5\ \ 04 F3\ \ 05 F1\ \ 06
F2\ \ 07 F12\ \ 08 NC\ \ 09 F10\ \ 0A F8\ \ 0B F6\ \ 0C F4\ \ 0D
TAB\ \ OE °\ \ 0F NC}

{
\ \ db\ \ 0FFH,\ \ 04300H,\ \ 0FFH,\ \ 03F00H,\ \ 03D00H,\ \ 03B00H,\ \ 03C00H,\ \ 08600H,\ \ 0FFH,\ \ 04400H,\ \ 04200H,\ \ 04000H,\ \ 03E00H,\ \ 009H,\ \ 0A7H,\ \ 0FFH}

{
\ \ \ \ ;10 NC\ \ 11 ALT\ \ 12 SHL\ \ 13 NC\ \ 14 CTL\ \ 15 Q\ \ 16
!\ \ 17 NC\ \ 18 NC\ \ 19 NC\ \ 1A Z\ \ 1B S\ \ 1C A\ \ 1D W\ \ 1E
@\ \ 1F NC }

{
\ \ db\ \ 0FFH,\ \ 0FFH,\ \ 0FFH,\ \ 0FFH,\ \ 0FFH,\ \ 051H,\ \ 021H,\ \ 0FFH,\ \ 0FFH,\ \ 0FFH,\ \ 05AH,\ \ 053H,\ \ 041H,\ \ 057H,\ \ 040H,\ \ 0FFH\ \ }

{
\ \ \ \ \foreignlanguage{spanish}{;20 NC\ \ 21 C\ \ 22 X\ \ 23 D\ \ 24
E\ \ 25 \$\ \ 26 \#\ \ 27 NC\ \ 28 NC\ \ 29 SPC\ \ 2A V\ \ 2B F\ \ 2C
T\ \ 2D R\ \ 2E \%\ \ 2F NC}}

{
\ \ db\ \ 0FFH,\ \ 043H,\ \ 058H,\ \ 044H,\ \ 045H,\ \ 024H,\ \ 023H,\ \ 0FFH,\ \ 0FFH,\ \ 0FFH,\ \ 056H,\ \ 046H,\ \ 054H,\ \ 052H,\ \ 025H,\ \ 0FFH\ \ }

{
\ \ \ \ ;30 NC\ \ 31 N\ \ 32 B\ \ 33 H\ \ 34 G\ \ 35 Y\ \ 36 \&\ \ 37
NC\ \ 38 NC\ \ 39 NC\ \ 3A M\ \ 3B J\ \ 3C U\ \ 3D /\ \ 3E (\ \ 3F NC}

{
\ \ db\ \ 0FFH,\ \ 0FFH,\ \ 042H,\ \ 048H,\ \ 047H,\ \ 059H,\ \ 026H,\ \ 0FFH,\ \ 0FFH,\ \ 0FFH,\ \ 04DH,\ \ 04AH,\ \ 055H,\ \ 02FH,\ \ 028H,\ \ 0FFH\ \ }

{
\foreignlanguage{spanish}{\ \ \ \ ;40 NC\ \ 41 ;\ \ 42 K\ \ 43 I\ \ 44
O\ \ 45 =\ \ 46 )\ \ 47 NC\ \ 48 NC\ \ 49 :\ \ 4A \_\ \ 4B L\ \ 4C
Ñ\ \ 4D P\ \ 4E ?  }4F NC}

{
\ \ db\ \ 0FFH,\ \ 03BH,\ \ 04BH,\ \ 049H,\ \ 04FH,\ \ 03DH,\ \ 029H,\ \ 0FFH,\ \ 0FFH,\ \ 03AH,\ \ 05FH,\ \ 04CH,\ \ 0A5H,\ \ 050H,\ \ 03FH,\ \ 0FFH\ \ }

{
\ \ \ \ ;50 NC\ \ 51 NC\ \ 52 [\ \ 53 NC\ \ 54 ¨\ \ 55 ¡\ \ 56 NC\ \ 57
NC\ \ 58 CAP\ \ 59 SHR\ \ 5A ENT\ \ 5B *\ \ 5C NC\ \ 5D ]\ \ 5E
NC\ \ 5F NC}

{
\ \ db\ \ 0FFH,\ \ 0FFH,\ \ 05BH,\ \ 0FFH,\ \ 0B0H,\ \ 0ADH,\ \ 0FFH,\ \ 0FFH,\ \ 0FFH,\ \ 0FFH,\ \ 013H,\ \ 02AH,\ \ 0FFH,\ \ 05DH,\ \ 0FFH,\ \ 0FFH\ \ }

{
\ \ \ \ ;60 NC\ \ 61 {\textgreater}\ \ 62 NC\ \ 63 NC\ \ 64 NC\ \ 65
NC\ \ 66 BKS\ \ 67 NC\ \ 68 NC\ \ 69 END\ \ 6A NC\ \ 6B
{\textless}-\ \ 6C HM\ \ 6D NC\ \ 6E NC\ \ 6F NC}

{
\ \ db\ \ 0FFH,\ \ 03EH,\ \ 0FFH,\ \ 0FFH,\ \ 0FFH,\ \ 0FFH,\ \ 08H,\ \ 0FFH,\ \ 0FFH,\ \ 0FFH,\ \ 0FFH,\ \ 0FFH,\ \ 0FFH,\ \ 0FFH,\ \ 0FFH,\ \ 0FFH\ \ }

{
\ \ \ \ ;70 0\ \ 71 DEL\ \ 72 AD\ \ 73 5\ \ 74 -{\textgreater}\ \ 75
AUP\ \ 76 ESC\ \ 77 NUM\ \ 78 F11\ \ 79 +\ \ 7A PDN\ \ 7B -\ \ 7C
*\ \ 7D PUP\ \ 7E B D\ \ 7F NC}

{
\ \ db\ \ 030H,\ \ 0FFH,\ \ 0FFH,\ \ 035H,\ \ 0FFH,\ \ 0FFH,\ \ 0FFH,\ \ 0FFH,\ \ 0FFH,\ \ 02BH,\ \ 0FFH,\ \ 02DH,\ \ 02AH,\ \ 0FFH,\ \ 0FFH,\ \ 0FFH\ \ }

{
\ \ \ \ \foreignlanguage{spanish}{;83 F7}}

{
\ \ \ \ ;E011 ALT GR\ \ E014 CTRR\ \ E069 END\ \ E06B LEFT\ \ E06C
HOME\ \ E070 INS\ \ E071 DEL\ \ }

{
\foreignlanguage{spanish}{\ \ \ \ };E072 DOWN\ \ E074 RIGHT\ \ E075
UP\ \ \ \ E07A P DN\ \ E07D P UP\ \ E05A INTRO\ \ }

{
\ \ \ \ ;E11477E1F014F077 PAUSE}

{
\ \ \ \ ;E012E07C\ \ PRINT SCREEN}

\end{document}
