\chapter{Implementación de tareas Software utilizando procesadores Soft Core}

\section{Introducción}

En el capítulo anterior se estudió la forma de implementar tareas hardware utilizando máquinas de estado algorítmicas. La implementación de tareas hardware es un proceso un poco tedioso ya que involucra la realización de una máquina de estados por cada tarea; la implementación del camino de datos se simplifica de forma considerable ya que existe un conjunto de bloques constructores que pueden ser tomados de una librería creada por el diseñador. El uso de tareas hardware se debe realizar únicamente cuando las restricciones temporales del diseño lo requieran, ya que como veremos en este capítulo, la implementación de tareas software es más sencilla y rápida.

La estructura de una máquina de estados algorítmica permite entender de forma fácil la estructura de un procesador ya que tienen los mismos componentes principales (unidad de control y camino de datos), la diferencia entre ellos es la posibilidad de programación y la configuración fija del camino de datos del procesador.

En este capítulo se estudiará la arquitectura del procesador MICO32 creado por la empresa Lattice semiconductor y gracias a que fué publicado bajo la licencia GNU, es posible su estudio, uso y modificación. En la primera sección se hace la presentación de la arquitectura; a continuación se realiza el análisis de la forma en que el procesador implementa las diferentes instrucciones, iniciando con las operaciones aritméticas y lógicas siguiendo con las de control de flujo de programa (saltos, llamado a función); después se analizarán la comunicación con la memoria de datos; y finalmente el manejo de interrupciones.

En la segunda sección se abordará la arquitectura de un SoC (System on a Chip) basado en el procesador LM32, se analizará la forma de conexión entre los periféricos y la CPU utilizando el bus wishbone; se realizará una descripción detallada de la programación de esta arquitectura utilizando herramientas GNU. 



%********************************************************************************************************************
%********************************************************                              SECCIÓN   ARQUITECTURA LM32
%********************************************************************************************************************
\section{Arquitectura del procesador LM32}


La figura \ref{lm32_arch_single} muestra el diagrama de bloques del soft-core LM32, este procesador utiliza 32 bits y una arquitectura de 6 etapas del pipeline; las 6 etapas del pipeline son:


\begin{enumerate}
 \item \textit{Address}: Se calcula la dirección de la instrucción a ser ejecutada y es enviada al registro de instrucciones.
 \item \textit{Fetch}: La instrucción se lee de la memoria.
 \item \textit{Decode}: Se decodifica la instrucción y se toman los operandos del banco de registros o tomados del bypass.
 \item \textit{Execute}: Se realiza la operacion especificada por la instrucción. Para instrucciones simples como las lógicas o suma, la ejecución finaliza en esta etapa, y el resultado se hace disponible para el bypass.
 \item \textit{Memory}: Para instrucciones más complejas como acceso a memoria externa, multiplicación, corrimiento, división, es necesaria otra etapa.
 \item \textit{Write back}: Los resultados producidos por la instrucción son escritas al banco de registros.
\end{enumerate}


\begin{figure}
  \begin{center} \includegraphics[scale=.6]{./LM32/images/lm32_block_diagram.pdf} \end{center}
  \caption{Diagrama de bloques del LM32}\label{lm32_arch_single}
\end{figure}

\subsection{Banco de Registros}
El LM32 posee 32 registros de 32 bits; el registro \textit{r0} siempre contiene el valor 0, esto es necesario para el correcto funcionamiento de los compiladores de C y ensamblador; los siguientes 8 registros (r1 a r7) son utilizados para paso de argumentos y retorno de resultados en llamados a funciones; si una función requiere más de 8 argumentos, se utiliza la pila (\textit{stack}). Los registros \textit{r1 - r28} pueden ser utilizados como fuente o destino de cualquier instrucción. El registro \textit{r29 (ra)} es utilizado por la instrucción \textit{call} para almacenar la dirección de retorno. El registro \textit{r30 (ea)} es utilizado para almacenar el valor del \textit{contador de programa} cuando se presenta una excepción. El registro \textit{r31 (ba)} almacena el valor del contador de programa cuando se presenta una excepción tipo \textit{breakpoint} o \textit{watchpoint}. Los registros \textit{r26 (gp)} \textit{r27 (fp)} y \textit{r28 (sp)} son el puntero global, de frame y de pila respectivamente.
 Después del reset el valor no se define el valor de los registros, por lo que la primera acción que debe ejecutar el programa de inicialización en colocar un cero en el registro \textit{r0 (\textbf{xor} r0, r0, r0)}



\subsection{Registro de estado y control}

La tabla \ref{csr} muestra los registros de estado y control (CSR), indicando si son de lectura o escritura y el índice que se utiliza para acceder al registro.

\begin{table}[htpb]
  \caption{Registro de Estado y Control}
  \centering
    \begin{tabular}{|l|l|l|}	
      \hline
      \textbf{Nombre}  & \textbf{Index} & \textbf{Descripción}  
      \\ \hline 
       IE          & 0x00 & (R/W)Interrupt enable        
      \\ \hline 
       EID         & ---- & (R)  Exception ID   
      \\ \hline 
       IM          & 0x01 & (R/W)Interrupt mask  
      \\ \hline 
       IP          & 0x02 & (R)  Interrupt pending 
      \\ \hline    
      ICC          & 0x03 & (W)  Instruction cache control   
      \\ \hline 
       DCC         & 0x04 & (W)  Data cache control  
      \\ \hline 
       CC          & 0x05 & (R)  Cycle counter 
      \\ \hline 
       CFG         & 0x06 & (R)  Configuration
      \\ \hline 
       EBA         & 0x07 & (R/W)Exception base address 
      \\ \hline 
    \end{tabular}
  \label{csr}
\end{table}

\subsubsection{Contador de Programa (PC)}
El contador de programa es un registro de 32 bits que contiene la dirección de la instrucción que se ejecuta actualmente. Debido a que todas las instrucciones son de 32 bits, los dos bits menos significativos del PC siempre son zero. El valor de este registro después del reset es \textit{h00000000}



\subsubsection{EID Exception ID}
El índice de la excepción es un número de 3 bits que indica la causa de la detención de la ejecución del programa. Las excepciones son eventos que ocurren al interior o al exterior del procesador y cambian el flujo normal de ejecución del programa. Los valores y eventos correspondientes son:



\begin{itemize}
 \item \textbf{0}: Reset; se presenta cuando se activa la señal de reset del procesador.
 \item \textbf{1}: Breakpoint; se presenta cuando se ejecuta la instrucción break o cuando se alcanza un punto de break hardware.
 \item \textbf{2}: Instruction Bus Error; se presenta cuando falla la captura e una instrucción, típicamente cuando la dirección no es válida.
 \item \textbf{3}: Watchpoint; se presenta cuando se activa un watchpoint.
 \item \textbf{4}: Data Bus Error; se presenta cuando falla el acceso a datos, típicamente porque la dirección solicitada es inválida o porque el tipo de acceso no es permitido.
 \item \textbf{5}: División por cero; Se presenta cuando se hace una división por cero.
 \item \textbf{6}: Interrupción; se presenta cuando un periférico solicita atención por parte del procesador, para que esta excepción se presente se deben habilitar las interrupciones globales (IE) y la interrupción del periférico (IM).
 \item \textbf{7}: System Call; se presenta cuando se ejecuta la instrucción \textit{scall}.
\end{itemize}

\subsubsection{IE Habilitación de interrupción}

l registro IE contiene el flag IE, que determina si se habilitan o no las interrupciones. Si este flag se desactiva, no se presentan interrupciones a pesar de la activación individual realizada con IM. Existen dos bits \textit{BIE} y \textit{EIE} que se utilizan para almacenar el estado de IE cuando se presenta una excepción tipo breakpoint u otro tipo de excepción; esto se explicará más adelante cuando se estudien las instrucciones relacionadas con las excepciones.


\subsubsection{IM Máscara de interrupción}
La máscara de interrupción contiene un bit de habilitación para cada una de las 32 interrupciones, el bit 0 corresponde a la interrupción 0. Para que la interrupción se presente es necesario que el bit correspondiente a la interrupción y el flag IE sean igual a 1. Después del reset el valor de IM es \textit{h00000000}


\subsubsection{IP Interrupción pendiente}

El registro IP contine un bit para cada una de las 32 interrupciones, este bit se activa cuando se presenta la interrupción asociada. Los bits del registro IP deben ser borrados escribiendo un 1 lógico.


- Compilación de progamas para el LM32, explicar un ejemplo sencillo puede ser el de tipos de datos comentandop todos los archivos, lm32, crt0.s, etc
- Set de instrucciones, con ejemplos en donde sea necesario como en:
   - llamado a funciones: Ejemplo sencillo que muestre como se pasan parámetros a través de r0, r1, r2.
   - saltos: If, while, forma
   - interrupciones explicar como se debe modificar el crt0.s para incluir los vectores de excepción y como se atiende la interrupción.
   - acceso a memoria externa: Explicar como se mapean los registros de los periféricos a C, y tipos de datos.
- Acceso a memoria externa: Bus wishbone: Topologías, señales del WB, arquitectura del conbus, explicar uart y timer.
- Como se forma el SoC con el LM32. Diagrama de bloques del SoC, explicando donde quedan los diferentes periféricos.





%********************************************************************************************************************
%********************************************************                              SECCIÓN   SET DE INSTRUCCIONES
%********************************************************************************************************************
\section{Set de Instrucciones del procesador Mico32}
En esta sección se realizará un análisis del conjunto de instrucciones del procesador Mico32; para facilitar el estudio se realizó una división en cuatro grupos comenzando con las instrucciones aritméticas y lógicas, siguiendo con las relacionadas con saltos, después se analizará la comunicación con la memoria de datos y finalmente las relacionadas con interrupciones y excepciones. Para cada uno de estos grupos se mostrará el camino de datos (simplificado) asociado al conjunto de instrucciones. 


\subsection{Instrucciones aritméticas}
En la figura \ref{arith_register} se muestra el camino de datos simplificado de las operaciones aritméticas y lógicas cuyos operandos son registros, y el resultado se almacena en un registro; en otras palabras son de la forma: \textbf{gpr[RX] = gpr[RY] {OP} gpr[RZ]}, donde: OP puede ser \textit{nor, xor, and, xnor, add, divu, modu, mul, or, sl, sr, sru, sub}. Como puede verse en esta figura la instrucción contiene la información necesaria para direccionar los registros que almacenan los operandos \textbf{RY} (instruction\_d 25:21) y \textbf{RZ} (instruction\_d 20:16), estas señales de 5 bits direccionan el banco de registros y el valor 
almacenado en ellos puede obtenerse en dos salidas diferentes ( \textbf{gpr[rz]} y \textbf{gpr[ry]}). En el archivo \textit{rtl/lm32/lm32\_cpu.v} se implementa el banco de registros de la siguiente forma:

\lstset{language=verilog}
\begin{lstlisting}
assign reg_data_0 = registers[read_idx_0_d];
assign reg_data_1 = registers[read_idx_1_d];
\end{lstlisting}


En este código \textit{reg\_data\_0} y \textit{reg\_data\_1} son las dos salidas \textbf{gpr[rz]} y \textbf{gpr[ry]}; las señales \textit{read\_idx\_0\_d} y \textit{read\_idx\_1\_d} corresponden a \textit{instruction\_d 25:21} y \textit{instruction\_d 20:16} respectivamente. El contenido de los registros direccionados de esta forma son llevados al modulo \textit{logic\_op} donde se realiza la operacion correspondiente a la instrucción y el resultado pasa a través de los estados del pipeline hasta llegar a la señal \textit{w\_result} (parte inferior de la figura) esta señal entra al banco de registros para ser almacenada en la dirección dada por la señal \textit{write\_idx\_w} la cual es fijada por la instrucción, más específicamente por \textit(instruction\_d 15:11). En el archivo \textit{rtl/lm32/lm32\_cpu.v} se implementa esta escritura al banco de registros de la siguiente forma: 

\lstset{language=verilog}
\begin{lstlisting}
always @(posedge clk_i)

begin

    if (reg_write_enable_q_w == `TRUE)

        registers[write_idx_w] <= w_result;

end
\end{lstlisting}


\subsubsection{Entre registros}
  \begin{figure}
    \begin{center} \includegraphics[scale=.2]{./LM32/images/arith_register.pdf} \end{center}
    \caption{Camino de datos de las operaciones aritméticas y lógicas entre registros}\label{arith_register}
  \end{figure}
  
 
 
 
\subsubsection{Inmediatas}

Existe otro grupo de operaciones lógicas y aritméticas en las que uno de los operandos es un registro y el otro es un número fijo, esto permite realizar operaciones con constantes que nos son almacenadas previamente en registros, sino que son almacenadas en la memoria de programa. En la figura \ref{arith_immediate} se muestra como se modifica el camino de datos para este tipo de instrucciones; en ella, podemos observar que \textit{instruction\_d 25:21} direcciona uno de los operandos que está almacenado en el banco de registros y de forma similar al caso anterior el dato almacenado es llevado al bloque \textit{logic\_op}. El segundo operando es llevado a este bloque desde un multiplexor donde se hace una extensión de signo de \textit{instruction\_d 15:0} o se hace un corrimiento a la derecha de 16 posiciones; esto, para convertir el número de 16 bits a uno de 32 bits, lo que da como resultado \textit{{16{instruction\_d[15]}}, instruction\_d[15:0]} y \textit{instruction\_d[15:0], 16'h0000} respectivamente; el 
corrimiento de 16 bits a la derecha se hace para poder realizar las operaciones \textit{andhi} y \textit{orhi}, las cuales solo operan sobre la parte alta de los operandos.

  \begin{figure}
    \begin{center} \includegraphics[scale=.2]{./LM32/images/arith_immediate.pdf} \end{center}
    \caption{Camino de datos de las operaciones aritméticas y lógicas inmediatas}\label{arith_immediate}
  \end{figure}

\subsection{Saltos}
Los saltos permiten controlar el flujo de ejecución del programa posibilitando la implementación de ciclos, llamado a funciones, y toma de decisiones. En esta subsección estudiaremos el camino de datos resultante para este tipo de instrucciones. A diferencia de las instrucciones aritméticas y lógicas, en este tipo de instrucciones se modifica el valor del contador de programa.

\subsubsection{Condicionales}

En la instrucción se almacena la dirección de los registros que deben ser comparados, específicamente en \textit{instruction\_d 25:21} y \textit{instruction\_d 20:16}; los valores almacenados en estos registros son llevados al sumador y a un bloque especial que determina si se cumple o nó la condición (señales rojas en la gráfica); la señal \textit{condition\_met\_x} se activa si la condición se cumple.

Para que el valor del contador de programa se modifique, es necesario que las señales \textit{condition\_met\_x}, \textit{branch\_m} y \textit{valid\_m} se encuentren activas (señales amarillas en la gráfica); la señal \textit{branch\_m} se activa cuando la instrucción es de tipo \textit{branch} o \textit{call}; la señal \textit{valid\_m} se activa cuando se presenta una instrucción válida. Adicionalmente, es necesario que el procesador no se encuentre en un estado de \textit{stall}. Si se cumplen las condiciones anteriores, se activará la señal \textit{branch\_taken\_m}, la que le indicará a la unidad de instrucciones que cargue el valor de la señal \textit{branch\_target\_m} en el contador de programa.

El valor de \textit{branch\_target\_m} (señal azul en la gráfica) es fijado por dos diferentes métodos: cuando se produce una excepción o cuando se produce un salto, la señak \textit{exception\_x} selecciona el valor adecuado para cada caso. La señal \textit{branch\_target\_x} es el resultado de la suma de \textit{pc\_d} y de \textit{branch\_offset\_d} (para esta suma no se utiliza el bloque sumador). El valor de \textit{branch\_offset} es seleccionado por la señal \textit{select\_call\_immediate} entre las señales \textit{call\_immediate} (para instrucciones de llamado a función) y \textit{branch\_immediate}; está última tiene como valor \textit{{{16{inst[15]}}, inst[15:0]}}, lo que es una extensión de signo de la constante de 16 bits almacenado en la memoria de programa.

En la figura \ref{branch_condition} se muestra el camino de datos equivalente a las instrucciones relacionadas con condicionales; 
  \begin{figure}
    \begin{center} \includegraphics[scale=.2]{./LM32/images/branch_condition.pdf} \end{center}
    \caption{Camino de datos de los saltos condicionales}\label{branch_condition}
  \end{figure}

\subsubsection{Llamado a función y salto incondicional}
Existen dos tipos de llamado a función y de salto incondicional; su diferencia radica en la forma de almacenar la dirección a la que deben saltar. En la figura \ref{branch_call} se muestra el camino de datos correspondiente a las instrucciones \textit{calli} y \textit{bi}, estas almacenan en la instrucción la dirección y en la figura \ref{branch_call} se muestra el camino de dato correspondiente a las instrucciones \textit{call} y \textit{b} las que almacenan la dirección en un registro.


Para ambos casos el contador de programa es modificado si se activan las señales \textit{condition\_met\_x}, \textit{branch\_m} y \textit{valid\_m}; la señal \textit{valid\_m} se activa cuando se presenta una instrucción válida; \textit{branch\_m} (color amarillo en los graficos) se activa cuando la instrucción que se está ejecutando es un salto o un llamado a función; y  \textit{condition\_met\_x} se activa cuando se cumple con la condición para el salto, debido a que estos saltos y llamados son incondiconales, el MICO32 contempla dos casos en los que activa esta señal, tal como se muestra a continuación (tomado de \textit{rtl/lm32/lm32\_cpu.v}):

\lstset{language=verilog}
\begin{lstlisting}
always @*
begin
    case (instruction[28:26])
    3'b000:  condition_met_x = `TRUE;
    3'b110   condition_met_x = `TRUE;
    ....
    ....
    ....
    default:              condition_met_x = 1'bx;
    endcase 
end
\end{lstlisting}

Los bits \textit{instruction[28:26]} hacen parte del código de la instrucción; el valor para las instrucciones \textit{bi} y \textit{b} es \textit{000} y para \textit{call} y \textit{calli} es \textit{110}, lo que activa \textit{condition\_met\_x} cada vez que se presentan estas instrucciones.

De forma similar a las instrucciones relacionadas con saltos condicionales el valor del contador de programa es igual al valor de las señal \textit{branch\_target\_x} (señal de color verde en las figuras); el valor de esta señal para las instrucciones \textit{call} y \textit{b} proviene del valor almacenado en el registro seleccionado por \textit{instruction\_d [25:21]}. Para las instrucciones \textit{calli} y \textit{bi} el valor está dado por la señal \textit{branch\_offset} la que toma como valor \textit{{{6{ins[25]}},ins[25:0]}} o \textit{{{16{ins[15]}},ins[15:0]}} para una instrucción \textit{call} o  \textit{b} respectivamente.

Adicionalmente, para las instrucciones de llamado a función \textit{call} y \textit{calli} se debe almacenar en el registro \textit{R29} la dirección de memoria siguiente a la que se realizó el llamado a la función, esto con el fín de retornar al flujo de programa principal, esto se logra haciendo uso del pipeline y se utiliza el valor del contador de programa \textit{pc\_m} cuyo valor contiene el valor adecuado para el retorno del llamado a función; el valor de \textit{pc\_m} (señal color morado en las figuras) es asignado a la señal \textit{w\_result} del banco de registros para ser almacenado en el registro indicado por \textit{write\_idx} (señal marrón en los gráficos); la que toma el valor de \textit{29} cuando se presenta una instrucción \textit{calli} o \textit{call}.

  \begin{figure}
    \begin{center} \includegraphics[scale=.2]{./LM32/images/branch_call_immediate.pdf} \end{center}
    \caption{Camino de datos de los saltos y l\textit\{branch\_m}lamado a funciones inmediatos}\label{branch_call_immediate}
  \end{figure}

  
  \begin{figure}
    \begin{center} \includegraphics[scale=.2]{./LM32/images/branch_call.pdf} \end{center}
    \caption{Camino de datos de los saltos  y llamado a funciones}\label{branch_call}
  \end{figure}


\subsection{Comunicación con la memoria de datos}

Antes de estudiar el camino de datos correspondiente a este grupo de ibstrucciones, hablaremos de los tipos de datos que soporta el procesador MICO32. En la figura \ref{data_types} se muestran ejemplos de manipulación de diferentes tipos de datos y como estos son tratados en la memoria del procesador.

El primer tipo de datos que se muestra en esta figura es el \textit{char}, la variable \textit{data8} es declarada como un \textit{volatile unsigned char *}, es decir un puntero a un \textit{char} sin signo tipo \textit{volatile}; los tipos de datos \textit{volatile} le indican al compilador que no realice optimizaciones sobre esta variable, lo que es importante cuando se direccionan periféricos. Al puntero \textit{data8} se le asigna la dirección \textit{0x400} y el valor \textit{0x44}. Si se aumenta el valor de la dirección del puntero en una posición \textit{data8++} la nueva dirección será \textit{0x401} y si se aumenta de nuevi pasará a ser \textit{0x402}; lo que indica que el procesador a pesar de ser de 32 bits puede realizar direccionamiento con granularidad byte; esto es muy conveniente para un almacenamiento eficiente de información, de no ser así se utilizaría una palabra de 32 bits para almacenar 8 bits.

La segunda parte de la figura \ref{data_types} ilustra el manejo del tipo de dato \textit{short} el cual es de 8 bits; para esto se utiliza en puntero \textit{data16} con una dirección inicial de \textit{0x200} y un valor de \textit{0x2020}; al aumentar la dirección del puntero en 1 (data16++) la dirección resultante es  \textit{0x202}, lo que permite el almacenamiento eficiente de este tipo de dato.

Finalmente se ilustra el tipo de datos \textit{int} y se observa como las direcciones de memoria inical y final después de aumentar el valor del puntero son \textit{0x300} \textit{0x304}; lo que muestra que el direccionamiento interno de la memoria depende del tipo de datos.


\subsubsection{Tipos de datos}
  \begin{figure}
    \begin{center} \includegraphics[scale=.6]{./LM32/images/data_types.pdf} \end{center}
    \caption{Tipos de datos soportados por el procesador Mico32}\label{data_types}
  \end{figure}


En la figura \ref{type_char} 
  \begin{figure}
    \begin{center} \includegraphics[scale=.6]{./LM32/images/char.pdf} \end{center}
    \caption{Acceso a un data tipo \textit{char}}\label{type_char}
  \end{figure}
 
  \begin{figure}
    \begin{center} \includegraphics[scale=.6]{./LM32/images/short.pdf} \end{center}
    \caption{Acceso a un data tipo \textit{short}}\label{type_short}
  \end{figure}
  
  
    \begin{figure}
    \begin{center} \includegraphics[scale=.6]{./LM32/images/int.pdf} \end{center}
    \caption{Acceso a un data tipo \textit{int}}\label{type_int}
  \end{figure}
  
  
\subsubsection{Escritura}
  \begin{figure}
    \begin{center} \includegraphics[scale=.2]{./LM32/images/store.pdf} \end{center}
    \caption{Camino de datos de las instrucciones de escritura a memoria}\label{data_write}
  \end{figure}

\subsubsection{Lectura}
  \begin{figure}
    \begin{center} \includegraphics[scale=.2]{./LM32/images/load.pdf} \end{center}
    \caption{Camino de datos de las instrucciones de escritura a memoria}\label{data_write}
  \end{figure}

  

  

\subsection{Interrupciones}

%   \begin{figure}
%     \begin{center} \includegraphics[scale=.2]{./LM32/images/exception.pdf} \end{center}
%     \caption{Camino de datos correspondiente a las excepciones}\label{exception}
%   \end{figure}


  
  \begin{figure}
    \begin{center} \includegraphics[scale=.2]{./LM32/images/exception_generation.pdf} \end{center}
    \caption{Camino de datos correspondiente a las generación de excepciones}\label{exception_generation}
  \end{figure}

  
  \begin{figure}
    \begin{center} \includegraphics[scale=.2]{./LM32/images/exception_csr.pdf} \end{center}
    \caption{Camino de datos correspondiente al acceso de los registros asociados a las excepciones}\label{exception_csr}
  \end{figure}

  \begin{figure}
    \begin{center} \includegraphics[scale=.2]{./LM32/images/eret_ret.pdf} \end{center}
    \caption{Camino de datos asociado al retorno de función y de excepción}\label{eret_ret}
  \end{figure}


Explicar el código de atención a la irq



%********************************************************************************************************************
%********************************************************                              SECCIÓN   ARQUITECTURA SoC
%********************************************************************************************************************

\section{Arquitectura del SoC LM32}
Explicar el componente hardware y software,explicar la estructura sw y hw de los proyectos


  \begin{figure}
    \begin{center} \includegraphics[scale=.6]{./LM32/images/soft_SoC_design_flow.pdf} \end{center}
    \caption{Flujo de diseño para el procesador LM32}\label{soft_SoC_design_flow}
  \end{figure}


\subsection{Bus wishbone}

\subsubsection{Señales principales}

\begin{itemize}
 \item \textit{ack\_o}: La activación de esta señal indica la terminación normal de un ciclo del bus. 
 \item \textit{addr\_i}: Bus de direcciones. 
 \item \textit{cyc\_i}: Esta señal se activa que un ciclo de bus válido se encuentra en progreso.
 \item \textit{sel\_i}: Estas señales indican cuando se coloca un dato válido en el bus \textit{dat\_i} durante un ciclo de escritura, y cuando deberían estar presentes en el bus \textit{dat\_o} durante un ciclo de lectura. El número de señales depende de la granularidad del puerto. El LM32 maneja una granularidad de 8 bits sobre un bus de 32 bits, por lo tanto existen 4 señales para seleccionar el byte deseado (\textit{sel\_i(3:0)}). 
 \item \textit{stb\_i}: Cuando se activa esta señal se indica al esclavo que ha sido seleccionado. Un esclavo wishbone debe responder a las otras señales únicamente cuando se activa esta señal. El esclavo debe activar la señal \textit{ack\_o} como respuesta a la activación de \textit{stb\_i}.
 
 \item \textit{we\_i}: Esta señal indica la dirección del flujo de datos, en un ciclo de lectura tiene un nivel lógico bajo y en escritura tiene un nivel lógico alto. 

 \item \textit{dat\_i}: Bus de datos de entrada.
 \item \textit{dat\_o}: Bus de datos de salida.
\end{itemize}


  \begin{figure}
    \begin{center} \includegraphics[scale=.6]{./LM32/images/uart_read_waves.pdf} \end{center}
    \caption{Ciclo de lectura del bus wishbone}\label{uart_read_waves}
  \end{figure}

  \begin{figure}
    \begin{center} \includegraphics[scale=.6]{./LM32/images/uart_read_waves.pdf} \end{center}
    \caption{Ciclo de escritura del bus wishbone}\label{uart_write_waves}
  \end{figure}

  
  
\subsubsection{Interface del bus wishbone}
explicar como funciona el conmax, mostrar diagrama de flujo y simulación

  \begin{figure}
    \begin{center} \includegraphics[scale=.35]{./LM32/images/conbus.pdf} \end{center}
    \caption{Circuito de interconexión del bus wishbone}\label{conbus}
  \end{figure}



\subsection{Comunicación con periféricos}
EXplicación de la UART y del TIMER globales interface en C.

  \begin{figure}
    \begin{center} \includegraphics[scale=.6]{./LM32/images/uart_block_full.pdf} \end{center}
    \caption{Ejemplo de periférico wishbone: UART}\label{uart_block_full}
  \end{figure}


  
  \begin{figure}
    \begin{center} \includegraphics[scale=.6]{./LM32/images/timer.pdf} \end{center}
    \caption{Ejemplo de periférico wishbone: TIMER}\label{timer}
  \end{figure}



\subsubsection{Lectura}
  \begin{figure}
    \begin{center} \includegraphics[scale=.6]{./LM32/images/uart_block_read.pdf} \end{center}
    \caption{Circuito equivalente de lectura de la UART}\label{uart_block_read}
  \end{figure}
  


\subsubsection{Escritura}
    \begin{figure}
    \begin{center} \includegraphics[scale=.6]{./LM32/images/uart_block_write.pdf} \end{center}
    \caption{Circuito equivalente de escritura de la UART}\label{uart_block_write}
  \end{figure}


\subsubsection{Interfaz Software}

  \begin{figure}
    \begin{center} \includegraphics[scale=.6]{./LM32/images/peripheral_soc.pdf} \end{center}
    \caption{Asignación de la dirección de memoria a los periféricos}\label{peripheral_soc}
  \end{figure}


  \begin{figure}
    \begin{center} \includegraphics[scale=.6]{./LM32/images/uart_sw_interface.pdf} \end{center}
    \caption{Definición de la dirección de los registros internos de la UART}\label{uart_sw_interface}
  \end{figure}

  \begin{figure}
    \begin{center} \includegraphics[scale=.6]{./LM32/images/timer_sw_interface.pdf} \end{center}
    \caption{Definición de la dirección de los registros internos del TIMER}\label{timer_sw_interface}
  \end{figure}


\subsubsection{}




