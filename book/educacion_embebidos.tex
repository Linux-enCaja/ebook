\chapter{Plan de Estudios Para la Enseñanza/Aprendizaje de Sistemas Embebidos} 
\label{ch:embedded}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                        INTODUCCION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introducción}

\subsection{Qué es un Sistema Embebido}
Un Sistema Embebido (ES) es un sistema de propósito específico en el cual, el computador es encapsulado completamente por el dispositivo que el controla. A diferencia de los computadores de propósito general, los sistemas embebidos son diseñados para una aplicación específica, es decir, estos sistemas realizan un grupo de funciones previamente definidas y una vez el sistema es diseñado, no se puede cambiar fácilmente su funcionalidad; debido a su interacción con el entorno deben cumplir restricciones temporales estrictas, el término \textit{sistemas de tiempo real} es utilizado para enfatizar este aspecto; son heterogéneos, es decir, están compuestos por componentes hardware (PLDs, ASICs) y software ($\mu$-controladores, $\mu$-procesadores, DSPs); tienen grandes requerimientos en términos de confiabilidad.

\subsection{Arquitectura}

En la Figura \ref{es_arch} se muestra la arquitectura típica de un Sistema Embebido. La cual integra un componente hardware (HW), implementado ya sea en un (CPLD, FPGA) o en un ASIC, (conocido con el nombre de tarea hardware) y un componente software (SW) capaz de ejecutar software; la parte del procesador está dividida en la CPU (En algunos casos posee una caché) y las unidades de Memoria.

\begin{figure}
  \begin{center} \includegraphics[scale=.6]{./images/ES_Architecture} \end{center}
  \caption{Arquitectura de un Sistema Embebido}\label{es_arch}
\end{figure} 

Al momento de diseñar un sistema embebido se encuentran diferentes opciones de implementación, la más adecuada, resultará de un análisis económico donde se valora el costo de la solución ante el cumplimiento de los requerimientos del sistema; estas opciones son:

\begin{itemize}
  \item Componente HW y SW integrado en un dispositivo semiconductor (System on Chip - SoC, Circuito integrado de aplicación específica - ASIC): En la actualidad existen muchas compañías que fabrican procesadores de 32 bits conectados a una gran variedad de periféricos y fabricados en un mismo circuito integrado, lo que simplifica el diseño y reduce costos de materiales. Este tipo de implementación es muy popular en los dispositivos de consumo masivo (reproductores de MP3, consolas de juego, teléfonos celulares, etc.), debido a los grandes niveles de producción (del orden de millones de unidades) resulta más económico contar con un dispositivo que integre el mayor número de funcionalidades que disminuye el costo de componentes y reduce el área de circuito impreso.

  \item Componente SW en un SoC y componente HW en un dispositivo lógico programable (CPLD, FPGA): Cuando no existe en el mercado un SoC con la cantidad de periféricos requerida para una determinada aplicación, o con una funcionalidad específica, es necesario recurrir a la utilización de dispositivos comerciales que implementen dicha función; en algunas ocasiones el periférico puede realizar funciones poco comunes y no se proporciona comercialmente, la solución es entonces, implementar estas funcionalidades en un dispositivo lógico programable (PLD). También se recomienda la utilización de PLDs en sistemas que requieren la utilización de la misma funcionalidad un gran número de veces (puertos seriales, pines de entrada/salida). Esta decisión está atada al nivel de producción, ya que al incluir un PLD aumenta el costo global del proyecto y el consumo de potencia (el consumo de las FPGAs actuales las hace poca prácticas para aplicaciones móviles).

  \item Componente SW y HW en una FPGA: Esta es la opción más flexible, pero la de menor desempeño, ya que al utilizar los recursos lógicos de la FPGA para la implementación del procesador (softcore) la longitud y capacitancia asociada a los caminos de interconexión entre los bloques lógicos aumentan el retardo de las señales, lo que disminuye la máxima velocidad de funcionamiento. Los procesadores \textit{softcore} más populares en la actualidad son: Microblaze y Picoblaze de Xilinx, Leon de Gaisler Research y Lattice-Mico32 de Lattice Semiconductors.

\end{itemize}


\subsection{Aplicaciones}
Los sistemas embebidos se encuentran en casi todas las actividades humanas, a diario se interactúa con ellos, aún sin darse cuenta, ya sea porque son parte de la vida diaria o porque hacen parte de aparatos que se utilizan a diario. La figura \ref{es_apps} muestra los campos de aplicación de los sistemas embebidos.

\begin{figure}
  \begin{center} \includegraphics[scale=.6]{./images/Embedded_systems_applications.pdf} \end{center}
  \caption{Aplicaciones de los Sistema Embebidos Fuente: TATA Consultancy services}\label{es_apps}
\end{figure} 


\subsection{Metodología de Diseño}
\label{design_metodology}

El proceso de diseño de un sistema embebido comienza con la {\textit{especificación del sistema}}, (ver Figura \ref{des_flow}), en este 
punto se describe la funcionalidad y se definen las restricciones físicas, eléctricas y económicas del sistema. Esta especificación debe ser muy general y no deben existir dependencias tecnológicas de ningún tipo, se suelen utilizar lenguajes de alto nivel, como UML, MARTE C++, System-C, Spec-C. La especificación puede ser verificada a través de una serie de pasos de análisis cuyo objetivo es determinar la validez de los algoritmos seleccionados, por ejemplo, determinar si el algoritmo converge o si sus resultados satisfacen las especificaciones. Desde el punto de vista de la re-utilización, algunas partes del funcionamiento global pueden tomarse de una librería de algoritmos existentes.

\begin{figure}[htpb]
  \begin{center} \includegraphics[scale=.55]{./images/design_flow} \end{center}
  \caption{Flujo de diseño de un sistema embebido \cite{Cor05}}\label{des_flow}
\end{figure} 

Una vez definidas las especificaciones del sistema, se debe realizar un modelamiento que permita extraer de estas su funcionalidad. El modelamiento es crucial en el diseño ya que de él depende el paso exitoso de la especificación a la implementación. Es importante definir que modelo matemático debe soportar el entorno de diseño; cada modelo posee propiedades matemáticas que pueden explotarse de forma eficiente para responder preguntas sobre la funcionalidad del sistema sin llevar a cabo dispendiosas tareas de verificación. Todo modelo obtenido debe ser verificado para comprobar que cumple con las restricciones del sistema.

Una vez se ha obtenido el modelo del sistema se procede a determinar su {\textit{arquitectura}}, esto es, el número y tipo de componentes y su inter-conexión; este paso no es mas que una exploración del espacio de diseño en búsqueda de soluciones que permitan la implementación de una funcionalidad dada, y puede realizarse con varios criterios en mente: costos, confiabilidad y viabilidad comercial.

Utilizando como base la arquitectura obtenida en el paso anterior las tareas del modelo del sistemas son implementadas en los componentes; esto es, asignación de funciones a los componentes de la arquitectura. Existen dos opciones a la hora de implementar las tareas o procesos:

\begin{enumerate}
  \item Implementación software: La tarea se va a ejecutar en un micro-procesador, micro-controlador o DSP.
  \item Implementación hardware: La tarea se va a ejecutar en un sistema digital dedicado ASIC o PLD.
\end{enumerate}

Para cumplir las especificaciones del sistema algunas tareas deben ser implementadas en hardware, esto con el fin de no ocupar al procesador en tareas cíclicas o que requieran mucho poder computacional, un ejemplo típico de estas tareas es la generación de bases de tiempos o la implementación de protocolos de comunicación. La decisión de que tareas se implementan en SW y que tareas se implementan en HW recibe el nombre de {\textit{particionamiento}}; esta selección depende fuertemente de restricciones económicas y temporales.

Las tareas software deben compartir los recursos que existan en el sistema (procesador y memoria), por lo tanto se deben tomar decisiones sobre el orden de ejecución y la prioridad de estas. Este proceso recibe el nombre de \textit{planificación}. En este punto del diseño el modelo debe incluir información sobre el mapeo, el particionamiento y la planificación del sistema.

Las siguientes fases corresponden a la implementación del modelo, para esto las tareas hardware deben ser llevadas al dispositivo elegido (ASIC, FPGA, micro-controlador, micro-procesador, DSP) y se debe obtener el \textit{archivo binario} con las instrucciones que implementan la funcionalidad de las tareas software y un \textit{archivo de configuración} para implementarla funcionalidad de las tareas hardware en el PLD, este proceso recibe el nombre de {\textit{síntesis}} HW y SW respectivamente, así mismo se deben sintetizar los mecanismos de comunicación entre las tareas hardware y software.

El proceso de prototipado consiste en la realización física del sistema, finalmente el sistema físico debe someterse a pruebas para verificar que cumple con las especificaciones iniciales.

Como puede verse en el flujo de diseño existen realimentaciones, estas permiten depurar el resultado de pasos anteriores en el caso
de no cumplirse con las especificaciones iniciales.


\subsection{Herramientas de desarrollo}

Las herramientas de desarrollo son fundamentales en el proceso de diseño, de su estado y capacidades depende el tiempo necesario para completar un determinado diseño; la disponibilidad de aplicaciones y librerías que permitan acelerar el proceso de diseño son puntos claves a la hora de seleccionar el entorno de desarrollo; otro factor importante es su costo, ya que pequeñas y medianas empresas no pueden invertir grandes sumas de dinero en su adquisición; adicionalmente, es crucial contar con una adecuada documentación e información que ayude a resolver problemas que se presenten en el ciclo de diseño. Se pueden clasificar estas herramientas en \textit{propietarias} y \textit{abiertas}, las primeras requieren la compra de licencias para su uso y es necesario pagar por soporte; las segundas, son distribuidas de forma gratuita y existe una gran cantidad de listas de discusión donde puede encontrarse respuesta a una gran variedad de problemas o pueden ser formuladas nuevas preguntas a un grupo especializado de 
usuarios.

La utilización de herramientas abiertas reduce de forma considerable la inversión en la plataforma de desarrollo; pero, ¿es posible realizar el flujo completo de concepción, diseño e implementación utilizando software abierto?, ¿el estado de desarrollo de las mismas facilita el diseño?, ¿existen dispositivos comerciales desarrollados con estas herramientas?. Para resolver estas dudas se consultaron varias encuestas realizadas por compañías y sitios especializados para observar la tendencia en utilización de sistemas operativos; los sitios consultados (Venture Development Corp, linuxfordevices) indican que el 27.9\% de los diseñadores utiliza sistemas operativos licenciados comercialmente, el 23.5\% sistemas operativos obtenidos públicamente, 15.9\% desarrollan su propio sistema operativo, el 12.1\% utiliza sistemas operativos comerciales basados en proyectos abiertos y el 30\% restante no utiliza un sistema operativo (ver figura \ref{os_trends}; el porcentaje de utilización de sistemas operativos basados en 
proyectos abiertos es del 35.6\%, lo que supera a los sistemas operativos comerciales; es interesante observar que casi el 70\% de los encuestados utilizan algún tipo de sistema operativo, lo que da un claro indicio de la necesidad de este en el ciclo de diseño.

\begin{figure}[htpb]
  \begin{center} \includegraphics[scale=.7]{./images/embedded_os_trends.png} \end{center}
  \caption{Comparación del uso de sistemas operativos Fuente: Venture Development Corp} \label{os_trends}
\end{figure}

De lo anterior se puede afirmar que más de la mitad de los diseñadores que utilizan sistemas operativos para sus aplicaciones eligen proyectos abiertos, lo que indica que estas herramientas tienen el grado de madurez necesaria para su uso en aplicaciones comerciales; por otro lado, una revisión del mercado de los teléfonos móviles realizada por \textit{Admob} indica que android superó a los sistemas operativos de Apple y RIM (utilizado en los blackberry) y se proyecta que en el 2014 igualará a Symbian de Nokia. Android utiliza el kernel de Linux como base de sus aplicaciones y utiliza herramientas abiertas para su desarrollo; otras empresas como Motorola y Nokia utilizan Linux como plataforma de algunas de sus aplicaciones; así mismo, muchos routers basados en procesadores ARM o MIPS; una gran variedad de reproductores multimedia, tablets y mini-laptops; todo esto, unido a la disponibilidad de foros de discusión donde programadores expertos y creadores de una gran variedad de aplicaciones brindan soporte a 
quien este interesado, hace de las herramientas abiertas y de Linux, una alternativa muy atractiva para desarrollar una metodología de diseño en torno a ella y adaptarla a las necesidades del país.

\textit{Linux Foundation} publicó un estudio \cite{LF08} donde calcula que el valor del kernel de Linux es de USD\$1400 millones; y son necesarios USD\$10.800 millones para desarrollar el stack completo de componentes desde cero; por este motivo, el uso de Linux reduce de forma considerable los costos finales del proyecto, \textit{Black Duck Software}\footnote{http://www.blackducksoftware.com Líder mundial en el suministro de productos y servicios que aceleran el desarrollo software utilizando software libre} posee la más completa base de datos de proyectos abiertos, representados en 200.000 proyectos, 4.9 billones de líneas de código; utilizando su detallado conocimiento de los proyectos abiertos y aplicando técnicas estándar de estimación de costos, calculan que el costo de desarrollo total del proyecto FOSS excede los USD\$387000 millones y representa la inversión colectiva de mas de dos millones de desarrolladores al año. Un análisis adicional, estima que el 10\% de las aplicaciones utilizadas para el 
desarrollo de aplicaciones en tecnología de la información se pueden reemplazar por proyectos abiertoss, lo que ahorraría mas de USD\$22 billones al año.

Los proyectos de código abierto permiten a las organizaciones ahorrar tiempo y dinero en muchos aspectos, al no tener que pagar por las herramientas de desarrollo y por librerías y aplicaciones que pueden utilizar para la implementación de nuevos productos; permitiendo la inversión de tiempo y esfuerzo en proyectos que pueden ser comercializados rápidamente.


\subsubsection{Dispositivos semiconductores}
En la actualidad existe una gran oferta de SoCs, grandes compañías proporcionan constantemente nuevos dispositivos con una gran variedad de periféricos para diferentes aplicaciones. El procesador más utilizado para aplicaciones embebidas es el procesador ARM (Advanced RISC Machine). ARM no fabrica circuitos integrados, suministra sus diseños en forma de \textit{netlist} a nivel de compuertas o a nivel de Lógica de Transferencia de Registros (RTL) en un lenguaje de descripción de hardware. Estas descripciones pueden ser utilizados en el proceso de diseño ASIC, permitiendo su integración con una gran variedad de núcleos IP (Intellectual Property); compañías como Atmel, Marvell, Freescale, NXP, Cirrus Logic, Samsung, Texas Instruments adquieren licencias que les permiten utilizar estos núcleos lógicos en la fabricación de sus SoCs.

Encuestas realizadas a diseñadores por el portal \textit{linuxfordevices} \footnote{Linuxfordevices es un sitio de encuentro y centro de noticias para la comunidad que utiliza Linux en dispositivos digitales.} sobre sus preferencias en el procesador utilizado en sus proyectos; como se dijo anteriormente. ARM es el más utilizado (30\%) seguido de cerca por los basados en x86 (25\%), la arquitectura POWERPC (15\%), MIPS (10\%), DSPs (5\%). Por este motivo, en esta investigación se utilizaron dispositivos basados en procesadores ARM (AT91RM9200 y SAM7 de Atmel, imx233 de Freescale), MIPS (JZ4740 de Ingenic) y el DSP de Analog devices BF532, cubriendo de esta forma un gran campo de aplicaciones.


Existen varias alternativas para la implementación de un sistema embebido: dispositivos lógicos programables (FPGAs, CPLDs), sistema sobre silicio (SoC), micro-controlador, micro-procesador, SoC + FPGA y ASIC; su utilización está determinada por el cumplimiento de restricciones temporales, funcionales y económicas. La opción tecnológicamente más avanzada es el uso de un Circuito Integrado de Aplicación Específica (ASIC) que implemente las tareas hardware y software en un solo dispositivo semiconductor; sin embargo, se estima que solo a partir de 10 mil unidades es conveniente utilizar un ASIC para reducir los costos de producción; esta es una cantidad muy alta para las pequeñas industrias electrónicas nacionales, y hasta donde llega el conocimiento del autor de este trabajo, por el momento no se conoce el primer circuito integrado fabricado y comercializado por una empresa colombiana o de existir, no es una práctica común. Por otro lado, las herramientas de desarrollo para el diseño de circuitos integrados 
son muy costosas y el grado de conocimientos de los diseñadores es mayor que en otro tipo de implementación.
 
 
Las FPGAs proporcionan una alternativa flexible para prototipado de ASICs, ya que permiten cumplir de forma rápida con los requerimientos del mercado (el proceso de fabricación de un ASIC toma varios meses). Sin embargo, para que un producto sea viable económicamente es necesaria una solución ASIC de bajo costo; en la actualidad existe la posibilidad de bajar los costos de producción gracias a la demanda de los mismos y a la utilización de una tecnología intermedia llamada \textit{arreglo de compuertas}, la arquitectura de estos dispositivos proporciona una gran cantidad de transistores en arreglos genéricos en un substrato común; y pueden ser utilizados para la implementación de \textit{celdas estándar} o diseños \textit{full custom}; utilizando esta técnica, es posible reducir el número de unidades necesarias para encontrar un punto económicamente viable de 5000 unidades (fuente Silicon-Pro). 
 
 
Según  Smith \cite{MS9}, la opción más económica para bajos volúmenes de producción son las FPGAs, a medida que la producción aumenta se produce un punto de quiebra entre las FPGAs y el arreglo de compuertas cerca a las 5000 unidades, y el segundo punto de ruptura se produce alrededor de las 50000 unidades, donde es más rentable la producción de un ASIC basado en celdas estándar. Es muy importante tener en mente estas cifras ya que ellas determinan la tecnología a utilizar. No obstante, vale la pena aclarar que en esta comparación no se tiene en cuenta la utilización de SoC, micro-controladores o micro-procesadores comerciales, por lo que no es necesariamente cierto que a bajos niveles de producción la opción más rentable sea la utilización de FPGAs; adicionalmente, debido a su alto consumo de potencia (del orden de 10 veces mayor que un ASIC) no es posible su utilización en aplicaciones móviles.
 
 
Los \textit{System on Chip} (SoC) proporcionan una excelente alternativa para la implementación de aplicaciones modernas; integran un procesador de 32 bits o un DSP que corre a frecuencias que van desde los 75 MHz hasta los 800 MHz y poseen periféricos que permiten controlar directamente una gran cantidad de dispositivos; muchos de ellos están diseñados para aplicaciones que requieren manejo de pantallas táctiles de cristal líquido, conexión a internet, diferentes medios de almacenamiento, reproducción de audio, manejo de sensores de imagen, entre otros; muchas de estas tareas son realizadas por procesadores dedicados diferentes al procesador principal del SoC. Adicionalmente, existe una gran gama de productos ofrecidos por diversos fabricantes como Freescale, NXP, Ingenic, Analog Devices, Altera, Marvell; por otro lado, su uso en aplicaciones de consumo masivo ha reducido el costo de estos dispositivos y es posible comprarlos en cualquier cantidad a precios que oscilan entre 4 y 20 USD.

\subsubsection{Arquitectura: SoC, memorias, periféricos}
Los SoCs comerciales se pueden dividir en dos grandes grupos dependiendo de la existencia o no de memoria no volátil para el almacenamiento del programa (memoria de instrucciones) dentro del SoC. Los que poseen memoria no volátil (hasta 512 Kbytes) normalmente incorporan una memoria RAM (hasta 32 kbytes) junto con una serie de periféricos (timers, I2C, SPI, USARTs, ADCs, Watchdog, USB device, canales para acceso directo a memoria - DMA); están diseñados para no utilizar componentes externos; normalmente este tipo de dispositivos utilizan procesadores que no tienen unidad de manejo de memoria \footnote{La MMU permite el manejo de memoria, dentro de sus funciones se encuentra el traslado de la memoria física a virtual, protección de la memoria, control de cache, control de buses} (MMU) como la familia ARM7, cuyas velocidades de ejecución varían entre los 50 y 70MHz. En la figura \ref{soc_int_volatil} se muestra la arquitectura típica de un sistema basado en estos dispositivos.
 
 \begin{figure}[H]
    \begin{center} \includegraphics[scale=.6]{./images/soc_int_volatil.pdf} \end{center}
   \caption{Arquitectura típica de un sistema embebido que utiliza SoC con memoria volátil interna} \label{soc_int_volatil}
 \end{figure}
 
Los procesadores que no poseen memoria no volátil interna se dividen en dos grupos: los que poseen o no unidad de manejo de memoria; en ambos casos, se cuenta con una memoria RAM interna (del orden de cientos de Kbytes) y adicionalmente a los periféricos mencionados anteriormente se suministran controladores para USB host, puertos SSI, controlador de LCD, codecs de audio, controlador de touch screen; debido a la ausencia de memoria no volátil interna, estos dispositivos poseen periféricos dedicados al manejo de memorias no volátiles NAND flash, NOR flash, SPI, I2C  y SD; y memorias volátiles SDRAM y DDR; su velocidad de operación varía entre los 75MHz y 800MHz. En la figura \ref{soc_no_int_volatil} se muestra la arquitectura típica de un sistema basado en estos procesadores.
 
 \begin{figure}[htpb]
   \begin{center} \includegraphics[scale=.6]{./images/soc_no_int_volatil_mmu.pdf} \end{center}
   \caption{Arquitectura típica de un sistema embebido que utiliza SoC sin memoria volátil interna} \label{soc_no_int_volatil}
 \end{figure}
 
 
Debido a la falta de memoria volátil, las aplicaciones de este tipo de dispositivos requieren una memoria externa para almacenar las aplicaciones básicas y datos, en la actualidad las más populares son las memorias NAND flash, NOR flash, SPI, EEPROM y SD. Normalmente, este tipo de procesadores son utilizados en aplicaciones que utilizan sistemas operativos, como se verá más adelante. Para que ciertos sistemas operativos (Linux, Windows CE) puedan ejecutarse se requiere una mínima cantidad de memoria RAM (del orden de los Mbytes), por esta razón es necesario incluir una memoria RAM externa, en la actualidad las más utilizadas son las SDRAM, DDR y DDR2. 
 
Como conclusión, se puede decir que en el mercado existen diferentes arquitecturas de SoCs que permiten realizar proyectos con diferentes grados de complejidad y que se ajustan a las opciones más utilizadas por los desarrolladores; la opción más económica es la utilización de un SoC que incluya las memorias no volátiles y RAM internamente; sin embargo, hasta el momento no existen dispositivos con grandes capacidades de memoria Flash y RAM internas, por lo que no es recomendado su uso en ciertas aplicaciones. Utilizar un SoC que no integre las memorias no volátiles proporciona una mayor flexibilidad, ya que estos dispositivos proporcionan periféricos que pueden controlar varios tipos de memorias, y se puede elegir la más económica, algo similar ocurre con la memoria RAM; sin embargo, el costo total de las memorias externas, SoC y área de circuito impreso es mayor que en el caso anterior

Aunque estos procesadores operan a velocidades entre los 75 y 800 MHz, no todos los componentes del SoC operan a esta frecuencia, el componente externo que requiere la mayor velocidad de operación es la memoria RAM y puede estar entre los 50 y 130 MHz, los demás periféricos funcionan a frecuencias del orden de las decenas de MHz o KHz; por esta razón estos SoC suministran un circuito PLL que permite generar la frecuencia de operación a partir de cristales de frecuencias del orden de las decenas de MHz, lo que facilita el diseño de la placa de circuito impreso.
 
Cada periférico requiere una conexión específica con el dispositivo que controla, los SoC modernos incluyen la mayor parte del circuito internamente con el objetivo de minimizar las conexiones y dispositivos adicionales. Existen tendencias de los fabricantes a agrupar periféricos teniendo en mente dos aplicaciones: multimedia, e industriales; para aplicaciones multimedia se proporcionan controladores de LCDs, ratón, teclado, pantalla táctil, CODECs de audio, control de potencia, relojes de tiempo real, control de carga de baterías entre otros; para aplicaciones industriales se proporcionan controladores de red cableada, puertos CAN, I2C, y SPI.

\subsubsection{Programación}
 
Como se mencionó anteriormente, para este estudio se utilizaron herramientas abiertas para la creación de aplicaciones, en la figura \ref{sw_flow_diagram} se muestra el flujo de creación de las tareas software usando la cadena de herramientas GNU \cite{Sta99}. La ventaja de utilizar estas herramientas (adicional a la económica) es el soporte a diferentes procesadores (24 diferentes CPUs, incluyendo micro-controladores de 8 bits), lo que permite la fácil migración entre CPUs; adicionalmente su alto grado de configurabilidad permite el cambio de disposición de las memorias volátiles y no volátiles de forma fácil (a través del script de enlazado). El proceso de generación del archivo binario que debe ser grabado en la memoria no volátil de la plataforma puede ser realizado en su totalidad por la cadena de herramientas GNU.
 
 \begin{figure}[htpb]
   \begin{center} \includegraphics[scale=.6]{./images/SW_design_flow.png} \end{center}
   \caption{Flujo de diseño software para creación de aplicaciones.} \label{sw_flow_diagram}
 \end{figure}
 
\subsubsection{Inicialización de un SoC}

Los SoC poseen la capacidad de \textit{iniciar} desde diferentes periféricos; cuando se activa la señal de \textit{reset} a un SoC que no posee memoria volátil interna, el primer programa en ejecutarse es el que reside en una memoria ROM interna, este programa revisa varios periféricos en búsqueda de un programa válido; los periféricos soportados varían según el fabricante, pero por lo general siempre soportan el uso de memorias NOR Flash (paralelas) y en SoCs más recientes memorias NAND Flash, SPI, o SD; sin embargo, la mayoría de SoC soportan memorias que se encuentran soldadas en la placa de circuito impreso, lo que hace necesario buscar métodos de programación de estas memorias que no implique desmontarlas o el uso de costosos conectores. En la mayoría de los SoC, cuando el programa residente en la ROM no encuentra ninguna aplicación válida en los periféricos soportados, establece una comunicación por uno de sus puertos seriales o USB y queda en espera del envío de un programa válido, el programa enviado 
es almacenado en la memoria RAM interna, y una vez finaliza su descarga se ejecuta desde la RAM interna. La figura \ref{soc_boot} muestra este proceso.
  
 \begin{figure}[htpb]
    \begin{center} \includegraphics[scale=.4]{./images/SoC_boot.pdf} \end{center}
    \caption{Inicialización de un SoC cuando las memorias no volátiles no están programadas.} \label{soc_boot}
  \end{figure}
 
Debido a que la RAM interna normalmente es pequeña (del orden de decenas de Kbytes), no es posible cargar aplicaciones muy grandes en ella, por lo que es necesario realizar el proceso de programación en varias etapas: en la primera etapa se carga una aplicación (\textit{first - stage bootloader}) que se encarga de configurar el procesador (pila, frecuencia de operación), configurar la memoria RAM externa y habilitar un canal de comunicación para descarga de aplicaciones, de esta forma, es posible almacenar aplicaciones tan extensas como la capacidad de la memoria RAM externa (del orden de MBytes). En la segunda etapa se descarga una aplicación a la memoria externa que tiene la capacidad de programar las memorias no volátiles externas con la información proveniente de los diferentes periféricos de comunicación del SoC (como puerto serial, memoria SD, USB), este segundo programa recibe el nombre de \textit{booloader} y se auto-almacena en las primeras posiciones de la memoria no volátil, de tal forma que sea 
ejecutado después de la activación de la señal de \textit{reset} y de la búsqueda que realiza el programa interno de la ROM. 
 
Una vez programada la memoria no volátil con una aplicación válida, los SoCs realizan una serie de pasos para ejecutar las aplicaciones almacenadas en ella, esto debido a la poca capacidad de la memoria RAM interna. Como se dijo anteriormente, una vez se activa la señal de \textit{reset} se ejecuta un programa contenido en la memoria ROM interna del SoC (figura \ref{soc_boot2} (a)), esta aplicación configura un periférico que permite la comunicación con los dispositivos de almacenamiento masivo externos, y además copia una determinada cantidad de información desde la memoria no volátil externa a la memoria RAM interna (figura \ref{soc_boot2} (b)), esto se hace porque el programa en la ROM no conoce la configuración de la plataforma y esta puede cambiar según la aplicación; después de esto ejecuta la aplicación copiada a la memoria RAM interna colocando en el contador de programa (PC) el valor correspondiente a la memoria RAM interna (figura \ref{soc_boot2} (c)).
 
 \begin{figure}[htpb]
   \begin{center} \includegraphics[scale=.6]{./images/SoC_boot2.pdf} \end{center}
   \caption{Inicialización de un SoC cuando la memoria no volátil está programada, parte 1.} \label{soc_boot2}
 \end{figure}
 
Este programa (\textit{loader}) está encargado de: configurar la memoria RAM externa (su capacidad varía dependiendo de la aplicación) y de copiar la aplicación propiamente dicha desde la memoria no volátil a la memoria RAM externa, (con lo que es posible cargar aplicaciones de mayor tamaño que la memoria RAM interna); finalmente, el \textit{loader} ejecuta la aplicación almacenada en la memoria RAM haciendo que el contador de programa (PC) sea igual a la dirección donde se almacenó esta aplicación (ver figura \ref{soc_boot3})
 
 \begin{figure}[htpb]
   \begin{center} \includegraphics[scale=.6]{./images/SoC_boot3.pdf} \end{center}
   \caption{Inicialización de un SoC cuando la memoria no volátil está programada, parte 2.} \label{soc_boot3}
 \end{figure}
 
 \subsubsection{Programación utilizando el puerto JTAG}
Algunos SoCs no suministran un camino para la programación de la memoria RAM interna, para estos casos, se puede utilizar un periférico que la mayoría de los dispositivos proporciona: el puerto JTAG (creado inicialmente como un mecanismo para realizar pruebas en las tarjetas de circuito impreso para verificar la correcta conexión entre componentes, y verificar el correcto funcionamiento de los circuitos integrados) el cual, esta formado por un registro de desplazamiento (ver figura \ref{jtag_basics}) que controla el paso de información desde y hacia cada uno de los pines del circuito integrado, permitiendo realizar varias operaciones. Con el paso del tiempo, se han adicionado funcionalidades a este protocolo y una de ellas es el control de circuitos especializados dentro de los SoCs para realizar emulación en circuito (ICE), suministrando un canal para la programación de la memoria RAM interna.
 
Algunos SoCs antiguos no poseen una unidad de emulación en circuito por lo que no es posible acceder a la memoria RAM interna, en estos casos es posible utilizar el protocolo JTAG para controlar directamente los pines del SoC conectados a las memorias no volátiles y ejecutar los protocolos de programación de las mismas; debido a que es necesario programar todos los registros de la cadena Boundary Scan, el tiempo de programación suele ser más largo que cuando se utiliza el ICE.
 
 \begin{figure}[htpb]
   \begin{center} \includegraphics[scale=.6]{./images/jtag_basics.png} \end{center}
   \caption{Cadena Boundary Scan fuente: Texas Instruments.} \label{jtag_basics}
 \end{figure}
 
 
 \subsubsection{Aplicaciones \textit{standalone} vs aplicaciones con sistema operativo}
 
Los sistemas operativos proporcionan facilidades al programador que permiten acelerar el desarrollo de aplicaciones, suministrando una capa de abstracción de hardware que permite manejar los periféricos a alto nivel sin preocuparse por el manejo tedioso a nivel de registros; adicionalmente, proporciona soporte para aplicaciones en red, manejo de sistemas de archivos, multitarea, seguridad, entre otras (ver figura \ref{kernel_arch}; adicionalmente, existen librerías especializadas que ayudan al desarrollo en diferentes áreas. Sin embargo, el uso de sistemas operativos como Linux, Android, Mac OS o Windows, exige el cumplimiento de condiciones mínimas para su uso; por ejemplo, Linux requiere 8 Mbytes de memoria RAM y 2 Mbytes de memoria no volátil, Android requiere 128 Mbytes de memoria RAM y 32 Mbyte de memoria no volátil; por esta razón es necesario agregar dos memorias externas, lo que aumenta la complejidad de la placa de circuito impreso y el costo del dispositivo. Por otro lado, los sistemas operativos 
tienen una particularidad en su funcionamiento que recibe el nombre de \textit{latencia}; y se define como el tiempo que transcurre entre la generación de un evento (interrupciones hardware o software ) y la respuesta ante este evento, este tiempo varía según el estado de carga del sistema; en un sistema operativo de tiempo real esta latencia es conocida y no depende de la carga de sistema. Esta latencia en algunas aplicaciones hace imposible el manejo de eventos ya que es posible que se pierdan algunos cuando el sistema se encuentre muy cargado.
 
 \begin{figure}[htpb]
   \begin{center} \includegraphics[scale=.6]{./images/kernel.jpg} \end{center}
   \caption{Estructura del kernel de Linux.} \label{kernel_arch}
 \end{figure}
 
 
Las aplicaciones \textit{standalone} utilizan los recursos necesarios y dependiendo de su complejidad pueden ajustarse a un SoC que incorpore la memoria RAM y no volátil internamente; adicionalmente, su programación puede reducir el problema que se presenta en la latencia a las interrupciones en los sistemas operativos. Sin embargo; es necesario dar soporte a todos los periféricos que se utilizarán y se deben escribir todas las rutinas, lo que puede aumentar el tiempo de desarrollo. 
 
En conclusión, el uso de sistemas operativos o aplicaciones standalone depende de la complejidad de la aplicación, y de consideraciones económicas como el \textit{time to market} y costo de los desarrolladores. 
 

\input cdio

