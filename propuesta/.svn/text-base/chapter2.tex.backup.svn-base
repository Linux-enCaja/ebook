\chapter{}

\section{La aproximación ``Funcionamiento Básico''} 

\cite{MJM94} Propone un nivel de descripción, instanciado en el llamado ``comportamiento básico'', bloques constructores para síntesis y análisis de funcionamiento complejo de grupo en un sistema multi-agente. La Biología proporciona evidencia de soporte de unidades de funcionamiento básico en una variedad de niveles. Controlar una pierna de una rana, o un brazo humano, es una tarea compleja, especialmente si se realiza a bajo nivel. Con el fin de reducir la complejidad, la naturaleza impone una abstracción. Musaa - Ivaldi \& Giszter \cite{MFA92} muestran que un grupo relativamente pequeño de campos vectoriales básicos, encontrados en la espina de la rana, genera el repertorio completo del comportamiento motriz, aplicando combinaciones apropiadas de los vectores básicos. Tomando esto como idea, se definen funcionamientos como leyes de control que encapsulan grupos de restricciones, de tal forma que se logran metas particulares. Los funcionamientos básicos se definen como un grupo mínimo de tales comportamientos, con propiedades apropiadas, que toman ventaja de la dinámica de el sistema dado, para cumplir de forma efectiva con su repertorio de tareas.

Los comportamientos básicos son una herramienta que pretenden describir, especificar y predecir el funcionamiento del grupo. Si se seleccionan de forma adecuada estos pueden generar comportamientos grupales repetibles y predecibles. 

\subsection{Selección y evaluación de comportamientos básicos}

La idea de los comportamientos básicos es general: Ellos pretenden ser primitivas para estructurar, sintetizar y analizar el funcionamiento del sistema, asi como, bloques constructores para control, planeamiento y aprendizaje. Están relacionados con los atractores dinámicos, estados de equilibrio y otros términos utilizados para describir comportamientos estables, repetibles y primitivos de cualquier sistema.

Este trabajo se centra en los comportamientos básicos para generar interacciones de grupo inteligentes en sistemas multi-agente. Se basa en la creencia de que el funcionamiento global de estos sistemas es el resultado de las interacciones locales, las cuales están gobernadas por reglas simples. Los comportamientos básicos presentan un mecanismo para estructurar el espacio de posibles reglas locales en un pequeño grupo base.

\subsubsection{Criterio de Selección}
Para un dominio dado, puede seleccionarse un pequeño grupo de comportamientos base o básicos, a partir del cual se pueden generar comportamientos de grupo complejos y deseables. Este grupo básico debe cumplir con los siguientes criterios:

\textbf{Necesidad:} Un funcionamiento dentro de un grupo de comportamientos básico es necesario	 si alcanza el objetivo requerido para el cumplimiento de la tarea de un agente, y además, este objetivo no puede cumplirse con cualquiera de los otros comportamientos o sus combinaciones. Es decir, un comportamiento básico no puede ser implementado en términos de otros comportamientos y no puede ser reducido a ellos.

\textbf{Suficiencia:} Un grupo de comportamientos básico es suficiente para cumplir un grupo de tareas en un dominio dado si no son necesarios otros comportamientos. El grupo de comportamientos básicos puede, bajo los operadores de combinación, generar todos los comportamientos grupales de alto nivel.

Si estos comportamientos son generados a mano, ellos podrían tener las siguientes propiedades:

\begin{enumerate}
 \item Simplicidad: El comportamiento puede ser implementado lo más simple posible.
 \item Localidad: Dentro de un marco de trabajo, el comportamiento puede ser generado por reglas locales, utilizando información local de sensores.
 \item Correctness: Dentro del modelo donde es probado, el comportamiento puede mantener el objetivo para el cual a sido diseñado dentro de un grupo de condiciones dadas en tiempo de diseño.
 \item Estabilidad: El comportamiento no es sensible a perturbaciones en las condiciones externas para las cuales ha sido diseñado.
 \item Repetibilidad: El comportamiento se puede realizar de acuerdo a las especificaciones en cada intento bajo condiciones y márgenes de error razonables. 
 \item Robustez: El desempeño del comportamiento no se degradada significativamente en presencia de errores y ruido de limites específicos.
 \item Escalabilidad: El comportamiento puede escalarse con aumento y disminución del tamaño del grupo.
\end{enumerate}


Es difícil imaginar una forma de medir la selección del grupo básico óptimo, ya que este depende de las tareas a las que será aplicado. Este trabajo no pretende determinar criterios de optimización, ni proporciona preuebas teóricas del correcto funcionamiento de los algorítmos de los comportamientos presentados.


\subsubsection{Comportamientos Básicos Para Movimiento en un Plano}

El trabajo experimental se centró en la interacción entre agentes móbiles en un espacio bi-dimensional. Este dominio tiene la complejidad deseada ya que el número de posibles comportamientos colectivos no está limitado. Afortunadamente, el espacio de posibles patrones espaciales y temporales puede ser clasificado en clases, y de esta forma pude ser visto de forma efectiva a un bajo nivel de resolución. La clasificación se basa en criterios específicos de dominio y tarea, los cuales permiten seleccionar las clases de comportamiento relevantes para centrarse en ellas. Los comportamientos básicos propuestos imponen dichas clases; ellos definen grupos de comportamientos sin especificar reglas particulares para implementarlas. El comportamiento de grupo en el dominio espacial puede verse como patrones espacio-temporales de la actividad de los agentes. Ciertas organizaciones de agentes espacialmente fijas son relevantes, asi como ciertos patrones espacio-temporales. Las organizaciones de agentes espacialmente fijas corresponden a logros de metas, mientras los patrones espacio-temporales corresponden al mantenimiento de las mismas.

\begin{table}
\centering
\begin{tabular}{|l p{10cm}|}
\hline
\textbf{Safe Wandering} & La habilidad de un grupo de agentes para moverse alrededor, mientras evitan
colisiones entre ellos y otros obstáculos. La naturaleza homogénoea de los agentes puede utilizarse para evitar colisiones entre agentes. Esto es, se pueden divisar dos estrategias diferentes; una para evitar colisiones entre agentes del mismo tipo, y otra para evitar colisiones con todo lo demás. \\

\textbf{Following} & La habilidad de dos o más agentes para moverse mientras se mantiene uno detrás del otro.\\

\textbf{Dispersion} & La habilidad de un grupo de agentes para dispersarse sobre un área con el fín de establecer y mantener una distancia mínima predeterminada.\\

\textbf{Aggregation}& La habilidad de un grupo de agentes de reunirse con el fin de establecer y mantener una distancia máxima predeterminada.\\
\textbf{Homming} &  La habilidad para alcanzar una región o lugar específico.\\
\hline
\end{tabular}
\caption{Grupo de comportamientos básicos para el dominio epacial}\label{espacial_set}
\end{table}

En el proceso de selección de los comportamientos básicos, el diseñador intenta decidir que grupo de comportamientos puede ser suficiente para un gran repertorio de metas. Mientras las propiedades dinámicas del sistema proporcionan restricciones bottom-up, las metas proporcionan una estructura top-down. Ambas influencias guían el proceso de selección. La minimización de energía es una meta universal de los sistemas físicos alimentados. En el dominio del movimiento en un plano, esta meta se traduce en minimización del movimiento \textit{non-goal-motion}. Dicho movimiento es generado por un comportamiento pobre en diseño, o por interferencia entre agentes. Por lo tanto, al minimizar la interferencia se maximiza el comportamiento \textit{goal-driven} y se minimizan movimientos innecesarios.

Minimizar la interferencia se traslada directamente en el cumplimiento de la meta de eliminar colisiones de forma inmediata y en el mantenimiento de la tarea de moverse evitando colisiones. La eliminación de colisiones en grupo se puede lograr utilizando la dispersión, un comportamiento que reduce la interferencia localmente. Eso también es útil en tareas que requieren cobertura de espacio, como por ejemplo, las que involucran búsqueda y exploración.

En contraste a las metas que minimizan la interacción disminuyendo la proximidad física, algunas involucran el intercambio de recursos a través de la proximidad física. Por lo tanto, la agregación es la primitiva más útil. moverse en un grupo requiere alguna forma de coordinación de movimiento con el fín de minimizar interferencias. Ejemplos de este tipo de movimiento estructurado son Following y Flocking.

La Tabla \ref{espacial_set} muestra una lista de comportamientos que constituyen un grupo básico para un repertorio flexible de interacciones de grupo.

\subsection{Especificaciones del Comportamiento Básico}

Los comportamientos básicos en un espacio 2D se especifican en términos de posiciónes \textit{p}, distancias \textit{d}, y umbrales de distancias $\delta_{avoid}$, $\delta_{disperse}$ y $\delta_{aggregate}$.\\

$\mathcal{R}$ es el grupo de robots: $\mathcal{R} = \left\lbrace R_{i} \right\rbrace, 1 \le i \le n $\\

$p_{i} =  \begin{pmatrix} x_{i} \\ y_{i} \end{pmatrix}$    $p_{home} =  \begin{pmatrix} x_{home} \\ y_{home} \end{pmatrix}$\\

$d_{home,i}=\sqrt{(x_{home}-x_{i})^{2} + (y_{home}-y_{i})^{2}}$¸\\

$d_{i,j}=\sqrt{(x_{i}-x_{j})^{2} + (y_{i}-y_{j})^{2}}$¸\\

Utilizando esta notación las siguientes son las especificaciones para las metas de comportamiento básico:

\underbar{Safe Wandering:}

El objetivo de \textit{Safe-Wandering} es conservar el movimiento mientras se mantiene una distancia mínima entre agentes $\delta_{avoid}$:

$\frac{dp_{j}}{dt} \ne 0  \qquad y \qquad \forall{i} d_{i,j} >  \delta_{avoid}$ \\

\underbar{following:}

El objetivo de \textit{following} es alcanzar y mantener un ángulo mínimo $\theta$ entre la posición del lider \textit{i} relativa al seguidor \textit{j}: \bigskip

$i=$líder      $j=$seguidor \\ \bigskip
$0 \le \frac{dp_{j}}{dt} \centerdot (p_{i}-p_{j}) \qquad \le \qquad \parallel \frac{dp_{j}}{dt} \parallel \parallel (p_{i}-p_{j})  \parallel cos \theta $ \\ \bigskip
$\theta  = 0 \Rightarrow cos \theta = 0$ \\ \bigskip


\underbar{Dispersion:}
El objetivo de la \textit{Dispersion} es alcanzar y mantener una distancia máxima $\delta_{aggregate}$ entre los agentes.

$\forall{j} d_{i,j} >  \delta_{aggregate}$ \\

\underbar{Homming}
El objetivo de \textit{Homming} es disminuir la distancia entre el agente y una posición objetivo llamada ``home'':

$\forall{j} \frac{dp_{j}}{dt} \centerdot (p_{j}-p_{home}) <  0 $\\



\lstset{backgroundcolor=\color{white},frame=simple,emph={EMPTY},emphstyle=\color{white}, showstringspaces=false,numbers=left,stepnumber=2,numberstyle=\tiny,backgroundcolor=\color{code-color}}


%################################################################################################################
%#######################################################################     ALGORITMOS DE COMPORTAMIENTO BASICOS
%################################################################################################################

\subsection{Algoritmos de Comportamiento Básico}
Los algorítmos aquí presentados están dados en notación formal y en seudo-código. Todos son expresados formalmente como comandos de velocidad en la forma:

$command(v)$\\
Los operadores $\mathcal{N}$ y $\mathcal{C}$ se utilizan para calcular en la mayoría de los algorimos. $\mathcal{N}$ es el \textbf{operador vecindad}, el cual, dado un robot $\mathcal{R}$ y una distancia umbral $\delta$, retorna todos los robots dentro de la vecindad: \\

$\mathcal{N}(i,\delta)={\left\lbrace j \in i, ..n | d_{i,j}\right\rbrace  \le \delta}$

$\mathcal{C}$ es el \textbf{operador centroide}, el cual, dado un robot $i$ y una distancia umbral $\delta$, retorna el centroide local:

$\mathcal{C}(i,\delta)=\frac{\sum_{j\in \mathcal{N}(i,\delta)}p_{j}}{\left | \mathcal{N}(i,\delta) \right | }$

$\mathcal{C}_{g} = \frac{\sum_{j\in \mathcal{R}}p_{j}}{\left | n \right |}$

\subsubsection{Safe-Wandering}
Las estrategias para moverse mientras se evitan colisiones son talvez el tópico más estudiado en la robótica móbil. Encontrar una estrategia de propósito general de evasión de obstáculos para un agente situado en un mundo dinámico es una tarea difícil. En un entorno multi-agente el problema puede ser muy difícil de resolver.

El comportamiento de evasión utilizado es:

$command (v \displaystyle{cos(\theta + u) \choose sin(\theta + u)} ) $  \\

donde $\theta$ es la orientación de $\mathcal{R}$ y \textit{u} es el ángulo incremental desde el obstáculo. Se puede divisar la regla \textbf{Avoid-Other-Agents}:

\begin{lstlisting}[caption={Algoritmo Avoid-Other-Agents}, numbers=none]
Avoid-Other-Agents
If an agent is within d_avoid
  If the nearst agent is on the left
    turn right
    otherwise turn left
\end{lstlisting}

Este algoritmo toma ventaja de la homogeneidad del grupo. Ya que todos los agentes ejecutan la misma estrategia, el comportamiento puede confiar y tomar ventaja de la simetria espacial redundante. Si un agente falla al reconocer a otro con sus sensores especialiazados para esa tarea, puede detectarlo con los sensores de evasión, y tratarlo como un obstáculo genérico, utilizando el siguiente algoritmo:

\begin{lstlisting}[caption={Algoritmo Avoid-Everything-Else}, numbers=none]
Avoid-Everything-Else
If an obstacle is within d_avoid
  If an obstacle is on the right only, turn left.

  If an obstacle is on the left only, turn right.
  After 3 consecutive identical turns, backup and turn.

  If an obstacle is on both sides, stop and wait.
  If an obstacle persist on both sides, 
     turn randomly and back up.
\end{lstlisting}

Con el fín de aumentar la robustez y minimizar las oscilaciones, esta estrategia toma ventaja del inevitable ruido en los sensores y actuadores, lo cual es un comportamiento estocástico. Este componente estocástico garantiza que un agente evasor no se quedará en lazos infinitos y oscilaciones. Adicionalmente a la naturaleza implícita estocástica del comportamiento del robot. El algoritmo \textit{Avoid-Everything-Else} también utiliza una estrategia explicitamente probabilistica al utilizar movimientos aleatorios.

Se probaron experimentalmente variaciones de este algoritmo de evasión y se compararon con base en la cantidad de tiempo que el agente tarda evadiendo, relativo a la cantidad de tiempo que tarda moviendose libremente. Esta relación es una medida indirecta de la calidad de la estrategia de evasión, ya que mientras más tiempo gaste el agente evadiendo peor es la estrategia. El tiempo de evasión depende de la densidad de agentes, por lo que fué utilizada como una variable controlada en los experimentos. La relación utilizada para evaluar la evasión es una medida indirecta; una medición de cuando el robot esté ``estancado'' sería más útil, pero en estos experimentos los robots no contaban con senosores que les permitieran detectar este estado.

La estrategia para \textit{safe-wandering} es la combinación de dos estrategias de evasión con una regla por defecto para el movimiento con cambios ocasionales de dirección.

\begin{lstlisting}[caption={:}, numbers=none]
Safe--Wander:
  If an agent is within d_avoid
    If the nearest agent is on the left
      turn right
      otherwise turn left.
  If an obstacle is within d_avoid
    If an obstacle is on the right only, turn left.
    If an obstacle is on the left only, turn right.
    After 3 consecutive identical turns, backup and turn.
    
    If an obstacle is on both sides, stop and wait.
    If an obstacle persists on both sides,
      turn randomly and back up.
  Otherwise move forward by d_forward, turn randomly
\end{lstlisting}

\subsubsection{Following}

El comportamiento \textit{Following} se implementa con respecto al agente seguidor. Se implementa con una regla simple que dirige al seguidor a la posición del lider:

$command(\frac{v_{0}}{ \left \| p_{leader}-p_{follower} \right \|}(p_{leader}-p_{follower}))$

Este comportamiento puede ser implementado como como un complemento del algoritmo \textit{Avoid-Everything-Else}:
\begin{lstlisting}[caption={:}, numbers=none]
Follow:
  If an agent is within d_follow 
    If an agent is on the right only, turn right.

    If an agent is on the left only, turn left.
\end{lstlisting}

\subsubsection{Dispersion}
Un algorítmo de dispersión robusto se puede diseñar como una extensión del algoritmo \textit{safe-wandering}. Mientras la evasión en \textit{safe-wandering} reacciona a la presencia de un solo agente,  \textit{dispersion} utiliza la distribución local de todos los agentes cercanos (los que se encuentran al alcance de los sensores) para determinar en que dirección moverse.

\begin{lstlisting}[caption={:}, numbers=none]
Centroid-Disperse:
  If one or more agents are within d_disperse
    move away from Centroid_disperse.
\end{lstlisting}

El algoritmo anterior, calcula el centroide local para determinar la distribución de densidad local de los agentes cercanos y se aleja de la densidad más alta:

$command(\frac{-v_{0}}{\left \| \mathcal{C}(i,\delta_{disperse}-p_{i}) \right\|}(\mathcal{C}(i,\delta_{disperse}-p_{i})))$

Bajo condiciones de alta densidad, el sistema puede tomar mucho tiempo para alcanzar el estado de dispersión, ya que las interacciones locales se propagan y el movimiento de un individuo puede afectar el estado de los demás. Es decir, la \textit{dispersion} puede verse como un proceso en curso que mantiene una distancia deseada entre los agentes, mientras ellos realizan otras tareas.

El siguiente algoritmo fué más exitoso en términos de eficiencia y confiabilidad:

\begin{lstlisting}[caption={:}, numbers=none]
Neighbor-Disperse:
Find 2 nearest neighbors within d_disperse
Compute the angle between them,
Compute the negative of the bisector,
align in that direction and go forward.
\end{lstlisting}

\subsubsection{Aggregation}

La \textit{Aggregation} es el inverso de la dispersión:

$command(\frac{+v_{0}}{\left \| \mathcal{C}(i,\delta_{aggregate}-p_{i}) \right\|}(\mathcal{C}(i,\delta_{aggregate}-p_{i})))$
y puede ser implementado utilizando el operador centroide, como se muestra a continuación:

\begin{lstlisting}[caption={:}, numbers=none]
Aggregate:
  If nearest agent is outside d_aggregate
    turn toward the local Centroid_aggregate, go.
  Otherwise, stop.
\end{lstlisting}


\subsubsection{Homming}

La estrategia \textit{homming} más simple es:

$command( \frac{v_{0}}{\left \| p_{home} - p_{i} \right\|}(p_{home} - p_{i}) )$

y es implementada mediante el algoritmo:

\begin{lstlisting}[caption={:}, numbers=none]
Home:
If at home
  stop.
  otherwise turn toward home, go.
\end{lstlisting}

El \textit{homming} individual es efectivo cuando la densidad de agentes es baja. Si un número suficiente de de agentes son confinados en un determinado espacio, ellos interfieren entre sí. 


\section{Combinación de Comportamientos Básicos}

\subsection{Dos Tipos de Combinación}
Los comportamientos básicos están diseñados para ser un substrato para una variedad de comportamientos de grupo más complejos para un determinado dominio. Generar funcionamientos complejos requiere aplicar algún tipo de operadores de combinación cuyas propiedades sean bien conocidas y produzcan el funcionamiento compuesto deseado. Este es uno de los retos del control \textit{Basado en el Comportamiento}, esto es, coordinar la actividad de multiples comportamientos de entrada para producir el comportamiento de salida deseado.

Dependiendo de la complejidad del sistema, el arbitramento puede y normalmente debe ser realizado sobre múltiples puntos. Un nivel de arbitramento puede ser alcanzado al diseñar condiciones de comportamiento mutuamente excluyentes\cite{Mat92}. Creando una correspondencia uno a uno única entre condiciones y comportamientos se garantiza un grupo de pares condición-acción mutuamente excluyentes. En contraste, si la correspondencia es una a varios, de tal forma, que la condición puede originar más de un posible comportamiento, existe la posibilidad que dos o más comportamientos entren en conflicto.

Las condiciones de comportamiento mutuamente excluyentes son suficientemente poderosas para arbitrar sistemas que realizan solo un comportamiento a la vez. Sin embargo, en sistemas más complejos, comportamientos múltiples pueden contribuir a la salida. Consecuentemente, muchos sistemas prácticos utilizan condiciones de comportamiento mutuamente excluyentes dentro de una capa coherente o submódulos del sistema que manejan un set de tareas coherentes. Entre módulos y capas es necesario otro nivel de arbitraje, el cual puede implementar ya sea un tipo de suma de las entradas o un interruptor. La forma general de un sistema basado en el comportamiento involucra tal combinación de operadores a uno o más niveles.

Para obtener ventaja del poder combinatorio de los comportamientos básicos, la arquitectura propuesta utiliza dos tipos de operadores: Los comportamientos pueden ser combinados directamente, ejecutando multiples comportamientos a la vez y temporalmente, secuenciando los comportamientos uno a la vez. La combinación directa permite que multiples comportamientos activos de forma concurrente contribuyan a las salidas. Las combinaciones temporales aseguran una secuencia coherente de la salida. Los dos tipos de operadores de combinación, aplicados al grupo de comportamientos básicos, pueden generar un repertorio ilimitado de comportamientos colectivos, ya que las combinaciones temporales pueden extenderse en el tiempo de forma arbitraria. 

\subsubsection{Combinación Directa de Comportamientos}

Una combinación directa de comportamientos es alguna función de las salidas de un sub-grupo de los comportamientos básicos. En el dominio espacial, las salidas de todos comportamientos básicos están en la forma de vectores de dirección y velocidad, por lo que una suma ponderada apropiada de tales vectores produce directamente comportamientos de alto nivel coherentes. A manera de ejemplo, se muestra como, la combinación directa de algunos comportamientos básicos produce el comportamiento complejo  \textit{flocking}.

\textit{Flocking} se define como un movimiento colectivo que satisface las siguientes restricciones: todos los agentes dentro del área de los sensores de cada robot, deben estar dentro de una distancia dada a sus vecinos mientras se mueven. A diferencia del comportamiento \textit{aggregation}, \textit{flocking} no solo requiere que los agentes permanezcan juntos sino que se muevan juntos hacia un determinado punto, normalmente llamado \textit{home}. Formalmente:


$\forall(i,j) d_{i,j} < \delta_{flock} y \frac{dp\mathcal{C}_{g}}{dt}\centerdot(\mathcal{C}_{g}-p_{home})<0 $

\textit{Flocking} puede ser implementada combinando las salidas de \textit{safe-wandering}, \textit{aggregation}, \textit{dispersion} y \textit{homming} de forma tal que se cumplen las restricciones dadas. De forma intuitiva \textit{aggregation} mantiene a los robots cerca uno del otro, \textit{dispersion} hace que no estén demasiado cerca, y \textit{safe-wandering} previene individualmente a cada agente y al grupo como un todo, de colisionar con cualquier obstáculo no-agente, y \textit{homming} mueve el grupo hacia la meta. \textit{Flocking} puede ser reducido aún más a una combinación de \textit{safe-wandering}, \textit{aggregation} y \textit{homming} para un rango de valores de $\delta_{flock}$, tal que: $\delta_{flock} <\delta_{aggregate}$, ya que \textit{safe-wandering} también tiene un efecto de dispersión. \\

En la figura \ref{hfs} se muestran las combinaciones necesarias para obtener los comportamientos \textit{hearding} y \textit{surrounding}

\tikzstyle{format} = [draw, thin, fill=blue!20]
\tikzstyle{medium} = [circle, draw, thin, fill=green!20, minimum height=2.5em]

\begin{figure}[ht]
\begin{center}

\begin{tikzpicture}[node distance=3cm, auto, thick]
    \path[-] node[format] (homing) {Homing};
    \path[-] node[format, right of=homing] (safe) {Safe-wandering};
    \path[-] node[format, right of=safe]   (disp) {Dispersion}
             node[medium, below left of=disp] (add1) {+}
             (homing) edge node {} (add1)
             (safe) edge node {} (add1)
             (disp) edge node {} (add1);
    \path[-] node[format, right of=disp]   (aggr) {Aggreagation}
             (aggr) edge node {} (add1);
    \path[-] node[format, right of=aggr]   (foll) {Following}
             node[medium, below left of=foll] (add2) {+}
             (aggr) edge node {} (add2)
             (foll) edge node {} (add2);
    \path (add1.south)  +(0,-1.2) node (floc) [format] {Flocking};
    \path (add2.south)  +(0,-1.2) node (surr) [format] {Surrounding};
    \path[-] node[medium, below left of=surr] (add3) {+};
    \path (add3.south)  +(0,-1.2) node (herd) [format] {Herding}
             (floc) edge node {} (add3)
             (surr) edge node {} (add3)
             (add2) edge node {} (surr)
             (add1) edge node {} (floc)
             (add3) edge node {} (herd);
\end{tikzpicture}
\caption{Ejemplo de combinación de comportamientos básicos} \label{hfs} 
 
\end{center}
\end{figure}

\subsubsection{Combinaciones Temporales de Comportamientos}

Los comportamientos básicos y sus combinaciones directas permiten alcanzar y mantener ciertas metas. Por ejemplo, \textit{dispersion} hace que todos los agentes se encuentren a una distancia mínima mientras que \textit{following} mantiene una fila de agentes en movimiento, los cuales se encuentran a una distancia dada de sus vecinos. Para poder realizar tareas de más alto nivel definidas por múltiples objetivos secuenciales, es necesario combinar temporalmente de forma apropiada los comportamientos básicos (ver figura \ref{temp}). Para que esto sea posible, es necesario confiar en la habilidad de los agentes para percibir el estado que origina el cambio de comportamiento. Si se cuenta con esta habilidad, es posible diseñar maquinas de estados finitos que generen una gran variedad de comportamientos multi-objetivo. Este método es ilustrado en la implementación de \textit{foraging} (figura \ref{temp}).


\tikzstyle{block} = [draw, fill=blue!20, rectangle, minimum height=3em, minimum width=6em]
\tikzstyle{sum}   = [draw, fill=blue!20, circle, node distance=3cm]
\tikzstyle{add}   = [circle, draw, thin, fill=green!20, minimum height=2.5em]
\tikzstyle{pinstyle} = [pin edge={to-,thin,black}]

\begin{figure}[ht]
\begin{center}

\begin{tikzpicture}[auto, node distance=2cm]
    \node [block] (safe) {$safe-wandering$};
    \node [sum,   right of=safe] (sum1) {};
    \draw [to-] (sum1) -> node {} (safe);

    \node [block, below of=safe] (disp) {$dispersion$};
    \node [sum,   right of=disp] (sum2) {};
    \draw [to-] (sum2) -- node {} (disp);

    \node [block, below of=disp] (homi) {$homing$};
    \node [sum,   right of=homi] (sum3) {};
    \draw [to-] (sum3) -- node {} (homi);

    \node [block, below of=homi] (foll) {$following$};
    \node [sum,   right of=foll] (sum4) {};  
    \draw [to-] (sum4) -- node {} (foll);

    \node [add, below right of=sum1, node distance=4cm, pin={[pinstyle]below:Condiciones de sensores}, pin={[pin edge={-to,thin,black}]right:\textbf{foraging}}] (add1) {X};
    \draw [to-] (sum1) -- node {} (add1);

\end{tikzpicture}

\caption{Implementación de  \textit{foraging} utilizandfo una combinación temporal de \textit{safe
wandering}, \textit{dispersion}, \textit{homing}, y \textit{following}} \label{temp} 
 
\end{center}
\end{figure}


En \textit{foraging}, el objetivo de alto nivel del grupo es recolectar objetos del entorno y llevarlos a un determinado lugar. Además de contar con los comportamientos básicos, los agentes son capaces de buscar objetos, recogerlos y llevarlos. \textit{Foraging} se inicia con la \textit{dispersion}, después \textit{safe-wandering}. Cuando se encuentra un objeto se activa \textit{homing}; encontrar un agente con una tarea inmediata diferente, genera \textit{safe-wandering} apartándose del objeto. Mientras que encuentrar otro agente con la misma tarea inmediata activa\textit{flocking}. Cuando se llega al lugar denominado \textit{home} y se deposita el objeto, se activa \textit{dispersion} si se encuentran varios agentes en este sitio, o  \textit{safe-wandering} si el robot se encuentra solo.

\tikzstyle{block} = [draw, fill=blue!20, rectangle, minimum height=3em, minimum width=6em]
\tikzstyle{sum}   = [draw, fill=blue!20, circle, node distance=3cm]
\tikzstyle{add}   = [circle, draw, thin, fill=green!20, minimum height=2.5em]
\tikzstyle{pinstyle} = [pin edge={to-,thin,black}]

\begin{figure}[ht]
 
\begin{center}

\begin{tikzpicture}[auto, node distance=2cm]
    \node [block] (safe) {$safe-wandering$};
    \node [sum,   right of=safe] (sum1) {};
    \draw [to-] (sum1) -> node {} (safe);

    \node [block, below of=safe] (disp) {$dispersion$};
    \node [sum,   right of=disp] (sum2) {};
    \draw [to-] (sum2) -- node {} (disp);

    \node [block, below of=disp] (homi) {$homing$};
    \node [sum,   right of=homi] (sum3) {};
    \draw [to-] (sum3) -- node {} (homi);

    \node [block, below of=homi] (foll) {$following$};
    \node [sum,   right of=foll] (sum4) {};  
    \draw [to-] (sum4) -- node {} (foll);

    \node [add, below right of=sum1, node distance=4cm, pin={[pinstyle]below:Condiciones de sensores}, pin={[pin edge={-to,thin,black}]right:\textbf{foraging}}] (add1) {X};
    \draw [to-] (sum1) -- node {} (add1);

\end{tikzpicture}

\caption{Implementación de  \textit{foraging} utilizandfo una combinación temporal de \textit{safe
wandering}, \textit{dispersion}, \textit{homing}, y \textit{following}} \label{temp} 
 
\end{center}
\end{figure}

La combinación es una tarea simple ya que, los conflictos entre dos o más agentes, (cada uno de ellos ejecutando un comportamiento diferente) son resueltos uniformemente gracias a la homegeneidad de los agentes. Ya que todos los agentes comparten la misma estructura objetivo, ellos responderán de forma consistente a las condiciones del entorno. Por ejemplo, si un grupo de agentes se dirigen hacia \textit{home} y encuentra varios agentes dispersos, la diferencia en los estados externos puede inducir a los agentes del grupo del mismo tipo o a los agentes dispersos de cualquier tipo, es decir, dividiendo o especializando al grupo de nuevo.


%################################################################################################################
%####################################################################### MRS FORMALISM DEFINITIONS AND NOTATION
%################################################################################################################

\section{Formalismo en Sistemas Multi-Robot (MRS)\cite{CVJ05}}
\begin{figure}[ht]
 
\begin{center}

\tikzstyle{sensor}=[draw, fill=blue!20, text width=15em, text centered, minimum height=2.5em]
\tikzstyle{naveqs} = [sensor, text width=6em, fill=blue!50, minimum height=8em, rounded corners]
\def\blockdist{7}
\begin{tikzpicture}
    \node (naveq) [naveqs] {Analysis};
    \path (naveq.0)+(-\blockdist,0) node (synt) [naveqs] {Syntesis};
    \path (naveq.south west)+(-1.6,-1.4) node (INS) {Automated Controller Syntesis};

    \draw [to-] (naveq.90) .. controls +(up:1cm) and +(up:1cm) .. node [above, sloped]  {Robot Controller} (synt.90) ;
    \draw [-to] (naveq.-90) .. controls +(up:-1cm) and +(up:-1cm) .. node [above, sloped]  {Task Performance} (synt.-90) ;
    % Draw a rounded box around naveq & synt
    \begin{pgfonlayer}{background}
        \path (synt.west |- naveq.north)+(-.6,1.6) node (a) {};
        \path (INS.south -| naveq.east)+(+0.6,-0.4) node (b) {};
        \path[fill=blue!20,rounded corners, draw=black!50, solid] (a) rectangle (b);
    \end{pgfonlayer}
    \path (naveq.north) +(2,2.5) node (formal) [sensor] {Formal Understanding of Coordinated RMS};
    \path (naveq.south) +(2,-3) node   (coord) [sensor] {Coordinated RMS};
    \path (synt.north)  +(-2,2.5) node (defini) [sensor, fill=red!50] {Formal Definitions World, Task, Robots};

    \draw [-to] (naveq.east)+(.6,0) .. controls +(right:1.5cm) and +(down:1cm) ..  (formal.-20) ;
    \draw [-to] (naveq.east)+(.6,0) .. controls +(right:1.5cm) and +(up:1cm) ..     (coord.20) ;
    \draw [to-] (synt.west)+(-.6,0) .. controls +(left:1.5cm) and +(down:1cm) ..   (defini.-160) ;

\end{tikzpicture}

  \caption{Metodología de Diseño de controladores para un MRS.} \label{meth}
\end{center}
\end{figure}

\subsection{Mundo}
El mundo, W, es el entorno en el cual se espera que el MRS realice una determinada tarea. Se asume que el mundo es Markoviano, poblado por un número finito de robots R, y el estado es un elemento del grupo finito de posibles estados S. El estado del mundo en un tiempo \textit{t} se denota como:
\\
$S^{t}=\Xi_{1} X \cdot \cdot \cdot \Xi_{m}$

donde cada $\Xi_{i} \in \mathcal{S}$ representa el dominio de una característica individual del mundo. Este grupo de características puede contener muchos elementos dependientes del dominio; incluyendo la posición física de los robots, valores de los estados internos de cada robot, la localización, o relaciones de proximidad de los artefactos físicos presentes en el mundo. El estado del mundo $S$ representa el dominio de todas las posibles combinaciones de valores sobre estas características individuales.

$\left\lbrace A_{r\in\mathcal{R}}\right\rbrace$ es un grupo de acciones que cada robot \textit{r} puede ejecutar. $A^{t}_{r}$ representa la acción que cada robot \textit{r} hace en un tiempo \textit{t}. $\left\lbrace X_{r\in\mathcal{R}}\right\rbrace$ es el conjunto de observaciones que cada robot puede hacer. $X^{t}_{r}$ representa la observación que un robot puede hacer en un tiempo \textit{t}. Una observación esta formada por información externa accesible al robot y formalmente representa un un subgrupo del estado del mundo. La función probabilística observación:

$O(s,x)=P_{r}(X^{t}_{r} = x |S^{t}=s)$ \\

da la probabilidad que en un tiempo $t$ la observación $x$ se realice en el estado $s$ \\

El mundo esta definido por una función de transición de estados probabilística:

$P(s,a,s')=P_{r}(S^{t+1}=s'|S^{t}=s,A^{t}_{r}=a)$ \\

la cual declara que la probabilidad del estado del mundo en el tiempo $t+1$ es $s'$ dado que el estado del mundo en el tiempo $t$ fué $s$ y un robot $r$ ejecutó una acción $a$ en el tiempo $t$.

\subsection{Task}

Una tarea $T$ se define como un grupo de estados del mundo y transiciones de estado del mundo representadas por un grafo acíclico directo (DAG). En el DAG para una tarea $T$, cada vértice en el grupo finito de vértices $V_{T}$ es un único estado del mundo. Para cada vértice $u \in V_{T}$, todos los vértices $v$, tales que $\left\lbrace u,v \right\rbrace \in E_{T}$, son llamados \textit{hijos} de $u$. Cada lado en el grupo finito de lados $E_{T}$ entre los vértices $E_{T}=\left\lbrace(u,v) |u,v \in V_{T}\right\rbrace$ representa una acción $a$ tal que $P(u,a,v)>0$

Existe exactamente un vértice en el grafo denotado como $u\_start_{T} \in V_{T}$ que corresponde al estado inicial del mundo. Un sub-grupo de vértices del grafo son marcados como vértices terminales y se denotan como $u\_term_{T} \subseteq V_{T}$. Por lo tanto, debe existir un camino a través del grafo para cada vertice en $V_{T}$ hacia al menos un vertice en $u\_term_{T}$ (ver Figura \ref{meth}.

Si a cualquier tiempo $t, s_{t} \in \subseteq u\_term_{T}$, tarea la termina. Se define una \textit{Ejecución correcta de tarea} cuando las acciones combinadas de los robots hacen que el estado del mundo vayan del nodo inicial al nodo terminal. Si las acciones de los robots hacen que el estado del mundo vaya de un estado $s_{i}$ a un estado $s_{j}$ en el cual no existe un lado en $E_{T}$ que conecte los vertices correspondientes del grafo, la tarea \textit{no se ejecuta correctamente} y la ejecución de la misma termina inmediatamente.

\tikzstyle{state}=[circle,fill=blue!20,thick, inner sep=0pt,minimum size=10mm]
\tikzstyle{ends} =[circle,fill=red!20, thick, inner sep=0pt,minimum size=10mm]

\begin{figure}[h]
\begin{center}

\begin{tikzpicture}[auto,node distance=3cm, semithick]
\node (S0)  at ( 0,0)     [ends]  {S0};
\node (S2)  at ( 0,-1.5)  [state] {S2};
\node (S12) at (1.5,1.5)  [state] {S12};
\node (S11) at (1,-4)     [state] {S11};
\node (S7)  at (3,3)      [state] {S7};
\node (S10) at (2,-1)     [state] {S10};
\node (S4)  at (4,0)      [state] {S4};
\node (S5)  at (4.5,1.5)  [ends]  {S5};
\node (S13) at (7,0.5)    [state] {S13};
\node (S8)  at (4.5,-1.5) [state] {S8};
\node (S1)  at (7,-1.5)   [state] {S1};
\node (S9)  at (3.5,-3.5) [state] {S9};
\node (S3)  at (5,-4.5)   [ends]  {S3};

\draw [-to,snake=snake] (S0)  -- (S2);
\draw [-to,snake=snake] (S0)  -- (S10);
\draw [-to,snake=snake] (S12) -- (S0);
\draw [-to,snake=snake] (S12) -- (S4);
\draw [-to,snake=snake] (S12) -- (S7);
\draw [-to,snake=snake] (S10) -- (S8);
\draw [-to,snake=snake] (S10) -- (S9);
\draw [-to,snake=snake] (S10) -- (S12);
\draw [-to,snake=snake] (S11) -- (S10);
\draw [-to,snake=snake] (S11) -- (S9);
\draw [-to,snake=snake] (S9)  -- (S8);
\draw [-to,snake=snake] (S9)  -- (S1);
\draw [-to,snake=snake] (S9)  -- (S3);
\draw [-to,snake=snake] (S2)  -- (S11);
\draw [-to,snake=snake] (S8)  -- (S4);
\draw [-to,snake=snake] (S8)  -- (S1);
\draw [-to,snake=snake] (S4)  -- (S5);
\draw [-to,snake=snake] (S4)  -- (S13);
\draw [-to,snake=snake] (S13) -- (S5);
\draw [-to,snake=snake] (S7)  -- (S5);

\end{tikzpicture}
  \caption{Representación gráfica de la descripción de la tarea $T$} \label{meth}

 
\end{center}
\end{figure}

\subsection{Robot}

Cada Robot en el sistema se considera funcionalmente identico y todos los Robots ejecutan los mismos controladores.

\subsubsection{Estado Interno Persistente}
Cada robot puede mantener en memoria persistente una cantidad finita de estados, la cual, puede ser modificada por el robot y ser utilizada para tomar decisiones de control. Los Datos que se almacenan durante pocos ciclos de control (Estado de los sensores, estado de los motores, buffers de comunicaciones) no se consideran como parte del estado interno, ya que no son persistentes.

El valor del estado interno de un robot $r$, $m_{r}$ es un miembro del grupo finito: $M_{r}=\left\lbrace i_{0}, ... , i_{0}\right\rbrace$, donde $i_{0}$ es el estado interno inicial de todos los robots. Se requiere que el valor de cada estado interno sea único.

\subsection{Comunicación entre Robots}
Cada robot puede comunicarse con los demás robots en el MRS utilizando una comunicación tipo \textit{broadcast}, la cual es recibida por todos los robots y se desconoce el orígen de la señal.

El grupo de todos los posibles mensajes de comunicación que un robot $r$ puede enviar y recibir es denotado por el conjunto $C_{r}=\left\lbrace c_{0}, ..., c_{q} \right\rbrace$; es necesario que cada mensaje sea único y distinguible. El mensaje de comunicación que un determinado robot $r$ se encuentre enviando se denota como $Cs_{r}$. El conjunto de mensajes que un robot $r$ esta recibiendo se denota como $Cr_{r}$.

\subsection{Controlador}
El comportamiento del robot en el mundo se define con 3 funciones, las cuales, en conjunto reciben el nombre de $controlador$ del robot; formado por una función de acción, una función de transición de estado interno y una función de comunicación.


La \textit{funcion de acción}

$Act(x,m,c,a)= Pr(A_{r}^{t}=a | X_{r}^{t}=x, M_{r}^{t}=m, Cr_{r}^{t}=c)$

da la probabilidad de que un robot $r$ ejecute una acción $a$ dado que recibe la observación $x$, tiene un valor de estado interno $m$, y recibe el mensaje de comunicación $Cr$.

Cuando se ejecutan las acciones de la función de acción, se puede cambiar el estado del mundo. Cada robot tiene un set adicional de acciones, llamadas acciones de $competencia$, que se ejecutan cuando no se ejecutan las acciones de la función de acción. Las acciones de competencia no cambian el estado del mundo cuando se ejecutan (por lo tanto no son importantes al momento de considerar la correcta o incorrecta ejecución de una tarea) y se utilizan principalmente en acciones como navegación local y evasión de obstáculos.

La \textit{función transición de estado interno}

$IState(x,m,c,m')= Pr(M_{r}^{t+1}=m' | X_{r}^{t}=x, M_{r}^{t}=m)$

proporciona el valor del estado interno del robot $r$ en el tiempo $t+1$ dado que en el tiempo $t$ recibió la observación $x$ y el valor de su estado interno fué $m$.

La \textit{función de comunicación}
$Comm(x,c)= Pr(Cs_{r}^{t+1}=c | X_{r}^{t}=x)$

proporciona el mensaje de comunicación transmitido por el robot $r$ en el instante $t+1$, dado que en el tiempo $t$ recibió la observación $x$.

La figura \ref{controller} muestra el diseño de alto nivel del controlador y muestra el orden en el cual considera las transiciones de estado interno, envio y recepción de mensajes de comunicación, y selección de acciones.


\begin{figure}[h]
\begin{center}

% Define block styles
\tikzstyle{decision} = [diamond, draw, fill=blue!20, text width=8em, node distance=3cm, inner sep=0pt]
\tikzstyle{block}    = [rectangle,  draw, fill=white!20,  text width=22em, rounded corners, minimum height=4em]
\tikzstyle{blockc}   = [rectangle, draw, fill=white!20,  text width=22em, text centered, rounded corners, minimum height=4em]
\tikzstyle{line}     = [draw, -latex']
    
\begin{tikzpicture}[node distance = 2cm, auto]
    % Place nodes
    \node [blockc]                    (expert)   {Execute\_Controller()};
    \node [blockc, below of=expert]   (init)     {$m \leftarrow m_{0}$};
    \node [blockc, below of=init]     (identify) {$x \leftarrow $ current observation};
    \node [blockc, below of=identify] (evaluate) {$c_{r} \leftarrow $ communications being received};
    \node [block, below of=evaluate]  (decide)   {$\textbf{IF}$ $\exists m'(IState(x,m,c,m'))>0$\\
                                                          $\qquad m\leftarrow m'$ with  prob.  $IState(x,m,c,m')$};
    \node [block, below of=decide]    (comm)     {$\textbf{IF}$ $\exists c(Comm(x,c))>0$\\
                                                          $\qquad$ send communication $c$ with prob. $Comm(x,c)$};
    \node [block, below of=comm]      (act)      {$\textbf{IF}$ $\exists a(Act(x,m,c_{r},a))>0$\\
                                                          $\qquad$ execute action $a$ with prob. $Act(x,m,c_{r},a)$\\
                                                          \textbf{else}\\
                                                          $\qquad$ execute desired competency actions};
    % Draw edges
     \path [line] (expert)   -- (init);
     \path [line] (init)     -- (identify);
     \path [line] (identify) -- (evaluate);
     \path [line] (evaluate) -- (decide);
     \path [line] (decide)   -- (comm);
     \path [line] (comm)     -- (act);
     \path [draw, to-] (identify.east) -| (5,-14) -| (act.south);
\end{tikzpicture}
  \caption{Descripción de alto nivel del controlador} \label{controller}
\end{center}
\end{figure}

\subsection{Taxonomia del controlador MRS}

Para realizar la taxonomía del controlador se tienen en cuenta las siguientes características:

\begin{enumerate}
 \item Selección de acción determinista o probabilista ($DAct$ o $PAct$):
 \item Capacidad de mantener un estado interno persistente  ($IS$ o $NoIS$)
 \item Capacidad de comunicación inter-robot o sin comunicación ($Comm$ o $NoComm$)
\end{enumerate}

\begin{figure}[ht]
 
\begin{center}

\tikzstyle{sensor} = [draw, fill=blue!20, text width=15em, text centered, minimum height=2.5em]
\tikzstyle{naveqs} = [sensor, text width=9em, fill=blue!20, minimum height=3em, rounded corners]
\begin{tikzpicture}
    \node (node0)                              [naveqs] {DAct-IS-NoComm};
    \path (node0.east)+(3,0)      node (node1) [naveqs] {DAct-IS-Comm};
    \path (node0.south)+(0,-2)    node (node2) [naveqs] {PAct-Is-NoComm};
    \path (node1.south)+(0,-2)    node (node3) [naveqs] {PAct-Is-Comm};

    \path (node0.north west)+(-1,1.5)  node (node4) [naveqs] {DAct-NoIS-NoComm};
    \path (node2.south west)+(-1,-1.5) node (node5) [naveqs] {PAct-NoIS-NoComm};
    \path (node1.north east)+(1,1.5)   node (node6) [naveqs] {DAct-NoIS-Comm};
    \path (node3.south east)+(1,-1.5)  node (node7) [naveqs] {PAct-NoIS-Comm};

    \draw [-to, dashed] (node0.east)  -- (node1.west);
    \draw [-to, dashed] (node2.east)  -- (node3.west);
    \draw [-to, dashed] (node0.south) -- (node2.north);
    \draw [-to, dashed] (node1.south) -- (node3.north);

    \draw [-to, dashed] (node4.east)  -- (node6.west);
    \draw [-to, dashed] (node5.east)  -- (node7.west);
    \draw [-to, dashed] (node4.-120)  -- (node5.120);
    \draw [-to, dashed] (node6.-120)  -- (node7.120);

    \draw [-to, dashed] (node4.-20)   -- (node0.156);
    \draw [-to, dashed] (node5.20)    -- (node2.-156);
    \draw [-to, dashed] (node6.-156)  -- (node1.20);
    \draw [-to, dashed] (node7.156)   -- (node3.-20);

%     \draw [-to] (naveq.east)+(.6,0) .. controls +(right:1.5cm) and +(up:1cm) ..     (coord.20) ;
%     \draw [to-] (synt.west)+(-.6,0) .. controls +(left:1.5cm) and +(down:1cm) ..   (defini.-160) ;
% 
\end{tikzpicture}

  \caption{Metodología de Diseño de controladores para un MRS.} \label{meth}
\end{center}
\end{figure}



