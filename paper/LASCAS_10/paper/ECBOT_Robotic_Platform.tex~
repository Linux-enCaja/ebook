\documentclass[journal,letterpaper]{IEEEtran}
\usepackage[latin1]{inputenc}
\usepackage{enumerate}
\usepackage{cite}      
\usepackage{graphicx}  
\usepackage{psfrag}    
\usepackage{subfigure} 
\usepackage{multicol}
\usepackage{multirow}
\usepackage{colortbl}
\usepackage{floatflt}
\usepackage{amsmath}   % From the American Mathematical Society
\usepackage[mathscr]{euscript}%Para letra en modo matemï¿½ico
\usepackage{pst-all,pstcol,graphics,graphpap,amsmath,amssymb,latexsym,array}


\usepackage{listings}
\lstset{language=C} 
% \lstset{ basicstyle=\small, keywordstyle=\color{blue}\bfseries, identifierstyle=, commentstyle=\color{gray}, showstringspaces=false}
\lstset{backgroundcolor=\color{white},frame=single,emph={EMPTY},emphstyle=\color{white}, showstringspaces=false}


\newpsobject{grilla}{psgrid}{subgriddiv=1,griddots=10,gridlabels=6pt}
\interdisplaylinepenalty=2500
\usepackage{array}

\hyphenation{semi-conduc-tor }

\DeclareMathOperator{\sen}{sen}

\begin{document}
\bibliographystyle{unsrt}
\title{ECBOT: Arquitectura Abierta para Robots Móviles}
\author{Carlos Iván Camargo -- Universidad Nacional de Colombia\\\ cicamargoba@unal.edu.co}

\markboth{ECBOT: Arquitectura Abierta para Robots Móviles}{Shell \MakeLowercase{\textit{et al.}}: Bare Demo of IEEEtran.cls for Journals}


\maketitle

\IEEEpeerreviewmaketitle

\begin{abstract}
Este artículo presenta el trabajo realizado en el diseño de una plataforma abierta para robótica móvil, enfatizando sus puntos más importantes: la arquitectura Software y Hardware. Esta plataforma permite la ejecución de Linux de forma nativa, lo que posibilita la ejecución de un servidor Player y la utilización del simuladores como Stage(2D) / Gazebo (3D). La última parte de este artículo presenta algunas aplicaciones de la plataforma y los planes de utilización a futuro.

\end{abstract}

\begin{keywords}
Sistemas Embebidos, Robótica Móvil, Linux, Player.
\end{keywords}

% &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
%                                                                                         INTRODUCCIÓN
% &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
\section{Introducción}

La robótica Móvil representa un campo de investigación que crece rápidamente. En la actualidad existe un gran número de 
grupos de investigación que trabajan en el desarrollo de técnicas de auto-organización para sistemas Multi-Robot, entre los que se encuentran: El proyecto Swarm-bots \cite{swarmbot-ascona02}, \cite{balnolpar02}, Interaction Labs (USC) \cite{JM03} \cite{JaMJM05}, Autonomous System Lab (EPFL),  MIT Computer Science and Artificial Intelligence Laboratory \cite{JM06}. De las experiencias obtenidas de estos proyectos, se deduce, que para desarrollar algoritmos de inteligencia artificial, es necesario contar con plataformas Hardware y Software que permitan validar los algoritmos y modelos computacionales propuestos. La característica común de los proyectos ya mencionados es la implementación física de los algoritmos sobre robots reales, lo cual separa estos trabajos de investigaciones similares en el área de los Sistemas Multi-Agente, los cuales son desarrollados en plataformas Software.

ECBOT fue desarrollado en el Departamento de Ingeniería Eléctrica y Electrónica de la Universidad
Nacional de Colombia, con el objetivo de proporcionar una plataforma \textbf{abierta} Hardware y Software de bajo costo que permita el
desarrollo de aplicaciones en Sistemas Multi-Robot (MRS). El eje central del desarrollo Hardware es el sistema operativo (OS) Linux, ya que este impone requerimientos que de cierta forma definen la arquitectura del componente Hardware del dispositivo. Por otro lado, la columna vertebral del sistema Software es el proyecto \textit{Player/Stage}\cite{BGRTV03}, el cual, suministra funciones de alto nivel que encapsulan el manejo tedioso de bajo nivel de los sensores y actuadore, haciendo posible que la programación del Robot se realice en una variedad de lenguajes de programación como Java, Lisp, Python, C/C++, etc.

Se presenta una plataforma robotica comparable en capacidades Software y Hardware a las plataformas comerciales más utilizadas en el área. A continuación se listan dos de las plataformas más populares, resaltando sus recursos Software y Hardware así como su costo.

\small
\begin{itemize}
 \item \textbf{Khepera III}
  \begin{itemize}
    \item Procesador: DsPIC y Xscale @ 400MHz
    \item Movimiento: 2 Servo motores DC
    \item Sensores, Entrada/Salida: 
      \begin{itemize}
         \item 9 sensores Infrarojos de proximidad y luz de ambiente
         \item 2 sensores Infrarojos para seguimiento de línea
         \item 5 Sensores de Ultrasonido
         \item 16 I/O Digitales, 8 Analogas
         \item 2 Leds Programables
      \end{itemize}
    \item Comunicación:
      \begin{itemize}
         \item Puerto serie Standard
         \item Comunicación USB
         \item Ethernet Inalámbrico
      \end{itemize}
    \item Simuladores: WEBOTS\footnote{http://www.k-team.com}
    \item Herramientas de Desarrollo: GNU TOOLS
    \item Costo: 2950 USD
  \end{itemize}

 \item \textbf{EPFL e-puck \footnote{http://www.e-puck.org}}
  \begin{itemize}
    \item Procesador: DsPIC
    \item Movimiento: 2 Servo motores DC
    \item Sensores, Entrada/Salida: 
      \begin{itemize}
         \item 8 sensores Infrarojos de proximidad y luz de ambiente
         \item 1 Acelerómetro
         \item 3 micrófonos
         \item 1 camara de color.
         \item 9 Leds Programables
      \end{itemize}
    \item Comunicación:
      \begin{itemize}
         \item Puerto serie Standard
         \item Puerto Infrarojo
         \item Enlace Bluetooth
      \end{itemize}
    \item Simuladores: WEBOTS
    \item Herramientas de Desarrollo: GNU TOOLS
    \item Costo: 1100 USD
  \end{itemize}

\end{itemize}
\normalfont


\section{Arquitectura Global de ECBOT}

ECBOT está formado por la unión de dos grandes componentes: El Componente Hardware y el Componente Software, el primero constituye el dispositivo físico mediante el cual se interactúa con el entorno y sobre el cual el componente Software implementa un determinado algoritmo. Para mayor comprensión primero se realizará la presentación de la Arquitectura Software.

\subsection{Arquitectura Software}
La columna vertebral del componente Software es el proyecto Player/Stage, el cual, es el resultado de un proyecto de investigación del Grupo de Investigación en Robótica de la University of Southern California. Este proyecto esta dividido en tres partes: 

\begin{enumerate}
 \item \textbf{Player} Es un servidor que proporciona una interfaz flexible a una gran variedad de sensores y actuadores. Como puede verse en la Figura \ref{player_arch} utiliza un modelo cliente/servidor basado en sockets TCP, su principal característica es que permite el manejo de los sensores y actuadores a través de una interfaz de programación de alto nivel, lo cual permite que los programas de control del robot sean escritos en cualquier lenguaje y puedan ser ejecutados en cualquier plataforma\footnote{También es posible que el cliente y el servidor se ejecuten en el mismo robot.} (cliente) que posea una conexión de red con el robot (servidor). Además, Player soporta múltiples conexiones concurrentes de clientes, lo cual es muy útil en estudios de control descentralizado. 

\begin{figure}[h]
  \begin{center} \includegraphics[scale=.3]{./images/player_arch} \end{center}
  \caption{Arquitectura de Player. \cite{BGKS00}}\label{player_arch}
\end{figure}
 
 \item \textbf{Stage} Es un simulador escalable; que simula robots que se mueven y realizan operaciones de sensado en un entorno de dos dimensiones, estos robots son controlados por Player. Stage proporciona robots virtuales los cuales interactúan con dispositivos simulados. En la Figura \ref{stage_ss} se puede observar una simulación multi-robot utilizando las librerías de Stage; una de las caracteristicas más atractivas del proyecto Player-Stage es que permite la creación de sensores y actuadores que simulan el comportamiento de los dispositivos reales.

\begin{figure}
  \begin{center} \includegraphics[scale=.4]{./images/stage} \end{center}
  \caption{Captura del simulador Stage. }\label{stage_ss}
\end{figure}
 
 \item \textbf{Gazebo} Es un simulador multi-robot 3D. A diferencia de Stage que fué diseñado para simular grupos numerosos de robots, gazebo simula el comportamiento de poblaciones pequeñas de robots (menos de 10).
\end{enumerate}
 


\subsubsection{Arquitectura Hardware}

La mayoría de los robots que utilizan Player utilizan el puerto serie para conectarse con el robot \footnote{Roomba: http://www.irobot.com, Khepera: http://www.k-team.com, Pioneer: http://www.activrobots.com/} y es necesario que un dispositivo externo ejecute el servidor de Player y realice las tareas control por este medio, esto obliga a tener una conexión física entre el dispositivo en el que se está ejecutando el servidor de player y el robot, lo cual resulta poco práctico en algunas aplicaciones. Algunos fabricantes de robots\footnote{Garcia: http://www.acroname.com} solucionaron este problema adicionando dispositivos inalámbricos (BlueTooth, ZigBee) para permitir la creación de ``puertos seriales inalámbricos''; sin embargo, esto no elimina la necesidad de un dispositivo externo que se encargue de ejecutar el servidor de Player. Por esta razón, uno de los requerimientos es que ECBOT sea capáz de ejecutar de forma nativa a Player. Para esto, es necesario que ECBOT pueda correr aplicaciones Linux, o lo que es lo mismo que soporte el sistema operativo Linux. Por esta razón el primer paso en el desarrollo de ECBOT fue el estudio de plataformas que soportaran linux Embebido, como resultado de este estudio se diseñó la plataforma abierta: ECB\_AT91 \cite{CC06}, la cual fué la base del desarrollo que dio como resultado ECBOT. En la figura \ref{ECBOT_Block} se muestra el Diagrama de Bloques de ECBOT,

\begin{figure}[h]
  \begin{center} \includegraphics[scale=.45]{./images/ECBOT_Block_2} \end{center}
  \caption{Diagrama de Bloques del componente Hardware de ECBOT.}\label{ECBOT_Block}
\end{figure}

\subsection{Especificaciones de ECBOT}

\subsubsection{Sensores y Actuadores}

Como puede verse en La Figura \ref{ECBOT_Block} ECBOT cuenta con un bus I2C encargado de realizar la interfaz con el mundo análogo (ya que el procesador central AT91RM9200 de ATmel no posee conversores A/D), seis microcontroladores de 8 bits (AVR de ATmel) permiten el manejo de los sensores y actuadores a través de este bus. Cuatro microcontroladores de 8 bits, manejan cada uno de ellos: dos sensores infrarojos de proximidad y luz de ambiente, utilizados en tareas de evasión de obstaculos y 6 LEDs (2-rojos, 2-verdes, 2-azules) que representan el estado interno del Robot; el quinto microcontrolador de 8 bits se encarga de manejar la velocidad y posición de 2 motores DC, para reducir el costo de los componentes ECBOT implementa un control de posición y velocidad de motores utilizando un método de medición de la velocidad basado en la fuerza electromotriz\cite{AZMN03}, \cite{RL04}. El bus I2C se encuentra disponible y puede ser utilizado para adicionar cualquier sensor que cumpla con su protocolo.

Adicionalmente ECBOT cuenta con una cámara digital que permite la implementación de algoritmos de seguimiento de color, una FPGA se encarga del manejo del sensor de imagen y de la comunicación con el procesador, Gracias a que ECBOT cuenta con 32MB de memoria RAM es posible capturar una imagen completa de 640x480 pixels. Adicionalmente la FPGA proporciona 10 señales de propósito general que pueden ser utilizadas para el manejo de servos o para el manejo de servo motores.

Los microcontroladores de 8 bits y la FPGA son programados por el procesador central a través de pines de Entrada/Salida de propósito general, los archivos de programación/configuración son almacenados en la plataforma y puedes ser modificados en cualquier momento; esto hace que ECBOT sea una plataforma independiente y que pueda ser programada ``en caliente''.

\subsubsection{Comunicaciones}
ECBOT proporciona 3 formas de comunicación:
\begin{itemize}
 \item Módulo WiFi: ECBOT permite la conexión de un adaptador USB 802.11, en la actualidad solo los adaptadores basados en el chip ZD1211 están soportados.
 \item Módulo 802.15.4: ECBOT cuenta con el tranceiver de Texas Instruments CC2420.
 \item Puerto Serie: En las primeras etapas del desarrollo es necesario utilizar el puerto serie para cargar las imágenes del loader, bootloader y kernel.
\end{itemize}


\subsubsection{Memorias y Dispositivos de Almacenamiento}

Se cuenta con una memoria Flash serial de 2 Mbytes donde se almacenan las imágenes del loader, bootloader y kernel, esta memoria puede ser modificada utilizando un loader que se ejecuta al inicializar la plataforma, o puede modificarse desde linux a través de un dispositivo MTD (Memory Technology Device). ECBOT permite la utilización de una memoria SDRAM de hasta 64 MBytes, la cual es utilizada como memoria de propósito general para las aplicaciones que corren bajo Linux.

ECBOT utiliza la distribución de linux \textit{Buildroot}, la cual esta basada en la librería de C  \textit{uClibc}, concebida para trabajar con sistemas embebidos. Buildroot es altamente configurable y permite seleccionar los paquetes que serán parte del sistema de archivos, lo cual optimiza el espacio requerido por este. Adicionalmente, permite la adicionar fácilmente nuevos paquetes, en nuestro caso se agregaron 3 nuevos: El servidor Player, el programador de microcontroladores para AVR: \textit{uisp \footnote{http://www.nongnu.org/uisp/}} y el programador para FPGAs: \textit{xc3sprog\footnote{http://www.rogerstech.co.uk/xc3sprog/}}. El sistema de archivos generado por Buildroot y las aplicaciones necesarias para el funcionamiento de ECBOT son almacenadas en una memoria SD.


\subsubsection{Unidad Central de Procesamiento}

El cerebro de ECBOT es un procesador de 32 Bits de la familia ARM de ATMEL el AT91RM9200, que corre a 180 MHz. Este procesador goza de gran popularidad dentro del grupo de desarrolladores de drivers para Linux, por lo que casi la totalidad de sus periféricos están soportados. Esto facilita la creación del soporte necesario para la board; la información necesaria sobre el \textit{port} de Linux a la plataforma se puede encontrar en \cite{CCNC}.

\subsubsection{Fotografías de la tarjeta principal de ECBOT}

En las Figuras \ref{ecbot_top_specs} y \ref{ecbot_bot_specs} se muestra el lado de componentes y el lado de soldadura de la tarjeta principal de ECBOT; en ellas podemos observar la localización de los componentes, la cual está fuertemente influenciada por el robot \textit{e-puck}\cite{entry-2} del EPFL.

\begin{figure}[h]
  \begin{center} \includegraphics[scale=.4]{./images/ECBOT2_TOP_Specs} \end{center}
  \caption{Lado de Componentes de la tarjeta principal de ECBOT.}\label{ecbot_top_specs}
\end{figure}

\begin{figure}[h]
  \begin{center} \includegraphics[scale=.4]{./images/ECBOT2_BOT_Specs} \end{center}
  \caption{Lado de soldadura de la tarjeta principal de ECBOT.}\label{ecbot_bot_specs}
\end{figure}



\section{Servidor Player para la plataforma ECBOT}

Una de las características más atractivas del proyecto Player/Stage es que es de carácter libre y su código fuente está disponible, gracias a esto, fué posible escribir un driver que soportara a ECBOT. Este driver permite controlar:

\begin{enumerate}
 \item El dispositivo de seguimiento de color implementado en la FPGA.
 \item La velocidad y posición de 2 motores.
 \item El color de los LEDs.
 \item La activación y la lectura de los sensores InfraRojos de proximidad.
\end{enumerate}
 
La figura \ref{ECBOT_player_server} muestra gráficamente la arquitectura del servidor Player de ECBOT, como puede verse, el servidor está encargado de comunicarse con los sensores (cámara y sensores InfraRojos), procesar esta información y enviarla al cliente, donde el algoritmo de control por intermedio de un generador de comandos del servidor controla los actuadores (LEDs y motores). En esta misma figura se muestra una base de bajo costo para la plataforma ECBOT. 

\begin{figure}[h]
  \begin{center} \includegraphics[scale=.7]{./images/ECBOT_player_server} \end{center}
  \caption{Servidor Player de ECBOT.}\label{ECBOT_player_server}
\end{figure}

A manera de ejemplo a continuación se muestran dos archivos típicos al utilizar Player/Stage. El primer archivo, muestra la configuración para el cliente de Player:

\footnotesize
\lstset{backgroundcolor=\color{lightgray},frame=none,emph={EMPTY},emphstyle=\color{white}, showstringspaces=false}
\begin{lstlisting}[numbers=none]
driver
(
  name "ecbot"
  provides ["position2d:0" "ir:0" "blinkenlight:0"]
)
\end{lstlisting}

\normalsize

Y el segundo el código para un cliente que controla la velocidad de los motores, el color de los leds y lee el estado de los sensores InfraRojos:

\footnotesize
\lstset{backgroundcolor=\color{lightgray},frame=none,emph={EMPTY},emphstyle=\color{white}, showstringspaces=false}
\begin{lstlisting}[numbers=left]
int main(int argc, char *argv[])
{
  using namespace PlayerCc;
  using namespace std;

  int preferredTurn = 1;

  std::cout <<"connecting to robot" << std::endl;
  PlayerClient    robot( "ecbot" );

  std::cout <<"connecting to ir proxy"<< std::endl;
  IrProxy         ir(&robot,0);

  std::cout <<"connecting to pos proxy"<< std::endl;
  Position2dProxy pp(&robot,0);

  std::cout <<"connecting to LED proxy"<< std::endl;
  BlinkenLightProxy bp(&robot,0);


  pp.SetMotorEnable( true );

  bp.SetColor(0xf0,0x01,0x01); // LED color RED

  for(;;)
  {
    char turnrate = 0x40;
    char speed    = 0x40;
    unsigned char IR[8];

    robot.Read();
    ++samples;

    bp.SetColor(0x01,0xf0,0x01); // LED color GREEN
    pp.SetSpeed(speed, turnrate);// Forward
    for(int i=0; i<8; i++){
      IR[i] = ir.Voltages[i];    // Read IRs
    }
  }
}
\end{lstlisting}

\normalsize

En la línea 9 se realiza la conexión con el servidos de Player del robot \textit{ecbot} \footnote{\textit{ecbot} es la dirección IP del robot dentro de la red}; en 12, 15 y 18 se definen los \textit{proxies} IR, Position2d y BlinkenLight, los cuales permiten la interacción con los sensores y actuadores del robot. En  las líneas 21 y 34 se cambia el color de los LEDs a Rojo y verde respectivamente; en la línea 35 se fija la velocidad de los motores de tal forma que el robot avanza; finalmente, en la línea 37 se lee el valor de los sensores de proximidad. Como puede verse de estos dos ejemplos, la utilización del proyecto Player/Stage facilita la implementación de algoritmos de control en robotica.


\section{Conclusiones y Trabajo Futuro}

La contribución de este trabajo es el desarrollo de una plataforma \textbf{abierta} Hardware y Software para aplicaciones de robótica móvil. A continuación se listan las tareas que se realizaron para la creación de esta plataforma:

\begin{itemize}
 \item Adecuar Linux para que se ejecute en un procesador ARM de 32 bits: Para esto fué necesario, la modificación de drivers existentes y la definición de una nueva plataforma.
 \item Diseño de las placas de Circuito Impreso: Para llegar al prototipo final, se implementaron tres tarjetas que permitieron probar los diferentes módulos de ECBOT. La primera se diseñó para probar el procesador y para realizar la implementación de Linux; en la segunda tarjeta se probó la interfaz del procesador y una FPGA, y la comunicación I2C con microcontroladores de 8 bits para permitir la lectura de señales análogas. La tercera es la que se muestra en la Figura \ref{ECBOT_final} y corresponde a la plataforma final.
 \item Creación o modificación de software para programación de los microcontroladores de 8 bits y configuración de la FPGA.
 \item Escritura de las rutinas de control de los sensores y actuadores seleccionados: Motores, sensores infraarojos, y LEDs.
 \item Adaptación del software Player/Stage para dar soporte a la plataforma robotica.
 \item Creación de los mnódulos de interfaz entre el procesador y la FPGA, e implementación del procesamiento de imagen en la FPGA. 
\end{itemize}

\begin{figure}[h]
  \begin{center} \includegraphics[scale=.6]{./images/ECBOT_movil} \end{center}
  \caption{Servidor Player de ECBOT.}\label{ECBOT_final}
\end{figure}

Todo el software, hardware y archivos necesarios para la fabricación de ECBOT se encuentran disponibles, su distribución es libre, esto es lo que da a la plataforma la categoría \textbf{abierta}.

 El componente Hardware de esta plataforma permite la ejecución del servidor Player de forma nativa, lo cual simplifica la implementación de algoritmos de control. Por otro lado, se presenta una plataforma abierta, es decir, los archivos necesarios para la fabricación de la tarjeta de circuito impreso, los esquemáticos, el firmware de los microncontroladores y su respectivo código fuente, los cambios requeridos al kernel de Linux  para realizar estudios sobre el sistema operativo Linux en sistemas Embebidos.

Este trabajo es el punto de partida en el estudio de técnicas de auto-coordinación en sistemas Multi-Robot, ECBOT fué diseñada de tal forma que permita la realización de experimentos clásicos en este estudio. El siguiente paso consiste en la fabricación de un grupo de 10 Robots y en la implementación de algoritmos que permitan a este grupo realizar un trabajo determinado de forma autónoma.

\section{}
\bibliography{biblio_EL}

\begin{floatingfigure}[l]{3cm}
 \includegraphics[scale=.3]{./images/cain}
\end{floatingfigure}
Carlos Camargo es Ingeniero Electricista de la Universidad Nacional de Colombia, Magister en Ingeniería Eléctrica de la Universidad de los Andes y Candidato a Doctor en Ingeniería Eléctrica en la Universidad Nacional de Colombia. Es profesor del Departamento de Ingeniería Eléctrica y Electrónica de la Universidad Nacional de Colombia en el área de los sistemas Digitales.



\end{document}