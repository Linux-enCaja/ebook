\documentclass[journal,letterpaper]{IEEEtran}
\usepackage[latin1]{inputenc}
\usepackage{enumerate}
\usepackage{cite}      
\usepackage{graphicx}  
\usepackage{psfrag}    
\usepackage{subfigure} 
\usepackage{multicol}
\usepackage{multirow}
\usepackage{colortbl}
\usepackage{floatflt}
\usepackage{amsmath}   % From the American Mathematical Society
\usepackage[mathscr]{euscript}%Para letra en modo matemï¿½ic
\usepackage{subfigure}

\begin{document}
\bibliographystyle{unsrt}
\title{Plataformas Roboticas Abiertas Como Herramienta de Difusión Tecnológica}
\author{Carlos Iván Camargo -- Universidad Nacional de Colombia\\\ cicamargoba@unal.edu.co}


\maketitle

\IEEEpeerreviewmaketitle

\begin{abstract}

La robótica móvil es un área que atrae muchos interesados con diferentes niveles de formación e intereses a lo largo del mundo; países en vía de desarrollo como Colombia, no son la excepción y muchos grupos de investigación y centros de formación a nivel básico, medio y profesional realizan actividades con estos dispositivos para aplicaciones en diferentes áreas del conocimiento. Sin embargo, en estos países existen muy pocos desarrollos de plataformas propias y la mayor parte es importada de países más industrializados. En este artículo se presentan dos plataformas robóticas abiertas que pueden ser utilizadas en diferentes niveles de formación como herramientas pedagógicas en diferentes áreas y como punto de partida de desarrollos comerciales; están compuestas por un componete hardware que permite la ejecución de aplicaciones de libre distribución como el sistema operativo Linux y un componente software que le permite al usuario trabajar en la solución de un problema determinado a alto nivel ocultando el tedioso manejo a bajo nivel de los sensores, actuadores y protocolos de comunicación asociados a las plataformas robóticas. El interés principal al liberar estas herramientas es la difusión del conocimiento adquirido durante su realización y de esta forma motivar al mayor número de personas posible a que construyan dispositivos digitales que den solución a problemas locales. 

\end{abstract}

\begin{keywords}
Sistemas Embebidos, Robótica Móvil, Linux, apropiación y difusión tecnológica.
\end{keywords}

% &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
%                                                                                         INTRODUCCIÓN
% &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
\section{Introducción}

La robótica Móvil representa un campo de investigación que crece rápidamente; en la actualidad existe un gran número de 
grupos que trabajan en el desarrollo de aplicaciones en diversas áreas, \cite{swarmbot-ascona02}, \cite{balnolpar02}, \cite{JM03}, \cite{JaMJM05}, \cite{JM06}, \cite{entry-2}, \cite{CC09}. En países en vía de desarrollo como Colombia, una gran parte de estas investigaciones utilizan productos  comerciales o integran componentes electrónicos y mecánicos genéricos para construir plataformas de experimentación; evitando el desarrollo local de hardware especializado; esto en gran parte se debe a la carencia de una plataforma tecnológica que permita el desarrollo de aplicaciones propias y al atraso que presenta a industria electrónica en dichos paises. 

Gracias a los avances de la industria de los semiconductores, a la invasión originada por los dispositivos digitales en las actividades humanas, y a las facilidades que ofrece la industria manufacturera asiática, se ha cambiado de forma dramática el escenario mundial en lo relacionado con el diseño y desarrollo de aplicaciones digitales, pasando de un modelo de total protección y confidencialidad a uno donde se proporciona toda la información y las herramientas necesarias para el desarrollo de dichas aplicaciones. Esto unido a la disponibilidad de aplicaciones software de libre distribución, disminuye de forma considerable la inversión necesaria para crear empresas de base tecnológica y de esta forma reducir la dependencia de paises en vía de desarrollo del mercado asiático.

Un estudio reciente \cite{CC11d} desarrollado en la Universidad Nacional de Colombia, mostró que una de las causas del atraso tecnológico en Colombia es la utilización de metodologías de diseño y tecnologías obsoletas por parte de la industria electrónica, originada en gran parte por la falta de profesionales con las habilidades necesarias para desarrollar productos comercializables que utilicen tecnología de punta, la fuerte dependencia hacia el mercado asiático, y la falta de políticas gubernamentales que protejan las industrias locales; todo esto afecta de forma considerable el mercado laboral de profesionales en el área y los obliga a aceptar salarios muy bajos o desempeñarse en actividades para las cuales no fueron fromados. Sin embargo, es posible realizar una transferencia tecnológica exitosa en el diseño de sistemas digitales, desarrollando una serie de actividades que ayuden a difundir los conocimientos asociados a dicha tecnología a diferentes niveles de formación. En \cite{CC11} se muestra la experiencia al modificar la forma tradicional de enseñanza de diseño de sistemas digitales, (utilizando tecnologías obsoletas y metodologías de diseño basadas en la experiencia del diseñador sin ayuda de herramentas CAD) introduciendo metodologías de diseño aceptadas internacionalmente \cite{Cor05}, herramientas hardware y software copyleft \cite{CC11c} (las que proporcionan toda la información necesaria para reproducirlas, modificarlas y programarlas utiizando herramientas abiertas) y una metodología basada en el proceso de diseño de un dispositivo digital que da solución a un problema local \cite{CC11}. Como resultado, se presentaron trabajos finales que superan en calidad a los presentados antes de realizar estos cambios y se percibe en los estudiantes una necesidad de crear productos que puedan convertirse en desarrollos comerciales, lo que puede ser la base de generación de empresas de base tecnológica.

\subsection{La robótica en la Educación}

La utilización de la robótica en la educación básica y media ha venido en aumento, y su uso adecuado permite el desarrollo de habilidades asociados al constructivismo (aprender haciendo), aprendizaje significativo (aprendizaje relacionado con necesidades, intereses propios) haciendo que el estudiante aprenda el valor de la nueva tecnología y como esta puede ser utilizada en dar solución a problemas comunes. Existen dos formas de utilizar la robótica en la educación \cite{DA09}: La robótica \textit{como objeto de aprendizaje}: enfocado a aspectos relacionados con el robot como construcción, programación e inteligencia artificial y la robótica como \textit{herramienta de aprendizaje}: visto como proyecto interdisciplinario que involucra ciencias, matemáticas, tecnologías de la información y comunicaciones.

En la actualidad existen plataformas comerciales que proporcionan la documentación necesaria para realizar la programación completa de sus dispositivos, pero no existen muchas que permitan realizar modificaciones en su hardware o crear nuevos productos a partir de ellas; ya que para que esto sea posible, es necesario suministrar los archivos de diseño de la placa de circuito impreso, la lista de materiales y utilizar componentes que se puedan adquirir sin firma de acuerdos de confidencialidad, así como el código fuente del software necesario para su funcionamiento. La plataformas más completas que puede ser considerada como \textit{copyleft} hardware fué desarrollada por el EPFL \cite{entry-2} proporciona los archivos gerber con los que se puede reproducir la placa de circuito impreso, pero no suministra los archivos de diseño necesarios para modificarla.

En este artículo presentamos ECBOT \cite{CC07} \cite{CC08c}, (concebida para uso universitario) y SIEBOT \cite{CC11c} (concebida para educación básica, media y profesional) como plataformas robóticas para la educación; su carácter abierto permite estudiar su funcionamiento, realizar modificaciones y desarrollar aplicaciones comerciales en otros campos diferentes a la robótica. Adicionalmente, pueden ser utilizada en la enseñanza de metodologías de diseño de sistemas digitales \cite{CC11c} \cite{CC11} proporcionando una herramienta que permita la transferencia de conocimiento en esta área. Estas plataformas encajan en la definición del hardware \textit{copyleft} y suministran toda la información necesaria \footnote{http://wiki.linuxencaja.net} para que puedan ser estudiadas, programadas, y modificadas (incluso para fines comerciales) por cualquier interesado. 

% &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
%                                                                                                ECBOT
% &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

\section{ECBOT}

ECBOT está compuesto por el componente hardware y el componente software, el primero constituye el dispositivo físico mediante el cual se interactúa con el entorno y sobre el cual el componente software implementa un determinado algoritmo.

\subsection{Arquitectura Software}
La columna vertebral del componente Software es el proyecto Player/Stage, el cual, es el resultado de un proyecto de investigación del Grupo de Investigación en Robótica de la University of Southern California. Este proyecto esta dividido en tres partes: 

\begin{enumerate}
 \item \textbf{Player:} Servidor que proporciona una interfaz flexible a una gran variedad de sensores y actuadores, utilizando un modelo cliente/servidor basado en sockets TCP; permitiendo su uso a trevés de una interfaz de programación de alto nivel, lo que permite que los programas de control del robot sean escritos en cualquier lenguaje y puedan ser ejecutados en cualquier plataforma (cliente) que posea una conexión de red con el robot (servidor). Además, Player soporta múltiples conexiones concurrentes de clientes, lo cual es muy útil en estudios de control descentralizado. 

 \item \textbf{Stage:} simulador escalable, trabaja con robots que se mueven y realizan operaciones de sensado en un entorno de dos dimensiones y son controlados por Player; proporciona robots virtuales los cuales interactúan con dispositivos físicos simulados. Una de las caracteristicas más atractivas del proyecto Player-Stage es que permite la creación de sensores y actuadores que simulan el comportamiento de los dispositivos reales teniendo en cuenta aspectos físicos como forma, peso y material.
\end{enumerate}

\subsection{Arquitectura Hardware}

Uno de los requerimientos iniciales fué la capacidad de ejecutar de forma nativa el cliente/servidor Player; para esto, es necesario que ECBOT pueda correr aplicaciones Linux; por esta razón, se diseñó la plataforma abierta \textit{ECB\_AT91} \cite{CC06}, la cual fué la base del desarrollo de ECBOT.

\begin{figure}[h]
  \begin{center} \includegraphics[scale=.35]{./images/ECBOT_Block_2} \end{center}
  \caption{Diagrama de Bloques del componente Hardware de ECBOT.}\label{ECBOT_Block}
\end{figure}

\subsection{Especificaciones de ECBOT}

\subsubsection{Sensores y Actuadores}

ECBOT cuenta con (ver figura \ref{ECBOT_Block}) un bus I2C encargado de realizar la interfaz con el mundo análogo (ya que el procesador central AT91RM9200 de ATmel no posee conversores A/D), 2 microcontroladores de 8 bits (AVR de ATmel) permiten el manejo de: seis sensores infrarojos de proximidad y luz de ambiente, y 2 motores DC utilizados en tareas de evasión de obstáculos y 8 LEDs (RGB) que representan el estado interno del Robot; para reducir el costo de los componentes ECBOT implementa un control de posición y velocidad de motores utilizando un método de medición de la velocidad basado en la fuerza electromotriz\cite{AZMN03}, \cite{RL04}. Adicionalmente, ECBOT dispone de una cámara digital que permite la implementación de algoritmos de seguimiento de color, una FPGA se encarga del manejo del sensor de imagen y de la comunicación con el procesador. Adicionalmente, la FPGA proporciona 10 señales de propósito general que pueden ser utilizadas como señales digitales de propósito general o para el manejo de servo motores. 

Los microcontroladores de 8 bits y la FPGA son programados por el procesador central a través de pines de Entrada/Salida de propósito general, los archivos de programación/configuración son almacenados en la plataforma, pueden ser transmitidos utilizando un enlace inalámbrico y pueden ser modificados en cualquier momento sin necesidad de conectores adicionales; esto hace que ECBOT sea una plataforma independiente y que pueda ser programada ``en caliente'' y de forma remota.

\subsubsection{Comunicaciones}
Se dispone de tres canales de comunicación: \textit{1 - puerto USB host} - es posible conectar cualquier dispositivo USB, como adaptadores USB-WiFi 802.11, modems 3G, EDGE, GSM, tranceivers ZigBee, etc permitiendo el control y reconfiguración de forma remota; \textit{2 - puerto Serie} En las primeras etapas del desarrollo se utiliza para cargar las imágenes del loader, bootloader y kernel, y se puede utilizar para conectar un GPS o un sensor con protocolo serial asíncrono; y \textit{puerto I2C} El bus I2C se encuentra disponible y puede ser utilizado para adicionar cualquier sensor que cumpla con su protocolo.

\subsubsection{Memorias y Sistema de archivos}

Se cuenta con una memoria Flash serial de 2 Mbytes donde se almacenan las imágenes del loader, bootloader y kernel, esta memoria puede ser modificada utilizando un loader que se ejecuta al inicializar la plataforma, o puede modificarse desde linux a través de un dispositivo MTD (Memory Technology Device). Permite la utilización de una memoria RAM tipo SDRAM de hasta 64 MBytes, suficiente para ejecutar una gran variedad de aplicaciones.

ECBOT utiliza la distribución de linux \textit{Buildroot}, la cual esta basada en la librería de C  \textit{uClibc}, concebida para trabajar con sistemas embebidos; es altamente configurable y proporciona una gran variedad de aplicaciones, las que pueden ser instaladas siguiendo las instrucciones de un script de instalación, lo que facilita la adición de aplicaciones no soportadas por la distribución oficial, en nuestro caso se agregaron 3 programas: el servidor Player portado a la plataforma ECBOT, el programador de microcontroladores para AVR: \textit{uisp} y el programador para FPGAs: \textit{xc3sprog}. El sistema de archivos generado por Buildroot y las aplicaciones necesarias para el funcionamiento de ECBOT son almacenadas en una memoria SD.

\subsubsection{Unidad Central de Procesamiento}
El cerebro de ECBOT es un procesador de 32 Bits de la familia ARM de ATMEL el AT91RM9200, que corre a 180 MHz. Este procesador goza de 
gran popularidad dentro del grupo de desarrolladores de drivers para Linux, por lo que casi la totalidad de sus periféricos están soportados. La información necesaria sobre el \textit{port} de Linux a la plataforma se puede encontrar en \cite{CC06b}


% &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
%                                                                                               SIEBOT
% &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

\section{SIEBOT}

SIEBOT integra la plataforma de desarrollo para codiseño HW/SW SIE \cite{CC11c} con una interfaz que permite el control de sensores y actuadores. La Figura \ref{SIE_arch} muestra su diagrama de bloques, en ella podemos encontrar un procesador que posee periféricos para comunicación serial (UART), memorias micro-SD, un puerto I2C, un LCD a color de 3 pulgadas, 2 entradas y salidas de audio stereo, 2 entradas análogas; una FPGA que proporciona 25 señales de entrada/salida digitales de propósito general (GPIOs) y controla un conversor análogo digital de 8 canales. Existen dos canales de comunicación entre la FPGA y el procesador: uno para controlar el puerto JTAG, lo que permite la configuración de la FPGA desde el procesador (eliminando la necesidad de cables de programación); y otro que proporciona el bus de datos, dirección y control para comunicarse con las tareas HW o periféricos implementadas en la FPGA. El procesador utilizado es un Ingenic JZ4725 (XBURST - MIPS) corriendo a 400MHz, se dispone de una memoria NAND de 2GB para almacenamiento de datos y programas, así como de una memoria SDRAM de 32 MB, permitiendo la ejecución de una gran variedad de aplicaciones Linux.

 \begin{figure}[htpb]
   \begin{center} \includegraphics[scale=.45]{./images/SIE_block_diagram.png}   \end{center}
   \begin{center} \includegraphics[scale=.4]{./images/SIE.jpg}   \end{center}
   \caption{Estructura de la plataforma de desarrollo SIE} \label{SIE_arch}
 \end{figure}

\subsubsection{Arquitectura}
Como ya se mencionó la FPGA de SIE utiliza los buses de datos, dirección y control para comunicarse con el procesador, por lo que es posible implementar un número indeterminado de perifericos en ella, los cuales pueden ser consultados en cualquier momento por el procesador con operaciones de lectura y escritura a un rango de memoria determinado por el diseñador. Esto permite la utilización de una gran cantidad de periféricos útiles en aplicaciones en robótica como sensores (que utilizan puerto serie o I2C), controladores de motores servo, generadores de señales PWM para control de motores, y otros actuadores, etc. 

\subsubsection{Comunicaciones}
SIE proporciona tres canales de comunicación: \textit{1 - puerto USB device} - permite la comunicación con un computador personal a través de un puerto serial device, este canal permite la programación de la memoria NAND no volátil con el lanzador de Linux \textit{u-boot}, la imágen del kernel y el sistema de archivos (openwrt), adicionalmente, permite el inicio de consolas remotas utilizando el protocolo \textit{ssh}; \textit{2 - puertos serie} - se dispone de dos puertos seriales con niveles de voltaje RS232 uno conectado al procesador (actualmente se conecta un GPS) y otro a la FPGA \textit{3 - puerto I2C} - puede ser utilizado para conectar una amplia gama de sensores que proporcionan su salida en este formato.

\subsubsection{Sensores y actuadores}
La tarjeta de sensores y actuadores soporta: un controlador puente-h para manejar dos motores de 6.8V, 2 encoders de cuadratura, 2 sensores de proximidad, una etapa de amplificación para 4 servomotores y 8 entradas análogas. 

\section{Interfaces para Programación de Aplicaciones}
En esta sección se presentarán dos entornos de programación abiertos, desarrolladas con el fín de abstraer las tediosas operaciones de programación a bajo nivel y configuración de la plataforma robótica SIEBOT (también es posible utilizarlas como herramientas de desarrollo de aplicaciones para ECBOT). \textit{SIE Blocks} y \textit{SIE Code Generator} permiten la realización de aplicaciones utilizando lenguajes gráficos y permiten descargarlas a la plataforma de forma automática utilizando como canal de comunicación una interfaz de red USB; dejando al usuario la programación de la funcionalidad. Las dos aplicaciones requieren el archivo de configuración de la FPGA en formato .bit y generado por las herramientas de síntesis de Xilinx, con la implementación de los periféricos necesarios para manejar los sensores y actuadores; dependiendo del nivel académico y de la aplicación se pueden suministrar diferentes archivos de configuración para la FPGA; sin embargo, el código fuente en lenguaje de descripción de hardware se encuentra disponible junto con un tutorial explicando su principio de funcionamiento, para que usuarios más avanzados los puedan ajustara sus requerimientos.

\subsection{SIE Blocks}
SIE Blocks está basado en el proyecto openblocks \cite{Roq07} desarrollado en el MIT, el cual a su vez sigue el trabajo en entornos de programación gráficos \textit{Starlogo} \cite{MR96} los cuales buscan reducir las barreras que presentan los lenguajes de programación tradicionales al ser utilizados en principiantes. La aproximación a la programación gráfica del MIT recibe el nombre de \textit{block programming} y en ella, los usuarios manipulan y conectan piezas de rompecabezas que representan objetos para construir programas; la silueta de estos bloques representa implícitamente la sintaxis del lenguaje y estos solo pueden conectarse con bloques con siluetas complementarias, eliminando la necesidad de memorizar reglas complejas y de esta forma ayudar a reducir la curva de aprendizaje. Esta aproximación ha demostrado ser muy efectiva aplicaciones comerciales como LEGO Mindstorm, Cricket LOGO y Labview.

\subsubsection{Principio de Funcionamiento}

En la Figura \ref{SIE_Blocks} se muestra una captura de pantalla de la ejecución de SIE Blocks, en ella podemos obervar un menú que contiene una serie de bloques constructores separados según su función: \textit{GPIOs, Functions, Movement, Loops, Data, Display y Math}, (es posible modificar estos bloques básicos ya que se suministra el código fuente de la aplicación \cite{Roq07}); en la zona central se pueden colocar los diferentes bloques constructores para formar un determinado algoritmo.

 \begin{figure}[htpb]
   \begin{center} \includegraphics[scale=.45]{./images/SIEBlocks.png}   \end{center}
   \caption{Interfaz gráfica de SIE Blocks} \label{SIE_Blocks}
 \end{figure}

En la parte superior, se encuentra un menú con las operaciones que puede realizar SIEBlocks. \textit{Load/save}: permite almacenar y cargar diferentes algoritmos en formato XML; \textit{connect with SIE}: establece una comunicación con la plataforma SIEBOT utilizando el protocolo \textit{ssh}; y \textit{Upload and compile}: Convierte el algoritmo a un formato XML para después ser convertido en un script que ejecutará un intérprete Lua que reside en SIEBOT. La figura \ref{SIEBLOCK_flow} resume el flujo de diseño al utilizar SIEBlocks.

 \begin{figure}[htpb]
   \begin{center} \includegraphics[scale=.45]{./images/SIEBlocks_design_flow.png}   \end{center}
   \caption{Flujo de diseño con SIEBlocks} \label{SIEBLOCK_flow}
 \end{figure}

El intérprete de Lua se encuentra en SIEBOT y recibe como entradas un script donde se indican las instrucciones a ejecutarse; para realizar operaciones sobre los sensores y actuadores se proporciona una librería (\textit{gpio.so} en este ejemplo) escrita en C, que contiene las funciones necesarias para manejo de memoria (comunicación con periféricos \textit{jz47xx\_mmap.c}) y control de pines de entrada/salida de propósito general (\textit{jz47xx\_gpio.c}), así como un archivo que encapsula estas funciones y permite su uso por parte del intérprete de Lua (\textit{sram\_gpio\_wrap.c}) en este archivo se encuentran el nombre de las funciones que se utilizarán en el script de Lua (\textit{open\_port}, \textit{clear\_pin}, \textit{set\_pin}, y \textit{gpio\_as\_output}).


\subsection{SIE\_CG}

\textit{SIE Code Generator} es desarrollado en QT y está inspirado en el simulador \textit{qucs}; permite la creación de nuevos elementos y librerías en tiempo de ejecución; no utiliza ningún lenguaje intermedio tipo Lua o Python; genera código en C a partir de la entrada gráfica y lo compila para la arquitectura XBURST - MIPS; adicionalmente, proporciona una serie de utilidades para transferir los archivos de configuración de la FPGA y el ejecutable generado por el proceso de compilación a la plataforma SIEBOT. En la figura\ref{SIECG_SS} se puede ver una captura de pantalla y en la \ref{SIECG_flow} se muestra el flujo de diseño hasta obtener el ejecutable final.


  \begin{figure}[htpb]
    \begin{center}
      \subfigure[Interfaz gráfica de SIE\_CG]{
        \includegraphics[scale=.35]{./images/SIE_CG_screenshoot.png}
        \label{SIECG_SS}
      }
      \\
      \subfigure[Flujo de diseño con SIE\_CG]{
        \includegraphics[scale=.49]{./images/SIE_CG_design_flow.png}
        \label{SIECG_flow}
      }
    \end{center}
  \end{figure}


\subsubsection{Principio de funcionamiento}

SIE\_CD permite la creación de componentes y librerías que pueden ser utilizados como bloques constructores de aplicaciones; existen dos tipos de bloques básicos: \textit{software} - que ejecutan una función determinada (secuencia de instrucciones) en el procesador de la plataforma, o \textit{software-hardware} - que controla una tarea hardware implementada en la FPGA (periféricos dedicados); en la descripción del componente es necesario incluir el segmento de código (genérico) en C que implementa la función deseada, SIE\_CG se encarga de unir estos segmentos de código en un solo código fuente (ver figura \ref{SIECG_flow}) y generar la aplicación que debe ser ejecutada en la plataforma robótica para obtener la funcionalidad deseada. En la figura \ref{SIECG_flow} podemos obervar el componente software \textit{while} equivalente a la sentencia \textit{\textbf{while (1)}} de C; El componente \textit{Frame Buffer Print Line} imprime dos mensajes de texto en la pantalla utilizando el buffer de video de Linux \textit{/dev/fb0}: \textit{Executing Code...} y \textit{CHA[0]}; el segundo componente \textit{ADC Single Channel} controla un periférico que maneja un conversor serial de ocho canales, el resultado de la conversión del canal 0 se imprime en consola y se muestra en la pantalla de SIEBOT en forma numérica y en una gráfica de barras.



\section{Conclusiones y Trabajo Futuro}

Este artículo presenta dos plataformas robóticas \textit{copyleft hardware} que utilizan el sistema operativo Linux y pueden ser utilizadas en centros de formación de varios niveles, o como base de desarrollos comerciales.

Se presentaron dos entornos de programación gráfico que facilitan el proceso de aprendizaje, ayudando a adquirir habilidades en programadores principiantes relacionadas con algoritmia y pensamiento estructurado; abstrayendo la complejidad de la sintáxis en una interfaz gráfica de alto nivel.

En este momento ambas plataformas se encuentran en proceso de producción en masa, y se está trabajando en el contenido de los programas académicos que se utilizarán en educación básica y media. El primer piloto se implementará en el Instituto Técnico Central \footnote{http://www.itc.edu.co}, en donde, se presentan los tres ciclos de interés: enseñanza media, técnica y profesional.

Este tipo de trabajos ayuda a difundir el conocimiento adquirido en años de investigación en procesos de fabricació y metodologías de diseño en sistemas digitales, proporcionando un ahorro de tiempo y dinero considerable a quien lo utilice.

\section{Bibliografía}

\bibliography{./biblio_EL.bib}





\end{document}
